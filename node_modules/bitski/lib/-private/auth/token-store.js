"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenStore = void 0;
const constants_1 = require("../constants");
const access_token_1 = require("./access-token");
const decoders_1 = require("decoders");
class TokenStore {
    constructor(clientId, store) {
        var _a, _b;
        this.clientId = clientId;
        this.store = store;
        this.loadTokensFromCache();
        (_b = (_a = this.store).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, () => this.loadTokensFromCache());
    }
    async getCurrentToken() {
        const accessToken = await this.accessToken;
        if (accessToken && !accessToken.expired) {
            return accessToken.token;
        }
    }
    async getCurrentIdToken() {
        const idToken = await this.idToken;
        const accessToken = await this.accessToken;
        if (idToken && accessToken && !accessToken.expired) {
            return idToken;
        }
    }
    getRefreshToken() {
        return this.refreshToken;
    }
    get idTokenKey() {
        return `${constants_1.ID_TOKEN_KEY}.${this.clientId}`;
    }
    get accessTokenKey() {
        return `${constants_1.ACCESS_TOKEN_KEY}.${this.clientId}`;
    }
    get refreshTokenKey() {
        return `${constants_1.REFRESH_TOKEN_KEY}.${this.clientId}`;
    }
    loadTokensFromCache() {
        this.accessToken = Promise.resolve(this.store.getItem(this.accessTokenKey))
            .then((accessTokenString) => {
            const accessTokenResult = decoders_1.string.decode(accessTokenString);
            if (accessTokenResult.value) {
                return access_token_1.AccessToken.fromString(accessTokenResult.value);
            }
        })
            .catch(() => {
            console.log('Could not parse accessToken, setting to undefined');
            return undefined;
        });
        this.idToken = Promise.resolve(this.store.getItem(this.idTokenKey))
            .then((token) => decoders_1.string.decode(token).value)
            .catch(() => {
            console.log('Could not parse idToken, setting to undefined');
            return undefined;
        });
        this.refreshToken = Promise.resolve(this.store.getItem(this.refreshTokenKey))
            .then((token) => decoders_1.string.decode(token).value)
            .catch(() => {
            console.log('Could not parse refreshToken, setting to undefined');
            return undefined;
        });
    }
    persistTokenResponse(response) {
        const parsedToken = access_token_1.AccessToken.fromTokenResponse(response);
        this.store.setItem(this.accessTokenKey, parsedToken.toStorageString());
        this.accessToken = Promise.resolve(parsedToken);
        this.store.setItem(this.idTokenKey, response.idToken);
        this.idToken = Promise.resolve(response.idToken);
        if (response.refreshToken) {
            this.store.setItem(this.refreshTokenKey, response.refreshToken);
            this.refreshToken = Promise.resolve(response.refreshToken);
        }
    }
    async invalidateCurrentToken() {
        this.accessToken = Promise.resolve(undefined);
        this.idToken = Promise.resolve(undefined);
        await Promise.all([
            this.store.clearItem(this.accessTokenKey),
            this.store.clearItem(this.idTokenKey),
        ]);
    }
    async clear() {
        this.accessToken = Promise.resolve(undefined);
        this.idToken = Promise.resolve(undefined);
        this.refreshToken = Promise.resolve(undefined);
        await Promise.all([
            this.store.clearItem(this.refreshTokenKey),
            this.store.clearItem(this.accessTokenKey),
            this.store.clearItem(this.idTokenKey),
        ]);
    }
}
exports.TokenStore = TokenStore;
//# sourceMappingURL=token-store.js.map