"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitskiProviderShim = exports.createResponse = void 0;
const eth_provider_types_1 = require("eth-provider-types");
const numbers_1 = require("./-private/utils/numbers");
// gotta keep it within MAX_SAFE_INTEGER
const extraDigits = 3;
function createRandomId() {
    // 13 time digits
    const datePart = new Date().getTime() * Math.pow(10, extraDigits);
    // 3 random digits
    const extraPart = Math.floor(Math.random() * Math.pow(10, extraDigits));
    // 16 digits
    return datePart + extraPart;
}
function createResponse(error, result) {
    return {
        id: createRandomId(),
        jsonrpc: '2.0',
        error,
        result,
    };
}
exports.createResponse = createResponse;
class BitskiProviderShim {
    constructor(loadSdk, options = {}) {
        this.loadSdk = loadSdk;
        this.options = options;
    }
    loadProvider() {
        if (!this.providerPromise) {
            this.providerPromise = this.loadSdk().then((sdk) => {
                if (!sdk) {
                    throw new Error('Bitski SDK not found');
                }
                return sdk.createProvider(this.options);
            });
        }
        return this.providerPromise;
    }
    // TODO: Update types in v4 to use eth-provider-types
    async request({ method, params = [] }) {
        const provider = await this.loadProvider();
        return provider.request({ method: method, params: params });
    }
    on(eventName, listener) {
        this.loadProvider().then((provider) => provider.on(eventName, listener));
    }
    removeListener(eventName, listener) {
        this.loadProvider().then((provider) => provider.removeListener(eventName, listener));
    }
    send(methodOrPayload, paramsOrCallback) {
        if (typeof methodOrPayload !== 'string' && !Array.isArray(paramsOrCallback)) {
            return this.sendAsync(methodOrPayload, paramsOrCallback);
        }
        return this.request({ method: methodOrPayload, params: paramsOrCallback })
            .then((result) => {
            return createResponse(undefined, result);
        })
            .catch((err) => {
            return createResponse(err);
        });
    }
    /**
     * @deprecated Please use `.request` instead.
     */
    sendAsync(payload, callback) {
        this.request(payload)
            .then((response) => {
            callback(null, createResponse(undefined, response));
        })
            .catch((err) => {
            callback(err);
        });
    }
    // method used externally to set provider
    setNetwork(network) {
        this.providerPromise = this.loadProvider().then(async (provider) => {
            await provider.request({
                method: eth_provider_types_1.EthMethod.wallet_addEthereumChain,
                params: [
                    {
                        chainId: (0, numbers_1.toHex)(network.chainId),
                        rpcUrls: [network.rpcUrl],
                    },
                ],
            });
            await provider.request({
                method: eth_provider_types_1.EthMethod.wallet_switchEthereumChain,
                params: [{ chainId: (0, numbers_1.toHex)(network.chainId) }],
            });
            return provider;
        });
    }
    supportsSubscriptions() {
        return true;
    }
    isConnected() {
        return true;
    }
    /**
     * @deprecated currentBlock is no longer exposed directly, use subscriptions or filters instead
     */
    get currentBlock() {
        return undefined;
    }
    /**
     * @deprecated call request with eth_subscribe directly instead
     */
    subscribe(_subscribeMethod, subscriptionMethod, params) {
        console.warn('BitskiProvider#subscribe() is deprecated. It is no longer necessary to call this method.');
        return Promise.resolve('');
    }
    /**
     * @deprecated call request with eth_ussubscribe directly instead
     */
    unsubscribe(subscriptionId, _unsubscribeMethod) {
        console.warn('BitskiProvider#unsubscribe() is deprecated. It is no longer necessary to call this method.');
        return Promise.resolve(true);
    }
    /**
     * @deprecated BitskiSDK is always running
     */
    isRunning() {
        console.warn('BitskiProvider#isRunning() is deprecated. It is no longer necessary to call this method.');
        return true;
    }
    /**
     * @deprecated BitskiSDK does not need to be started anymore
     */
    start() {
        console.warn('BitskiProvider#start() is deprecated. It is no longer necessary to call this method.');
    }
    /**
     * @deprecated BitskiSDK does not need to be stopped anymore. Unsubscribe from all active
     * subscriptions instead.
     */
    stop() {
        console.warn('BitskiProvider#stop() is deprecated. It is no longer necessary to call this method.');
    }
    /**
     * @deprecated BitskiSDK does not support custom providers anymore
     */
    addProvider(_source, _index) {
        console.warn('BitskiProvider#addProvider() is deprecated. It is no longer necessary to call this method.');
    }
    /**
     * @deprecated BitskiSDK does not support custom providers anymore
     */
    removeProvider(source) {
        console.warn('BitskiProvider#removeProvider() is deprecated. It is no longer necessary to call this method.');
    }
}
exports.BitskiProviderShim = BitskiProviderShim;
//# sourceMappingURL=provider-shim.js.map