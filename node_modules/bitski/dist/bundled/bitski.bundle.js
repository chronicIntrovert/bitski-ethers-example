(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Bitski = {}));
})(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
					var args = [null];
					args.push.apply(args, arguments);
					var Ctor = Function.bind.apply(f, args);
					return new Ctor();
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var ethProviderTypes = {};

	(function (exports) {
		/**
		 * Provider API types from: https://eips.ethereum.org/EIPS/eip-1193#appendix-i-consumer-facing-api-documentation
		 * JSON RPC API types from: https://ethereum.org/en/developers/docs/apis/json-rpc/#web3_clientversion
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.EthProviderMessageType = exports.EthEvent = exports.EthProviderRpcErrorCode = exports.EthBlockNumberTag = exports.EthMethod = void 0;
		(function (EthMethod) {
		    EthMethod["web3_clientVersion"] = "web3_clientVersion";
		    EthMethod["web3_sha3"] = "web3_sha3";
		    EthMethod["net_version"] = "net_version";
		    EthMethod["net_listening"] = "net_listening";
		    EthMethod["net_peerCount"] = "net_peerCount";
		    EthMethod["eth_protocolVersion"] = "eth_protocolVersion";
		    EthMethod["eth_syncing"] = "eth_syncing";
		    EthMethod["eth_coinbase"] = "eth_coinbase";
		    EthMethod["eth_createAccessList"] = "eth_createAccessList";
		    EthMethod["eth_feeHistory"] = "eth_feeHistory";
		    EthMethod["eth_mining"] = "eth_mining";
		    EthMethod["eth_hashrate"] = "eth_hashrate";
		    EthMethod["eth_gasPrice"] = "eth_gasPrice";
		    EthMethod["eth_accounts"] = "eth_accounts";
		    EthMethod["eth_requestAccounts"] = "eth_requestAccounts";
		    EthMethod["eth_blockNumber"] = "eth_blockNumber";
		    EthMethod["eth_getBalance"] = "eth_getBalance";
		    EthMethod["eth_getStorageAt"] = "eth_getStorageAt";
		    EthMethod["eth_getTransactionCount"] = "eth_getTransactionCount";
		    EthMethod["eth_getBlockTransactionCountByHash"] = "eth_getBlockTransactionCountByHash";
		    EthMethod["eth_getBlockTransactionCountByNumber"] = "eth_getBlockTransactionCountByNumber";
		    EthMethod["eth_getUncleCountByBlockHash"] = "eth_getUncleCountByBlockHash";
		    EthMethod["eth_getUncleCountByBlockNumber"] = "eth_getUncleCountByBlockNumber";
		    EthMethod["eth_getCode"] = "eth_getCode";
		    EthMethod["eth_sign"] = "eth_sign";
		    EthMethod["eth_signTransaction"] = "eth_signTransaction";
		    EthMethod["eth_signTypedData"] = "eth_signTypedData";
		    EthMethod["eth_signTypedData_v1"] = "eth_signTypedData_v1";
		    EthMethod["eth_signTypedData_v3"] = "eth_signTypedData_v3";
		    EthMethod["eth_signTypedData_v4"] = "eth_signTypedData_v4";
		    EthMethod["eth_sendTransaction"] = "eth_sendTransaction";
		    EthMethod["eth_sendRawTransaction"] = "eth_sendRawTransaction";
		    EthMethod["eth_call"] = "eth_call";
		    EthMethod["eth_estimateGas"] = "eth_estimateGas";
		    EthMethod["eth_getBlockByHash"] = "eth_getBlockByHash";
		    EthMethod["eth_getBlockByNumber"] = "eth_getBlockByNumber";
		    EthMethod["eth_getTransactionByHash"] = "eth_getTransactionByHash";
		    EthMethod["eth_getTransactionByBlockHashAndIndex"] = "eth_getTransactionByBlockHashAndIndex";
		    EthMethod["eth_getTransactionByBlockNumberAndIndex"] = "eth_getTransactionByBlockNumberAndIndex";
		    EthMethod["eth_getTransactionReceipt"] = "eth_getTransactionReceipt";
		    EthMethod["eth_getUncleByBlockHashAndIndex"] = "eth_getUncleByBlockHashAndIndex";
		    EthMethod["eth_getUncleByBlockNumberAndIndex"] = "eth_getUncleByBlockNumberAndIndex";
		    EthMethod["eth_maxPriorityFeePerGas"] = "eth_maxPriorityFeePerGas";
		    EthMethod["eth_newFilter"] = "eth_newFilter";
		    EthMethod["eth_newBlockFilter"] = "eth_newBlockFilter";
		    EthMethod["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
		    EthMethod["eth_uninstallFilter"] = "eth_uninstallFilter";
		    EthMethod["eth_getFilterChanges"] = "eth_getFilterChanges";
		    EthMethod["eth_getFilterLogs"] = "eth_getFilterLogs";
		    EthMethod["eth_getLogs"] = "eth_getLogs";
		    EthMethod["eth_getProof"] = "eth_getProof";
		    EthMethod["eth_getWork"] = "eth_getWork";
		    EthMethod["eth_submitWork"] = "eth_submitWork";
		    EthMethod["eth_submitHashrate"] = "eth_submitHashrate";
		    EthMethod["eth_chainId"] = "eth_chainId";
		    EthMethod["eth_subscribe"] = "eth_subscribe";
		    EthMethod["eth_unsubscribe"] = "eth_unsubscribe";
		    EthMethod["wallet_addEthereumChain"] = "wallet_addEthereumChain";
		    EthMethod["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
		    EthMethod["wallet_requestPermissions"] = "wallet_requestPermissions";
		    EthMethod["wallet_getPermissions"] = "wallet_getPermissions";
		})(exports.EthMethod || (exports.EthMethod = {}));
		(function (EthBlockNumberTag) {
		    EthBlockNumberTag["Latest"] = "latest";
		    EthBlockNumberTag["Earliest"] = "earliest";
		    EthBlockNumberTag["Pending"] = "pending";
		})(exports.EthBlockNumberTag || (exports.EthBlockNumberTag = {}));
		(function (EthProviderRpcErrorCode) {
		    EthProviderRpcErrorCode[EthProviderRpcErrorCode["UserRejectedRequest"] = 4001] = "UserRejectedRequest";
		    EthProviderRpcErrorCode[EthProviderRpcErrorCode["Unauthorized"] = 4100] = "Unauthorized";
		    EthProviderRpcErrorCode[EthProviderRpcErrorCode["UnsupportedMethod"] = 4200] = "UnsupportedMethod";
		    EthProviderRpcErrorCode[EthProviderRpcErrorCode["Disconnected"] = 4900] = "Disconnected";
		    EthProviderRpcErrorCode[EthProviderRpcErrorCode["ChainDisconnected"] = 4901] = "ChainDisconnected";
		})(exports.EthProviderRpcErrorCode || (exports.EthProviderRpcErrorCode = {}));
		(function (EthEvent) {
		    EthEvent["message"] = "message";
		    EthEvent["connect"] = "connect";
		    EthEvent["disconnect"] = "disconnect";
		    EthEvent["chainChanged"] = "chainChanged";
		    EthEvent["accountsChanged"] = "accountsChanged";
		    EthEvent["data"] = "data";
		})(exports.EthEvent || (exports.EthEvent = {}));
		(function (EthProviderMessageType) {
		    EthProviderMessageType["eth_subscription"] = "eth_subscription";
		})(exports.EthProviderMessageType || (exports.EthProviderMessageType = {}));
		
	} (ethProviderTypes));

	var dist$3 = {};

	var classes = {};

	var fastSafeStringify = stringify$1;
	stringify$1.default = stringify$1;
	stringify$1.stable = deterministicStringify;
	stringify$1.stableStringify = deterministicStringify;

	var LIMIT_REPLACE_NODE = '[...]';
	var CIRCULAR_REPLACE_NODE = '[Circular]';

	var arr = [];
	var replacerStack = [];

	function defaultOptions () {
	  return {
	    depthLimit: Number.MAX_SAFE_INTEGER,
	    edgesLimit: Number.MAX_SAFE_INTEGER
	  }
	}

	// Regular stringify
	function stringify$1 (obj, replacer, spacer, options) {
	  if (typeof options === 'undefined') {
	    options = defaultOptions();
	  }

	  decirc(obj, '', 0, [], undefined, 0, options);
	  var res;
	  try {
	    if (replacerStack.length === 0) {
	      res = JSON.stringify(obj, replacer, spacer);
	    } else {
	      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
	    }
	  } catch (_) {
	    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
	  } finally {
	    while (arr.length !== 0) {
	      var part = arr.pop();
	      if (part.length === 4) {
	        Object.defineProperty(part[0], part[1], part[3]);
	      } else {
	        part[0][part[1]] = part[2];
	      }
	    }
	  }
	  return res
	}

	function setReplace (replace, val, k, parent) {
	  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
	  if (propertyDescriptor.get !== undefined) {
	    if (propertyDescriptor.configurable) {
	      Object.defineProperty(parent, k, { value: replace });
	      arr.push([parent, k, val, propertyDescriptor]);
	    } else {
	      replacerStack.push([val, k, replace]);
	    }
	  } else {
	    parent[k] = replace;
	    arr.push([parent, k, val]);
	  }
	}

	function decirc (val, k, edgeIndex, stack, parent, depth, options) {
	  depth += 1;
	  var i;
	  if (typeof val === 'object' && val !== null) {
	    for (i = 0; i < stack.length; i++) {
	      if (stack[i] === val) {
	        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
	        return
	      }
	    }

	    if (
	      typeof options.depthLimit !== 'undefined' &&
	      depth > options.depthLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    if (
	      typeof options.edgesLimit !== 'undefined' &&
	      edgeIndex + 1 > options.edgesLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    stack.push(val);
	    // Optimize for Arrays. Big arrays could kill the performance otherwise!
	    if (Array.isArray(val)) {
	      for (i = 0; i < val.length; i++) {
	        decirc(val[i], i, i, stack, val, depth, options);
	      }
	    } else {
	      var keys = Object.keys(val);
	      for (i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        decirc(val[key], key, i, stack, val, depth, options);
	      }
	    }
	    stack.pop();
	  }
	}

	// Stable-stringify
	function compareFunction (a, b) {
	  if (a < b) {
	    return -1
	  }
	  if (a > b) {
	    return 1
	  }
	  return 0
	}

	function deterministicStringify (obj, replacer, spacer, options) {
	  if (typeof options === 'undefined') {
	    options = defaultOptions();
	  }

	  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
	  var res;
	  try {
	    if (replacerStack.length === 0) {
	      res = JSON.stringify(tmp, replacer, spacer);
	    } else {
	      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
	    }
	  } catch (_) {
	    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
	  } finally {
	    // Ensure that we restore the object as it was.
	    while (arr.length !== 0) {
	      var part = arr.pop();
	      if (part.length === 4) {
	        Object.defineProperty(part[0], part[1], part[3]);
	      } else {
	        part[0][part[1]] = part[2];
	      }
	    }
	  }
	  return res
	}

	function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
	  depth += 1;
	  var i;
	  if (typeof val === 'object' && val !== null) {
	    for (i = 0; i < stack.length; i++) {
	      if (stack[i] === val) {
	        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
	        return
	      }
	    }
	    try {
	      if (typeof val.toJSON === 'function') {
	        return
	      }
	    } catch (_) {
	      return
	    }

	    if (
	      typeof options.depthLimit !== 'undefined' &&
	      depth > options.depthLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    if (
	      typeof options.edgesLimit !== 'undefined' &&
	      edgeIndex + 1 > options.edgesLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    stack.push(val);
	    // Optimize for Arrays. Big arrays could kill the performance otherwise!
	    if (Array.isArray(val)) {
	      for (i = 0; i < val.length; i++) {
	        deterministicDecirc(val[i], i, i, stack, val, depth, options);
	      }
	    } else {
	      // Create a temporary object in the required way
	      var tmp = {};
	      var keys = Object.keys(val).sort(compareFunction);
	      for (i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        deterministicDecirc(val[key], key, i, stack, val, depth, options);
	        tmp[key] = val[key];
	      }
	      if (typeof parent !== 'undefined') {
	        arr.push([parent, k, val]);
	        parent[k] = tmp;
	      } else {
	        return tmp
	      }
	    }
	    stack.pop();
	  }
	}

	// wraps replacer function to handle values we couldn't replace
	// and mark them as replaced value
	function replaceGetterValues (replacer) {
	  replacer =
	    typeof replacer !== 'undefined'
	      ? replacer
	      : function (k, v) {
	        return v
	      };
	  return function (key, val) {
	    if (replacerStack.length > 0) {
	      for (var i = 0; i < replacerStack.length; i++) {
	        var part = replacerStack[i];
	        if (part[1] === key && part[0] === val) {
	          val = part[2];
	          replacerStack.splice(i, 1);
	          break
	        }
	      }
	    }
	    return replacer.call(this, key, val)
	  }
	}

	Object.defineProperty(classes, "__esModule", { value: true });
	classes.EthereumProviderError = classes.EthereumRpcError = void 0;
	const fast_safe_stringify_1 = fastSafeStringify;
	/**
	 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
	 * per EIP-1474.
	 * Permits any integer error code.
	 */
	class EthereumRpcError extends Error {
	    constructor(code, message, data) {
	        if (!Number.isInteger(code)) {
	            throw new Error('"code" must be an integer.');
	        }
	        if (!message || typeof message !== 'string') {
	            throw new Error('"message" must be a nonempty string.');
	        }
	        super(message);
	        this.code = code;
	        if (data !== undefined) {
	            this.data = data;
	        }
	    }
	    /**
	     * Returns a plain object with all public class properties.
	     */
	    serialize() {
	        const serialized = {
	            code: this.code,
	            message: this.message,
	        };
	        if (this.data !== undefined) {
	            serialized.data = this.data;
	        }
	        if (this.stack) {
	            serialized.stack = this.stack;
	        }
	        return serialized;
	    }
	    /**
	     * Return a string representation of the serialized error, omitting
	     * any circular references.
	     */
	    toString() {
	        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
	    }
	}
	classes.EthereumRpcError = EthereumRpcError;
	/**
	 * Error subclass implementing Ethereum Provider errors per EIP-1193.
	 * Permits integer error codes in the [ 1000 <= 4999 ] range.
	 */
	class EthereumProviderError extends EthereumRpcError {
	    /**
	     * Create an Ethereum Provider JSON-RPC error.
	     * `code` must be an integer in the 1000 <= 4999 range.
	     */
	    constructor(code, message, data) {
	        if (!isValidEthProviderCode(code)) {
	            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
	        }
	        super(code, message, data);
	    }
	}
	classes.EthereumProviderError = EthereumProviderError;
	// Internal
	function isValidEthProviderCode(code) {
	    return Number.isInteger(code) && code >= 1000 && code <= 4999;
	}
	function stringifyReplacer(_, value) {
	    if (value === '[Circular]') {
	        return undefined;
	    }
	    return value;
	}

	var utils = {};

	var errorConstants = {};

	Object.defineProperty(errorConstants, "__esModule", { value: true });
	errorConstants.errorValues = errorConstants.errorCodes = void 0;
	errorConstants.errorCodes = {
	    rpc: {
	        invalidInput: -32000,
	        resourceNotFound: -32001,
	        resourceUnavailable: -32002,
	        transactionRejected: -32003,
	        methodNotSupported: -32004,
	        limitExceeded: -32005,
	        parse: -32700,
	        invalidRequest: -32600,
	        methodNotFound: -32601,
	        invalidParams: -32602,
	        internal: -32603,
	    },
	    provider: {
	        userRejectedRequest: 4001,
	        unauthorized: 4100,
	        unsupportedMethod: 4200,
	        disconnected: 4900,
	        chainDisconnected: 4901,
	    },
	};
	errorConstants.errorValues = {
	    '-32700': {
	        standard: 'JSON RPC 2.0',
	        message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
	    },
	    '-32600': {
	        standard: 'JSON RPC 2.0',
	        message: 'The JSON sent is not a valid Request object.',
	    },
	    '-32601': {
	        standard: 'JSON RPC 2.0',
	        message: 'The method does not exist / is not available.',
	    },
	    '-32602': {
	        standard: 'JSON RPC 2.0',
	        message: 'Invalid method parameter(s).',
	    },
	    '-32603': {
	        standard: 'JSON RPC 2.0',
	        message: 'Internal JSON-RPC error.',
	    },
	    '-32000': {
	        standard: 'EIP-1474',
	        message: 'Invalid input.',
	    },
	    '-32001': {
	        standard: 'EIP-1474',
	        message: 'Resource not found.',
	    },
	    '-32002': {
	        standard: 'EIP-1474',
	        message: 'Resource unavailable.',
	    },
	    '-32003': {
	        standard: 'EIP-1474',
	        message: 'Transaction rejected.',
	    },
	    '-32004': {
	        standard: 'EIP-1474',
	        message: 'Method not supported.',
	    },
	    '-32005': {
	        standard: 'EIP-1474',
	        message: 'Request limit exceeded.',
	    },
	    '4001': {
	        standard: 'EIP-1193',
	        message: 'User rejected the request.',
	    },
	    '4100': {
	        standard: 'EIP-1193',
	        message: 'The requested account and/or method has not been authorized by the user.',
	    },
	    '4200': {
	        standard: 'EIP-1193',
	        message: 'The requested method is not supported by this Ethereum provider.',
	    },
	    '4900': {
	        standard: 'EIP-1193',
	        message: 'The provider is disconnected from all chains.',
	    },
	    '4901': {
	        standard: 'EIP-1193',
	        message: 'The provider is disconnected from the specified chain.',
	    },
	};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
		const error_constants_1 = errorConstants;
		const classes_1 = classes;
		const FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
		const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
		const FALLBACK_ERROR = {
		    code: FALLBACK_ERROR_CODE,
		    message: getMessageFromCode(FALLBACK_ERROR_CODE),
		};
		exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
		/**
		 * Gets the message for a given code, or a fallback message if the code has
		 * no corresponding message.
		 */
		function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
		    if (Number.isInteger(code)) {
		        const codeString = code.toString();
		        if (hasKey(error_constants_1.errorValues, codeString)) {
		            return error_constants_1.errorValues[codeString].message;
		        }
		        if (isJsonRpcServerError(code)) {
		            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
		        }
		    }
		    return fallbackMessage;
		}
		exports.getMessageFromCode = getMessageFromCode;
		/**
		 * Returns whether the given code is valid.
		 * A code is only valid if it has a message.
		 */
		function isValidCode(code) {
		    if (!Number.isInteger(code)) {
		        return false;
		    }
		    const codeString = code.toString();
		    if (error_constants_1.errorValues[codeString]) {
		        return true;
		    }
		    if (isJsonRpcServerError(code)) {
		        return true;
		    }
		    return false;
		}
		exports.isValidCode = isValidCode;
		/**
		 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
		 * Merely copies the given error's values if it is already compatible.
		 * If the given error is not fully compatible, it will be preserved on the
		 * returned object's data.originalError property.
		 */
		function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false, } = {}) {
		    var _a, _b;
		    if (!fallbackError ||
		        !Number.isInteger(fallbackError.code) ||
		        typeof fallbackError.message !== 'string') {
		        throw new Error('Must provide fallback error with integer number code and string message.');
		    }
		    if (error instanceof classes_1.EthereumRpcError) {
		        return error.serialize();
		    }
		    const serialized = {};
		    if (error &&
		        typeof error === 'object' &&
		        !Array.isArray(error) &&
		        hasKey(error, 'code') &&
		        isValidCode(error.code)) {
		        const _error = error;
		        serialized.code = _error.code;
		        if (_error.message && typeof _error.message === 'string') {
		            serialized.message = _error.message;
		            if (hasKey(_error, 'data')) {
		                serialized.data = _error.data;
		            }
		        }
		        else {
		            serialized.message = getMessageFromCode(serialized.code);
		            serialized.data = { originalError: assignOriginalError(error) };
		        }
		    }
		    else {
		        serialized.code = fallbackError.code;
		        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
		        serialized.message = (message && typeof message === 'string'
		            ? message
		            : fallbackError.message);
		        serialized.data = { originalError: assignOriginalError(error) };
		    }
		    const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
		    if (shouldIncludeStack && error && stack && typeof stack === 'string') {
		        serialized.stack = stack;
		    }
		    return serialized;
		}
		exports.serializeError = serializeError;
		// Internal
		function isJsonRpcServerError(code) {
		    return code >= -32099 && code <= -32000;
		}
		function assignOriginalError(error) {
		    if (error && typeof error === 'object' && !Array.isArray(error)) {
		        return Object.assign({}, error);
		    }
		    return error;
		}
		function hasKey(obj, key) {
		    return Object.prototype.hasOwnProperty.call(obj, key);
		}
		
	} (utils));

	var errors$1 = {};

	Object.defineProperty(errors$1, "__esModule", { value: true });
	errors$1.ethErrors = void 0;
	const classes_1 = classes;
	const utils_1 = utils;
	const error_constants_1 = errorConstants;
	errors$1.ethErrors = {
	    rpc: {
	        /**
	         * Get a JSON RPC 2.0 Parse (-32700) error.
	         */
	        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
	        /**
	         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
	         */
	        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
	        /**
	         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
	         */
	        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
	        /**
	         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
	         */
	        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
	        /**
	         * Get a JSON RPC 2.0 Internal (-32603) error.
	         */
	        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
	        /**
	         * Get a JSON RPC 2.0 Server error.
	         * Permits integer error codes in the [ -32099 <= -32005 ] range.
	         * Codes -32000 through -32004 are reserved by EIP-1474.
	         */
	        server: (opts) => {
	            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
	                throw new Error('Ethereum RPC Server errors must provide single object argument.');
	            }
	            const { code } = opts;
	            if (!Number.isInteger(code) || code > -32005 || code < -32099) {
	                throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
	            }
	            return getEthJsonRpcError(code, opts);
	        },
	        /**
	         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
	         */
	        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
	        /**
	         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
	         */
	        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
	        /**
	         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
	         */
	        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
	        /**
	         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
	         */
	        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
	        /**
	         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
	         */
	        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
	        /**
	         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
	         */
	        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg),
	    },
	    provider: {
	        /**
	         * Get an Ethereum Provider User Rejected Request (4001) error.
	         */
	        userRejectedRequest: (arg) => {
	            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
	        },
	        /**
	         * Get an Ethereum Provider Unauthorized (4100) error.
	         */
	        unauthorized: (arg) => {
	            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
	        },
	        /**
	         * Get an Ethereum Provider Unsupported Method (4200) error.
	         */
	        unsupportedMethod: (arg) => {
	            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
	        },
	        /**
	         * Get an Ethereum Provider Not Connected (4900) error.
	         */
	        disconnected: (arg) => {
	            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
	        },
	        /**
	         * Get an Ethereum Provider Chain Not Connected (4901) error.
	         */
	        chainDisconnected: (arg) => {
	            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
	        },
	        /**
	         * Get a custom Ethereum Provider error.
	         */
	        custom: (opts) => {
	            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
	                throw new Error('Ethereum Provider custom errors must provide single object argument.');
	            }
	            const { code, message, data } = opts;
	            if (!message || typeof message !== 'string') {
	                throw new Error('"message" must be a nonempty string');
	            }
	            return new classes_1.EthereumProviderError(code, message, data);
	        },
	    },
	};
	// Internal
	function getEthJsonRpcError(code, arg) {
	    const [message, data] = parseOpts(arg);
	    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
	}
	function getEthProviderError(code, arg) {
	    const [message, data] = parseOpts(arg);
	    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
	}
	function parseOpts(arg) {
	    if (arg) {
	        if (typeof arg === 'string') {
	            return [arg];
	        }
	        else if (typeof arg === 'object' && !Array.isArray(arg)) {
	            const { message, data } = arg;
	            if (message && typeof message !== 'string') {
	                throw new Error('Must specify string message.');
	            }
	            return [message || undefined, data];
	        }
	    }
	    return [];
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
		const classes_1 = classes;
		Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function () { return classes_1.EthereumRpcError; } });
		Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function () { return classes_1.EthereumProviderError; } });
		const utils_1 = utils;
		Object.defineProperty(exports, "serializeError", { enumerable: true, get: function () { return utils_1.serializeError; } });
		Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function () { return utils_1.getMessageFromCode; } });
		const errors_1 = errors$1;
		Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function () { return errors_1.ethErrors; } });
		const error_constants_1 = errorConstants;
		Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function () { return error_constants_1.errorCodes; } });
		
	} (dist$3));

	/**
	 * parseNumber
	 * Converts a value that represents a number into a hex value.
	 * @param arg {string | number | BN} A number value to convert to hex.
	 * Can be a regular number, base-10 string, base-16 string, or BN instance.
	 * @returns {BN} BN instance representing the number
	 *
	 * (Adapted from ethereumjs-abi)
	 */
	function parseNumber(arg) {
	    const type = typeof arg;
	    if (type === 'string' || type === 'number') {
	        return BigInt(arg);
	    }
	    else if (arg.toArray) {
	        // assume this is a BN
	        return BigInt(arg.toString(10));
	    }
	    else {
	        throw dist$3.ethErrors.rpc.invalidInput('Argument is not a number');
	    }
	}
	function parseBitWidth(type, offset) {
	    // default to 256 bit if not specified
	    let size = 256;
	    // If type string is longer than offset, parse bits from the type string
	    if (type.length > offset) {
	        size = parseInt(type.substr(offset), 10);
	    }
	    // bit width must be a multiple of 8, and in the range 8-256.
	    if (size % 8 || size < 8 || size > 256) {
	        throw dist$3.ethErrors.rpc.invalidInput(`Invalid bit width ${type}`);
	    }
	    return size;
	}
	/**
	 * encodeNumber
	 * Takes a decimal string, hex string, regular number, or BN instance and returns a hex string in the specified format.
	 * Typically these conversions are done in web3, but until web3 adds direct support, this is necessary for normalizing
	 * numbers eth_signTypedData payloads.
	 * @param num The value to convert
	 * @param type The solidity ABI type to format the data as (eg. uint256, int8, etc). Only supports int and uint variants.
	 * @param compact boolean (default false). Whether to use compact encoding for uints, or pad with zeroes.
	 * @returns {string} A hex string formatted as the specified type.
	 */
	function encodeNumber(num, type, compact = false) {
	    if (type.startsWith('uint')) {
	        const size = parseBitWidth(type, 4); // start after 'uint'
	        const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.
	        const parsed = parseNumber(num);
	        // uint can never be negative
	        if (parsed < BigInt(0)) {
	            throw dist$3.ethErrors.rpc.invalidInput('Supplied uint is negative');
	        }
	        // Convert to hex, and prepend 0x
	        if (compact) {
	            return '0x' + parsed.toString(16);
	        }
	        return '0x' + parsed.toString(16).padStart(length, '0');
	    }
	    else if (type.startsWith('int')) {
	        // bit width must be a multiple of 8, and in the range 8-256.
	        const size = parseBitWidth(type, 3);
	        const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.
	        const parsed = parseNumber(num);
	        // Convert to twos complement at the bit size from the type, then convert value to hex
	        return '0x' + BigInt.asUintN(size, parsed).toString(16).padStart(length, '0');
	    }
	    else {
	        throw dist$3.ethErrors.rpc.invalidInput('Invalid type passed');
	    }
	}
	// A function that takes a number and returns a 0x-prefixed hex string
	const toHex = (num) => `0x${num.toString(16)}`;

	// URLs
	const BITSKI_API_BASE_URL = 'https://api.bitski.com/v1';
	const BITSKI_RPC_BASE_URL = 'https://api.bitski.com/v1/web3';
	const BITSKI_SIGNER_BASE_URL = 'https://sign.bitski.com';
	const IFRAME_MESSAGE_ORIGIN_ENDS_WITH = '.bitski.com';
	const SIGN_METHODS = [
	    ethProviderTypes.EthMethod.eth_sendTransaction,
	    ethProviderTypes.EthMethod.eth_signTransaction,
	    ethProviderTypes.EthMethod.eth_sign,
	    ethProviderTypes.EthMethod.eth_signTypedData,
	    ethProviderTypes.EthMethod.eth_signTypedData_v3,
	    ethProviderTypes.EthMethod.eth_signTypedData_v4,
	    // Kept for legacy compat
	    'personal_sign',
	];
	// JSON-RPC methods that require Authorization header
	[
	    ethProviderTypes.EthMethod.eth_requestAccounts,
	    ethProviderTypes.EthMethod.eth_accounts,
	    ...SIGN_METHODS,
	];
	// Errors that indicate the access token is not valid
	const UNAUTHORIZED_ERRORS = [
	    'Missing auth',
	    'Invalid client id',
	    'Not Authorized',
	];
	// These are chains we support on our backend, e.g. for nonce management and such
	const SUPPORTED_CHAIN_IDS = [
	    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
	    28, 29, 30, 31, 32, 33, 34, 35, 38, 40, 41, 42, 43, 44, 45, 50, 51, 52, 53, 54, 55, 56, 57, 58,
	    59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 74, 76, 77, 78, 79, 80, 81, 82, 83, 85, 86, 87,
	    88, 89, 90, 91, 92, 93, 95, 96, 97, 99, 100, 101, 102, 105, 106, 107, 108, 110, 111, 122, 123,
	    124, 125, 126, 127, 128, 137, 141, 142, 162, 163, 168, 170, 172, 186, 188, 189, 199, 200, 211,
	    218, 222, 225, 226, 246, 250, 256, 258, 262, 269, 280, 288, 300, 321, 322, 324, 333, 335, 336,
	    338, 361, 363, 364, 365, 369, 385, 420, 499, 512, 513, 555, 558, 588, 595, 600, 666, 686, 700,
	    707, 708, 721, 777, 787, 788, 803, 820, 821, 880, 888, 900, 901, 902, 903, 940, 941, 942, 977,
	    998, 999, 1001, 1007, 1008, 1010, 1012, 1022, 1023, 1024, 1028, 1030, 1088, 1139, 1140, 1197,
	    1201, 1202, 1213, 1214, 1280, 1284, 1285, 1286, 1287, 1288, 1337, 1618, 1620, 1657, 1688, 1856,
	    1898, 1984, 1987, 2001, 2020, 2021, 2022, 2025, 2100, 2101, 2152, 2153, 2213, 2221, 2559, 3000,
	    3001, 3331, 3333, 3334, 3400, 3500, 3690, 3966, 3967, 4002, 4102, 4689, 4690, 4918, 5197, 5315,
	    5700, 5777, 5851, 5869, 6626, 7341, 7878, 8000, 8001, 8029, 8080, 8217, 8285, 8723, 8724, 8888,
	    8995, 9000, 9001, 9100, 9527, 9999, 10000, 10001, 10101, 10823, 11111, 11437, 12051, 12052, 13381,
	    16000, 16001, 19845, 21337, 21816, 24484, 24734, 31102, 31337, 32659, 39797, 42069, 42161, 42220,
	    42261, 42262, 43110, 43113, 43114, 44787, 45000, 47805, 49797, 53935, 55555, 55556, 60000, 60001,
	    60002, 60103, 62320, 63000, 63001, 69420, 70000, 70001, 70002, 70103, 71393, 73799, 78110, 80001,
	    99998, 99999, 100000, 100001, 100002, 100003, 100004, 100005, 100006, 100007, 100008, 108801,
	    110000, 110001, 110002, 110003, 110004, 110005, 110006, 110007, 110008, 200101, 200625, 201018,
	    201030, 210425, 234666, 246529, 246785, 281121, 333888, 333999, 421611, 444900, 666666, 888888,
	    955305, 1313114, 1313500, 1337702, 2203181, 7762959, 11155111, 13371337, 18289463, 20181205,
	    28945486, 35855456, 61717561, 99415706, 192837465, 245022926, 245022934, 245022940, 311752642,
	    356256156, 486217935, 1122334455, 1313161554, 1313161555, 1313161556, 1666600000, 1666600001,
	    1666600002, 1666600003, 1666700000, 1666700001, 1666700002, 1666700003, 2021121117, 3125659152,
	    4216137055, 11297108099, 11297108109, 197710212030, 197710212031, 6022140761023, 868455272153094,
	].map(toHex);
	const makeChainDef = (chainId, chainName, blockExplorerUrl) => ({
	    chainId: toHex(chainId),
	    rpcUrls: [`https://api.bitski.com/v1/web3/chains/${chainId}`],
	    chainName,
	    blockExplorerUrls: [blockExplorerUrl],
	});
	const Mainnet = makeChainDef(1, 'Mainnet', 'https://etherscan.io/');
	const Goerli = makeChainDef(5, 'Görli', 'https://goerli.etherscan.io/');
	const Polygon = makeChainDef(137, 'Polygon', 'https://polygonscan.com/');
	const Mumbai = makeChainDef(80001, 'Mumbai', 'https://mumbai.polygonscan.com/');
	const ArbitrumOne = makeChainDef(42161, 'ArbitrumOne', 'https://arbiscan.io/');
	const Optimism = makeChainDef(10, 'Optimism', 'https://optimistic.etherscan.io/');
	const ZkSyncEra = makeChainDef(324, 'zkSync Era', 'https://explorer.zksync.io');
	const ZkSyncEraTestnet = makeChainDef(280, 'zkSync Era Testnet', 'https://goerli.explorer.zksync.io');
	const BinanceSmartChain = makeChainDef(56, 'BinanceSmartChain', 'https://bscscan.com/');
	const BinanceSmartChainTestnet = makeChainDef(97, 'BinanceSmartChainTestnet', 'https://testnet.bscscan.com/');
	const DEFAULT_CHAINS = [
	    Mainnet,
	    Goerli,
	    Polygon,
	    Mumbai,
	    ArbitrumOne,
	    Optimism,
	    ZkSyncEra,
	    ZkSyncEraTestnet,
	    BinanceSmartChain,
	    BinanceSmartChainTestnet,
	];

	function _extends() {
	  _extends = Object.assign
	    ? Object.assign.bind()
	    : function (target) {
	        for (var i = 1; i < arguments.length; i++) {
	          var source = arguments[i];
	          for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	              target[key] = source[key];
	            }
	          }
	        }
	        return target
	      };
	  return _extends.apply(this, arguments)
	}

	var _register = new WeakSet();

	function brand(ann) {
	  _register.add(ann);

	  return ann
	}

	function object$2(fields, text) {
	  return brand({
	    type: 'object',
	    fields: fields,
	    text: text,
	  })
	}
	function array$2(items, text) {
	  return brand({
	    type: 'array',
	    items: items,
	    text: text,
	  })
	}
	function func$1(text) {
	  return brand({
	    type: 'function',
	    text: text,
	  })
	}
	function unknown$1(value, text) {
	  return brand({
	    type: 'unknown',
	    value: value,
	    text: text,
	  })
	}
	function scalar(value, text) {
	  return brand({
	    type: 'scalar',
	    value: value,
	    text: text,
	  })
	}
	function circularRef(text) {
	  return brand({
	    type: 'circular-ref',
	    text: text,
	  })
	}

	function updateText(annotation, text) {
	  if (text !== undefined) {
	    return brand(
	      _extends({}, annotation, {
	        text: text,
	      })
	    )
	  } else {
	    return annotation
	  }
	}

	function merge(objAnnotation, fields) {
	  var newFields = _extends({}, objAnnotation.fields, fields);

	  return object$2(newFields, objAnnotation.text)
	}
	function asAnnotation(thing) {
	  return typeof thing === 'object' && thing !== null && _register.has(thing) ? thing : undefined
	}

	function annotateArray(value, text, seen) {
	  seen.add(value);
	  var items = value.map(function (v) {
	    return annotate(v, undefined, seen)
	  });
	  return array$2(items, text)
	}

	function annotateObject(obj, text, seen) {
	  seen.add(obj);
	  var fields = {};
	  Object.keys(obj).forEach(function (key) {
	    var value = obj[key];
	    fields[key] = annotate(value, undefined, seen);
	  });
	  return object$2(fields, text)
	}

	function annotate(value, text, seen) {
	  if (value === null || value === undefined || typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'symbol' || typeof value.getMonth === 'function') {
	    return scalar(value, text)
	  }

	  var ann = asAnnotation(value);

	  if (ann) {
	    return updateText(ann, text)
	  }

	  if (Array.isArray(value)) {
	    if (seen.has(value)) {
	      return circularRef(text)
	    } else {
	      return annotateArray(value, text, seen)
	    }
	  }

	  if (typeof value === 'object') {
	    if (seen.has(value)) {
	      return circularRef(text)
	    } else {
	      return annotateObject(value, text, seen)
	    }
	  }

	  if (typeof value === 'function') {
	    return func$1(text)
	  }

	  return unknown$1(value, text)
	}

	function public_annotate(value, text) {
	  return annotate(value, text, new WeakSet())
	}

	function public_annotateObject(obj, text) {
	  return annotateObject(obj, text, new WeakSet())
	}

	var INDENT = '  ';

	function subtract(xs, ys) {
	  var result = new Set();
	  xs.forEach(function (x) {
	    if (!ys.has(x)) {
	      result.add(x);
	    }
	  });
	  return result
	}

	function asDate(value) {
	  return !!value && Object.prototype.toString.call(value) === '[object Date]' && !isNaN(value) ? value : null
	}
	function isMultiline(s) {
	  return s.indexOf('\n') >= 0
	}
	function indent(s, prefix) {
	  if (prefix === void 0) {
	    prefix = INDENT;
	  }

	  if (isMultiline(s)) {
	    return s
	      .split('\n')
	      .map(function (line) {
	        return '' + prefix + line
	      })
	      .join('\n')
	  } else {
	    return '' + prefix + s
	  }
	}

	function summarize(ann, keypath) {
	  if (keypath === void 0) {
	    keypath = [];
	  }

	  var result = [];

	  if (ann.type === 'array') {
	    var items = ann.items;
	    var index = 0;
	    items.forEach(function (ann) {
	      summarize(ann, [].concat(keypath, [index++])).forEach(function (item) {
	        return result.push(item)
	      });
	    });
	  } else if (ann.type === 'object') {
	    var fields = ann.fields;
	    Object.keys(fields).forEach(function (key) {
	      var value = fields[key];
	      summarize(value, [].concat(keypath, [key])).forEach(function (item) {
	        return result.push(item)
	      });
	    });
	  }

	  var text = ann.text;

	  if (!text) {
	    return result
	  }

	  var prefix;

	  if (keypath.length === 0) {
	    prefix = '';
	  } else if (keypath.length === 1) {
	    prefix = typeof keypath[0] === 'number' ? 'Value at index ' + keypath[0] + ': ' : 'Value at key ' + JSON.stringify(keypath[0]) + ': ';
	  } else {
	    prefix = 'Value at keypath ' + keypath.map(String).join('.') + ': ';
	  }

	  return [].concat(result, ['' + prefix + text])
	}

	function serializeString(s, width) {
	  if (width === void 0) {
	    width = 80;
	  }
	  var ser = JSON.stringify(s);

	  if (ser.length <= width) {
	    return ser
	  }

	  var truncated = s.substring(0, width - 15) + '...';
	  ser = JSON.stringify(truncated) + ' [truncated]';
	  return ser
	}

	function serializeArray(annotation, prefix) {
	  var items = annotation.items;

	  if (items.length === 0) {
	    return '[]'
	  }

	  var result = [];
	  items.forEach(function (item) {
	    var _serializeAnnotation = serializeAnnotation(item, '' + prefix + INDENT),
	      ser = _serializeAnnotation[0],
	      ann = _serializeAnnotation[1];

	    result.push('' + prefix + INDENT + ser + ',');

	    if (ann !== undefined) {
	      result.push(indent(ann, '' + prefix + INDENT));
	    }
	  });
	  return ['['].concat(result, [prefix + ']']).join('\n')
	}

	function serializeObject(annotation, prefix) {
	  var fields = annotation.fields;
	  var fieldNames = Object.keys(fields);

	  if (fieldNames.length === 0) {
	    return '{}'
	  }

	  var result = [];
	  fieldNames.forEach(function (key) {
	    var valueAnnotation = fields[key];
	    var kser = serializeValue(key);
	    var valPrefix = '' + prefix + INDENT + ' '.repeat(kser.length + 2);

	    var _serializeAnnotation2 = serializeAnnotation(valueAnnotation, '' + prefix + INDENT),
	      vser = _serializeAnnotation2[0],
	      vann = _serializeAnnotation2[1];

	    result.push('' + prefix + INDENT + kser + ': ' + vser + ',');

	    if (vann !== undefined) {
	      result.push(indent(vann, valPrefix));
	    }
	  });
	  return ['{'].concat(result, [prefix + '}']).join('\n')
	}

	function serializeValue(value) {
	  if (typeof value === 'string') {
	    return serializeString(value)
	  } else if (typeof value === 'number' || typeof value === 'boolean') {
	    return value.toString()
	  } else if (value === null) {
	    return 'null'
	  } else if (value === undefined) {
	    return 'undefined'
	  } else {
	    var valueAsDate = asDate(value);

	    if (valueAsDate !== null) {
	      return 'new Date(' + JSON.stringify(valueAsDate.toISOString()) + ')'
	    } else if (value instanceof Date) {
	      return '(Invalid Date)'
	    } else {
	      return '(unserializable)'
	    }
	  }
	}
	function serializeAnnotation(ann, prefix) {
	  if (prefix === void 0) {
	    prefix = '';
	  }
	  var serialized;

	  if (ann.type === 'array') {
	    serialized = serializeArray(ann, prefix);
	  } else if (ann.type === 'object') {
	    serialized = serializeObject(ann, prefix);
	  } else if (ann.type === 'function') {
	    serialized = '<function>';
	  } else if (ann.type === 'circular-ref') {
	    serialized = '<circular ref>';
	  } else if (ann.type === 'unknown') {
	    serialized = '???';
	  } else {
	    serialized = serializeValue(ann.value);
	  }

	  var text = ann.text;

	  if (text !== undefined) {
	    var sep = '^'.repeat(isMultiline(serialized) ? 1 : serialized.length);
	    return [serialized, [sep, text].join(isMultiline(text) ? '\n' : ' ')]
	  } else {
	    return [serialized, undefined]
	  }
	}
	function formatInline(ann) {
	  var _serializeAnnotation3 = serializeAnnotation(ann),
	    serialized = _serializeAnnotation3[0],
	    annotation = _serializeAnnotation3[1];

	  if (annotation !== undefined) {
	    return serialized + '\n' + annotation
	  } else {
	    return serialized
	  }
	}

	function ok(value) {
	  return {
	    ok: true,
	    value: value,
	    error: undefined,
	  }
	}

	function err(error) {
	  return {
	    ok: false,
	    value: undefined,
	    error: error,
	  }
	}

	function noThrow(fn) {
	  return function (t) {
	    try {
	      var v = fn(t);
	      return ok(v)
	    } catch (e) {
	      return err(public_annotate(t, e instanceof Error ? e.message : String(e)))
	    }
	  }
	}

	function format$1(err, formatter) {
	  var formatted = formatter(err);

	  if (typeof formatted === 'string') {
	    var _err = new Error('\n' + formatted);

	    _err.name = 'Decoding error';
	    return _err
	  } else {
	    return formatted
	  }
	}

	function define$1(fn) {
	  function decode(blob) {
	    return fn(blob, ok, function (msg) {
	      return err(typeof msg === 'string' ? public_annotate(blob, msg) : msg)
	    })
	  }

	  function verify(blob, formatter) {
	    if (formatter === void 0) {
	      formatter = formatInline;
	    }

	    var result = decode(blob);

	    if (result.ok) {
	      return result.value
	    } else {
	      throw format$1(result.error, formatter)
	    }
	  }

	  function value(blob) {
	    return decode(blob).value
	  }

	  function transform(transformFn) {
	    return then(noThrow(transformFn))
	  }

	  function refine(predicateFn, errmsg) {
	    return reject(function (value) {
	      return predicateFn(value) ? null : errmsg
	    })
	  }

	  function then(next) {
	    return define$1(function (blob, ok, err) {
	      var result = decode(blob);
	      return result.ok ? next(result.value, ok, err) : result
	    })
	  }

	  function reject(rejectFn) {
	    return then(function (value, ok, err) {
	      var errmsg = rejectFn(value);
	      return errmsg === null ? ok(value) : err(typeof errmsg === 'string' ? public_annotate(value, errmsg) : errmsg)
	    })
	  }

	  function describe(message) {
	    return define$1(function (blob, _, err) {
	      var result = decode(blob);

	      if (result.ok) {
	        return result
	      } else {
	        return err(public_annotate(result.error, message))
	      }
	    })
	  }

	  function peek_UNSTABLE(next) {
	    return define$1(function (blob, ok, err) {
	      var result = decode(blob);
	      return result.ok ? next([blob, result.value], ok, err) : result
	    })
	  }

	  return Object.freeze({
	    verify: verify,
	    value: value,
	    decode: decode,
	    transform: transform,
	    refine: refine,
	    reject: reject,
	    describe: describe,
	    then: then,
	    peek_UNSTABLE: peek_UNSTABLE,
	  })
	}

	var pojo = define$1(function (blob, ok, err) {
	  return blob !== null && blob !== undefined && typeof blob === 'object' && Object.prototype.toString.call(blob) === '[object Object]' ? ok(blob) : err('Must be an object')
	});

	function object$1(decodersByKey) {
	  var knownKeys = new Set(Object.keys(decodersByKey));
	  return pojo.then(function (plainObj, ok, err) {
	    var actualKeys = new Set(Object.keys(plainObj));

	    var missingKeys = subtract(knownKeys, actualKeys);
	    var record = {};
	    var errors = null;
	    Object.keys(decodersByKey).forEach(function (key) {
	      var decoder = decodersByKey[key];
	      var rawValue = plainObj[key];
	      var result = decoder.decode(rawValue);

	      if (result.ok) {
	        var value = result.value;

	        if (value !== undefined) {
	          record[key] = value;
	        }

	        missingKeys['delete'](key);
	      } else {
	        var ann = result.error;

	        if (rawValue === undefined) {
	          missingKeys.add(key);
	        } else {
	          if (errors === null) {
	            errors = {};
	          }

	          errors[key] = ann;
	        }
	      }
	    });

	    if (errors || missingKeys.size > 0) {
	      var objAnn = public_annotateObject(plainObj);

	      if (errors) {
	        objAnn = merge(objAnn, errors);
	      }

	      if (missingKeys.size > 0) {
	        var errMsg = Array.from(missingKeys)
	          .map(function (key) {
	            return '"' + key + '"'
	          })
	          .join(', ');
	        var pluralized = missingKeys.size > 1 ? 'keys' : 'key';
	        objAnn = updateText(objAnn, 'Missing ' + pluralized + ': ' + errMsg);
	      }

	      return err(objAnn)
	    }

	    return ok(record)
	  })
	}

	function instanceOf(klass) {
	  return define$1(function (blob, ok, err) {
	    return blob instanceof klass ? ok(blob) : err('Must be ' + klass.name + ' instance')
	  })
	}

	var EITHER_PREFIX = 'Either:\n';

	function itemize(s) {
	  return '-' + indent(s).substring(1)
	}

	function nest(errText) {
	  return errText.startsWith(EITHER_PREFIX) ? errText.substr(EITHER_PREFIX.length) : itemize(errText)
	}

	function _either() {
	  for (var _len = arguments.length, decoders = new Array(_len), _key = 0; _key < _len; _key++) {
	    decoders[_key] = arguments[_key];
	  }

	  if (decoders.length === 0) {
	    throw new Error('Pass at least one decoder to either()')
	  }

	  return define$1(function (blob, _, err) {
	    var errors = [];

	    for (var _i = 0; _i < decoders.length; _i++) {
	      var result = decoders[_i].decode(blob);

	      if (result.ok) {
	        return result
	      } else {
	        errors.push(result.error);
	      }
	    }

	    var text =
	      EITHER_PREFIX +
	      errors
	        .map(function (err) {
	          return nest(summarize(err).join('\n'))
	        })
	        .join('\n');
	    return err(text)
	  })
	}

	var either = _either;

	var undefined_ = define$1(function (blob, ok, err) {
	  return blob === undefined ? ok(blob) : err('Must be undefined')
	});

	function _maybeish(emptyCase) {
	  function _inner(decoder) {
	    var rv = either(emptyCase, decoder);

	    if (arguments.length >= 2) {
	      var _defaultValue = arguments[1];

	      var _defaultValue2 = typeof _defaultValue === 'function' ? _defaultValue() : _defaultValue;

	      return rv.transform(function (value) {
	        return value != null ? value : _defaultValue2
	      })
	    } else {
	      return rv
	    }
	  }

	  return _inner
	}

	var optional$1 = _maybeish(undefined_);

	var poja = define$1(function (blob, ok, err) {
	  if (!Array.isArray(blob)) {
	    return err('Must be an array')
	  }

	  return ok(blob.slice())
	});

	function all(items, blobs, ok, err) {
	  var results = [];

	  for (var index = 0; index < items.length; ++index) {
	    var result = items[index];

	    if (result.ok) {
	      results.push(result.value);
	    } else {
	      var ann = result.error;

	      var clone = [].concat(blobs);
	      clone.splice(index, 1, public_annotate(ann, ann.text ? ann.text + ' (at index ' + index + ')' : 'index ' + index));
	      return err(public_annotate(clone))
	    }
	  }

	  return ok(results)
	}

	function array$1(decoder) {
	  return poja.then(function (blobs, ok, err) {
	    var results = blobs.map(decoder.decode);
	    return all(results, blobs, ok, err)
	  })
	}

	function nonEmptyArray(decoder) {
	  return array$1(decoder).refine(function (arr) {
	    return arr.length > 0
	  }, 'Must be non-empty array')
	}

	var anyNumber = define$1(function (blob, ok, err) {
	  return typeof blob === 'number' ? ok(blob) : err('Must be number')
	});

	var number$2 = anyNumber.refine(function (n) {
	  return Number.isFinite(n)
	}, 'Number must be finite');

	var integer$1 = number$2.refine(function (n) {
	  return Number.isInteger(n)
	}, 'Number must be an integer');

	number$2.refine(function (n) {
	  return n >= 0
	}, 'Number must be positive');

	integer$1.refine(function (n) {
	  return n >= 0
	}, 'Number must be positive');

	var url_re = /^([A-Za-z]{3,9}(?:[+][A-Za-z]{3,9})?):\/\/(?:([-;:&=+$,\w]+)@)?(?:([A-Za-z0-9.-]+)(?::([0-9]{2,5}))?)(\/(?:[-+~%/.,\w]*)?(?:\?[-+=&;%@.,\w]*)?(?:#[.,!/\w]*)?)?$/;

	var string$1 = define$1(function (blob, ok, err) {
	  return typeof blob === 'string' ? ok(blob) : err('Must be string')
	});

	regex(/\S/, 'Must be non-empty string');

	function regex(regex, msg) {
	  return string$1.refine(function (s) {
	    return regex.test(s)
	  }, msg)
	}

	regex(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, 'Must be email');

	var url = either(
	  regex(url_re, 'Must be URL').transform(function (value) {
	    return new URL(value)
	  }),
	  instanceOf(URL)
	);

	url.refine(function (value) {
	  return value.protocol === 'https:'
	}, 'Must be an HTTPS URL');

	var uuid = regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, 'Must be uuid');

	uuid.refine(function (value) {
	  return value[14] === '1'
	}, 'Must be uuidv1');

	uuid.refine(function (value) {
	  return value[14] === '4'
	}, 'Must be uuidv4');

	// Default implementation of generic store interface.
	const CHAINS_STORAGE_KEY = 'bitski-chains';
	const CURRENT_CHAIN_STORAGE_KEY = 'bitski-current-chain';
	// A decoder for EthChainDefinitionWithRpcUrl
	const chainDefinitionDecoder = object$1({
	    chainId: string$1,
	    rpcUrls: nonEmptyArray(string$1),
	    chainName: optional$1(string$1),
	    nativeCurrency: optional$1(object$1({
	        name: string$1,
	        symbol: string$1,
	        decimals: number$2,
	    })),
	    blockExplorerUrls: optional$1(array$1(string$1)),
	    iconUrls: optional$1(array$1(string$1)), // Currently ignored.
	});
	// Uses localStorage or sessionStorage (pass which one you want in constructor).
	class LocalStorageStore {
	    constructor(storage = localStorage) {
	        this.storage = storage;
	    }
	    keys() {
	        return Object.keys(this.storage);
	    }
	    async clear() {
	        this.storage.clear();
	    }
	    async getItem(key) {
	        const value = this.storage.getItem(key);
	        return value ? JSON.parse(value) : undefined;
	    }
	    async setItem(key, value) {
	        this.storage.setItem(key, JSON.stringify(value));
	    }
	    async clearItem(key) {
	        this.storage.removeItem(key);
	    }
	}
	function ensureRpcUrl(definition) {
	    if (!definition.rpcUrls || definition.rpcUrls.length === 0) {
	        const chainId = definition.chainId;
	        if (!SUPPORTED_CHAIN_IDS.includes(chainId)) {
	            throw new Error(`no RPC url found for chainId ${chainId}, and it is not a chain supported directly by Bitski`);
	        }
	        definition.rpcUrls = [`https://api.bitski.com/v1/web3/chains/${parseInt(chainId, 16)}`];
	    }
	}
	class BitskiProviderStateStore {
	    constructor(store) {
	        var _a, _b;
	        this.store = store;
	        this.load();
	        (_b = (_a = this.store).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, async () => this.load());
	    }
	    async findChain(chainId) {
	        const chains = await this.chains;
	        return chains.find((chain) => chain.chainId === chainId);
	    }
	    async addChain(definition) {
	        if (await this.findChain(definition.chainId)) {
	            // Chain already exists, return success
	            return;
	        }
	        ensureRpcUrl(definition);
	        const chains = await this.chains;
	        chains.push(definition);
	        this.store.setItem(CHAINS_STORAGE_KEY, chains);
	    }
	    async getCurrentChainId() {
	        return this.currentChainId;
	    }
	    async setCurrentChainId(chainId) {
	        this.currentChainId = Promise.resolve(chainId);
	        this.store.setItem(CURRENT_CHAIN_STORAGE_KEY, chainId);
	    }
	    load() {
	        this.chains = Promise.resolve(this.store.getItem(CHAINS_STORAGE_KEY)).then((chains) => {
	            var _a;
	            const result = array$1(chainDefinitionDecoder).decode(chains);
	            return (_a = result.value) !== null && _a !== void 0 ? _a : DEFAULT_CHAINS.slice();
	        });
	        this.currentChainId = Promise.resolve(this.store.getItem(CURRENT_CHAIN_STORAGE_KEY)).then((chainId) => {
	            var _a;
	            const result = string$1.decode(chainId);
	            return (_a = result.value) !== null && _a !== void 0 ? _a : '0x1';
	        });
	    }
	}

	var safeEventEmitter = {};

	var domain;

	// This constructor is used to store event handlers. Instantiating this is
	// faster than explicitly calling `Object.create(null)` to get a "clean" empty
	// object (tested with v8 v4.9).
	function EventHandlers() {}
	EventHandlers.prototype = Object.create(null);

	function EventEmitter() {
	  EventEmitter.init.call(this);
	}

	// nodejs oddity
	// require('events') === require('events').EventEmitter
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.usingDomains = false;

	EventEmitter.prototype.domain = undefined;
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	EventEmitter.init = function() {
	  this.domain = null;
	  if (EventEmitter.usingDomains) {
	    // if there is an active domain, then attach to it.
	    if (domain.active ) ;
	  }

	  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
	    this._events = new EventHandlers();
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || isNaN(n))
	    throw new TypeError('"n" argument must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	function $getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return $getMaxListeners(this);
	};

	// These standalone emit* functions are used to optimize calling of event
	// handlers for fast cases because emit() itself often has a variable number of
	// arguments and can be deoptimized because of that. These functions always have
	// the same number of arguments and thus do not get deoptimized, so the code
	// inside them can execute faster.
	function emitNone(handler, isFn, self) {
	  if (isFn)
	    handler.call(self);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone$1(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self);
	  }
	}
	function emitOne(handler, isFn, self, arg1) {
	  if (isFn)
	    handler.call(self, arg1);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone$1(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1);
	  }
	}
	function emitTwo(handler, isFn, self, arg1, arg2) {
	  if (isFn)
	    handler.call(self, arg1, arg2);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone$1(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2);
	  }
	}
	function emitThree(handler, isFn, self, arg1, arg2, arg3) {
	  if (isFn)
	    handler.call(self, arg1, arg2, arg3);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone$1(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2, arg3);
	  }
	}

	function emitMany(handler, isFn, self, args) {
	  if (isFn)
	    handler.apply(self, args);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone$1(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].apply(self, args);
	  }
	}

	EventEmitter.prototype.emit = function emit(type) {
	  var er, handler, len, args, i, events, domain;
	  var doError = (type === 'error');

	  events = this._events;
	  if (events)
	    doError = (doError && events.error == null);
	  else if (!doError)
	    return false;

	  domain = this.domain;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    er = arguments[1];
	    if (domain) {
	      if (!er)
	        er = new Error('Uncaught, unspecified "error" event');
	      er.domainEmitter = this;
	      er.domain = domain;
	      er.domainThrown = false;
	      domain.emit('error', er);
	    } else if (er instanceof Error) {
	      throw er; // Unhandled 'error' event
	    } else {
	      // At least give some kind of context to the user
	      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	      err.context = er;
	      throw err;
	    }
	    return false;
	  }

	  handler = events[type];

	  if (!handler)
	    return false;

	  var isFn = typeof handler === 'function';
	  len = arguments.length;
	  switch (len) {
	    // fast cases
	    case 1:
	      emitNone(handler, isFn, this);
	      break;
	    case 2:
	      emitOne(handler, isFn, this, arguments[1]);
	      break;
	    case 3:
	      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
	      break;
	    case 4:
	      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
	      break;
	    // slower
	    default:
	      args = new Array(len - 1);
	      for (i = 1; i < len; i++)
	        args[i - 1] = arguments[i];
	      emitMany(handler, isFn, this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');

	  events = target._events;
	  if (!events) {
	    events = target._events = new EventHandlers();
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (!existing) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] = prepend ? [listener, existing] :
	                                          [existing, listener];
	    } else {
	      // If we've already got an array, just append.
	      if (prepend) {
	        existing.unshift(listener);
	      } else {
	        existing.push(listener);
	      }
	    }

	    // Check for listener leak
	    if (!existing.warned) {
	      m = $getMaxListeners(target);
	      if (m && m > 0 && existing.length > m) {
	        existing.warned = true;
	        var w = new Error('Possible EventEmitter memory leak detected. ' +
	                            existing.length + ' ' + type + ' listeners added. ' +
	                            'Use emitter.setMaxListeners() to increase limit');
	        w.name = 'MaxListenersExceededWarning';
	        w.emitter = target;
	        w.type = type;
	        w.count = existing.length;
	        emitWarning(w);
	      }
	    }
	  }

	  return target;
	}
	function emitWarning(e) {
	  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
	}
	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function _onceWrap(target, type, listener) {
	  var fired = false;
	  function g() {
	    target.removeListener(type, g);
	    if (!fired) {
	      fired = true;
	      listener.apply(target, arguments);
	    }
	  }
	  g.listener = listener;
	  return g;
	}

	EventEmitter.prototype.once = function once(type, listener) {
	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');

	      events = this._events;
	      if (!events)
	        return this;

	      list = events[type];
	      if (!list)
	        return this;

	      if (list === listener || (list.listener && list.listener === listener)) {
	        if (--this._eventsCount === 0)
	          this._events = new EventHandlers();
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length; i-- > 0;) {
	          if (list[i] === listener ||
	              (list[i].listener && list[i].listener === listener)) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (list.length === 1) {
	          list[0] = undefined;
	          if (--this._eventsCount === 0) {
	            this._events = new EventHandlers();
	            return this;
	          } else {
	            delete events[type];
	          }
	        } else {
	          spliceOne(list, position);
	        }

	        if (events.removeListener)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events;

	      events = this._events;
	      if (!events)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (!events.removeListener) {
	        if (arguments.length === 0) {
	          this._events = new EventHandlers();
	          this._eventsCount = 0;
	        } else if (events[type]) {
	          if (--this._eventsCount === 0)
	            this._events = new EventHandlers();
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        for (var i = 0, key; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = new EventHandlers();
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners) {
	        // LIFO order
	        do {
	          this.removeListener(type, listeners[listeners.length - 1]);
	        } while (listeners[0]);
	      }

	      return this;
	    };

	EventEmitter.prototype.listeners = function listeners(type) {
	  var evlistener;
	  var ret;
	  var events = this._events;

	  if (!events)
	    ret = [];
	  else {
	    evlistener = events[type];
	    if (!evlistener)
	      ret = [];
	    else if (typeof evlistener === 'function')
	      ret = [evlistener.listener || evlistener];
	    else
	      ret = unwrapListeners(evlistener);
	  }

	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount.call(emitter, type);
	  }
	};

	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
	  var events = this._events;

	  if (events) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
	};

	// About 1.5x faster than the two-arg version of Array#splice().
	function spliceOne(list, index) {
	  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
	    list[i] = list[k];
	  list.pop();
	}

	function arrayClone$1(arr, i) {
	  var copy = new Array(i);
	  while (i--)
	    copy[i] = arr[i];
	  return copy;
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	var events = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: EventEmitter,
		EventEmitter: EventEmitter
	});

	var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(events);

	Object.defineProperty(safeEventEmitter, "__esModule", { value: true });
	const events_1 = require$$0$3;
	function safeApply(handler, context, args) {
	    try {
	        Reflect.apply(handler, context, args);
	    }
	    catch (err) {
	        // Throw error after timeout so as not to interrupt the stack
	        setTimeout(() => {
	            throw err;
	        });
	    }
	}
	function arrayClone(arr) {
	    const n = arr.length;
	    const copy = new Array(n);
	    for (let i = 0; i < n; i += 1) {
	        copy[i] = arr[i];
	    }
	    return copy;
	}
	let SafeEventEmitter$2 = class SafeEventEmitter extends events_1.EventEmitter {
	    emit(type, ...args) {
	        let doError = type === 'error';
	        const events = this._events;
	        if (events !== undefined) {
	            doError = doError && events.error === undefined;
	        }
	        else if (!doError) {
	            return false;
	        }
	        // If there is no 'error' event listener then throw.
	        if (doError) {
	            let er;
	            if (args.length > 0) {
	                [er] = args;
	            }
	            if (er instanceof Error) {
	                // Note: The comments on the `throw` lines are intentional, they show
	                // up in Node's output if this results in an unhandled exception.
	                throw er; // Unhandled 'error' event
	            }
	            // At least give some kind of context to the user
	            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
	            err.context = er;
	            throw err; // Unhandled 'error' event
	        }
	        const handler = events[type];
	        if (handler === undefined) {
	            return false;
	        }
	        if (typeof handler === 'function') {
	            safeApply(handler, this, args);
	        }
	        else {
	            const len = handler.length;
	            const listeners = arrayClone(handler);
	            for (let i = 0; i < len; i += 1) {
	                safeApply(listeners[i], this, args);
	            }
	        }
	        return true;
	    }
	};
	var _default = safeEventEmitter.default = SafeEventEmitter$2;

	var inflightCache = {};

	var clone = {exports: {}};

	(function (module) {
		var clone = (function() {

		function _instanceof(obj, type) {
		  return type != null && obj instanceof type;
		}

		var nativeMap;
		try {
		  nativeMap = Map;
		} catch(_) {
		  // maybe a reference error because no `Map`. Give it a dummy value that no
		  // value will ever be an instanceof.
		  nativeMap = function() {};
		}

		var nativeSet;
		try {
		  nativeSet = Set;
		} catch(_) {
		  nativeSet = function() {};
		}

		var nativePromise;
		try {
		  nativePromise = Promise;
		} catch(_) {
		  nativePromise = function() {};
		}

		/**
		 * Clones (copies) an Object using deep copying.
		 *
		 * This function supports circular references by default, but if you are certain
		 * there are no circular references in your object, you can save some CPU time
		 * by calling clone(obj, false).
		 *
		 * Caution: if `circular` is false and `parent` contains circular references,
		 * your program may enter an infinite loop and crash.
		 *
		 * @param `parent` - the object to be cloned
		 * @param `circular` - set to true if the object to be cloned may contain
		 *    circular references. (optional - true by default)
		 * @param `depth` - set to a number if the object is only to be cloned to
		 *    a particular depth. (optional - defaults to Infinity)
		 * @param `prototype` - sets the prototype to be used when cloning an object.
		 *    (optional - defaults to parent prototype).
		 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
		 *    should be cloned as well. Non-enumerable properties on the prototype
		 *    chain will be ignored. (optional - false by default)
		*/
		function clone(parent, circular, depth, prototype, includeNonEnumerable) {
		  if (typeof circular === 'object') {
		    depth = circular.depth;
		    prototype = circular.prototype;
		    includeNonEnumerable = circular.includeNonEnumerable;
		    circular = circular.circular;
		  }
		  // maintain two arrays for circular references, where corresponding parents
		  // and children have the same index
		  var allParents = [];
		  var allChildren = [];

		  var useBuffer = typeof Buffer != 'undefined';

		  if (typeof circular == 'undefined')
		    circular = true;

		  if (typeof depth == 'undefined')
		    depth = Infinity;

		  // recurse this function so we don't reset allParents and allChildren
		  function _clone(parent, depth) {
		    // cloning null always returns null
		    if (parent === null)
		      return null;

		    if (depth === 0)
		      return parent;

		    var child;
		    var proto;
		    if (typeof parent != 'object') {
		      return parent;
		    }

		    if (_instanceof(parent, nativeMap)) {
		      child = new nativeMap();
		    } else if (_instanceof(parent, nativeSet)) {
		      child = new nativeSet();
		    } else if (_instanceof(parent, nativePromise)) {
		      child = new nativePromise(function (resolve, reject) {
		        parent.then(function(value) {
		          resolve(_clone(value, depth - 1));
		        }, function(err) {
		          reject(_clone(err, depth - 1));
		        });
		      });
		    } else if (clone.__isArray(parent)) {
		      child = [];
		    } else if (clone.__isRegExp(parent)) {
		      child = new RegExp(parent.source, __getRegExpFlags(parent));
		      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
		    } else if (clone.__isDate(parent)) {
		      child = new Date(parent.getTime());
		    } else if (useBuffer && Buffer.isBuffer(parent)) {
		      if (Buffer.allocUnsafe) {
		        // Node.js >= 4.5.0
		        child = Buffer.allocUnsafe(parent.length);
		      } else {
		        // Older Node.js versions
		        child = new Buffer(parent.length);
		      }
		      parent.copy(child);
		      return child;
		    } else if (_instanceof(parent, Error)) {
		      child = Object.create(parent);
		    } else {
		      if (typeof prototype == 'undefined') {
		        proto = Object.getPrototypeOf(parent);
		        child = Object.create(proto);
		      }
		      else {
		        child = Object.create(prototype);
		        proto = prototype;
		      }
		    }

		    if (circular) {
		      var index = allParents.indexOf(parent);

		      if (index != -1) {
		        return allChildren[index];
		      }
		      allParents.push(parent);
		      allChildren.push(child);
		    }

		    if (_instanceof(parent, nativeMap)) {
		      parent.forEach(function(value, key) {
		        var keyChild = _clone(key, depth - 1);
		        var valueChild = _clone(value, depth - 1);
		        child.set(keyChild, valueChild);
		      });
		    }
		    if (_instanceof(parent, nativeSet)) {
		      parent.forEach(function(value) {
		        var entryChild = _clone(value, depth - 1);
		        child.add(entryChild);
		      });
		    }

		    for (var i in parent) {
		      var attrs;
		      if (proto) {
		        attrs = Object.getOwnPropertyDescriptor(proto, i);
		      }

		      if (attrs && attrs.set == null) {
		        continue;
		      }
		      child[i] = _clone(parent[i], depth - 1);
		    }

		    if (Object.getOwnPropertySymbols) {
		      var symbols = Object.getOwnPropertySymbols(parent);
		      for (var i = 0; i < symbols.length; i++) {
		        // Don't need to worry about cloning a symbol because it is a primitive,
		        // like a number or string.
		        var symbol = symbols[i];
		        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
		        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
		          continue;
		        }
		        child[symbol] = _clone(parent[symbol], depth - 1);
		        if (!descriptor.enumerable) {
		          Object.defineProperty(child, symbol, {
		            enumerable: false
		          });
		        }
		      }
		    }

		    if (includeNonEnumerable) {
		      var allPropertyNames = Object.getOwnPropertyNames(parent);
		      for (var i = 0; i < allPropertyNames.length; i++) {
		        var propertyName = allPropertyNames[i];
		        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
		        if (descriptor && descriptor.enumerable) {
		          continue;
		        }
		        child[propertyName] = _clone(parent[propertyName], depth - 1);
		        Object.defineProperty(child, propertyName, {
		          enumerable: false
		        });
		      }
		    }

		    return child;
		  }

		  return _clone(parent, depth);
		}

		/**
		 * Simple flat clone using prototype, accepts only objects, usefull for property
		 * override on FLAT configuration object (no nested props).
		 *
		 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
		 * works.
		 */
		clone.clonePrototype = function clonePrototype(parent) {
		  if (parent === null)
		    return null;

		  var c = function () {};
		  c.prototype = parent;
		  return new c();
		};

		// private utility functions

		function __objToStr(o) {
		  return Object.prototype.toString.call(o);
		}
		clone.__objToStr = __objToStr;

		function __isDate(o) {
		  return typeof o === 'object' && __objToStr(o) === '[object Date]';
		}
		clone.__isDate = __isDate;

		function __isArray(o) {
		  return typeof o === 'object' && __objToStr(o) === '[object Array]';
		}
		clone.__isArray = __isArray;

		function __isRegExp(o) {
		  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
		}
		clone.__isRegExp = __isRegExp;

		function __getRegExpFlags(re) {
		  var flags = '';
		  if (re.global) flags += 'g';
		  if (re.ignoreCase) flags += 'i';
		  if (re.multiline) flags += 'm';
		  return flags;
		}
		clone.__getRegExpFlags = __getRegExpFlags;

		return clone;
		})();

		if (module.exports) {
		  module.exports = clone;
		}
	} (clone));

	var dist$2 = {};

	var idRemapMiddleware = {};

	var getUniqueId$1 = {};

	Object.defineProperty(getUniqueId$1, "__esModule", { value: true });
	getUniqueId$1.getUniqueId = void 0;
	// uint32 (two's complement) max
	// more conservative than Number.MAX_SAFE_INTEGER
	const MAX = 4294967295;
	let idCounter = Math.floor(Math.random() * MAX);
	function getUniqueId() {
	    idCounter = (idCounter + 1) % MAX;
	    return idCounter;
	}
	getUniqueId$1.getUniqueId = getUniqueId;

	Object.defineProperty(idRemapMiddleware, "__esModule", { value: true });
	idRemapMiddleware.createIdRemapMiddleware = void 0;
	const getUniqueId_1 = getUniqueId$1;
	function createIdRemapMiddleware() {
	    return (req, res, next, _end) => {
	        const originalId = req.id;
	        const newId = getUniqueId_1.getUniqueId();
	        req.id = newId;
	        res.id = newId;
	        next((done) => {
	            req.id = originalId;
	            res.id = originalId;
	            done();
	        });
	    };
	}
	idRemapMiddleware.createIdRemapMiddleware = createIdRemapMiddleware;

	var createAsyncMiddleware$3 = {};

	Object.defineProperty(createAsyncMiddleware$3, "__esModule", { value: true });
	createAsyncMiddleware$3.createAsyncMiddleware = void 0;
	/**
	 * JsonRpcEngine only accepts callback-based middleware directly.
	 * createAsyncMiddleware exists to enable consumers to pass in async middleware
	 * functions.
	 *
	 * Async middleware have no "end" function. Instead, they "end" if they return
	 * without calling "next". Rather than passing in explicit return handlers,
	 * async middleware can simply await "next", and perform operations on the
	 * response object when execution resumes.
	 *
	 * To accomplish this, createAsyncMiddleware passes the async middleware a
	 * wrapped "next" function. That function calls the internal JsonRpcEngine
	 * "next" function with a return handler that resolves a promise when called.
	 *
	 * The return handler will always be called. Its resolution of the promise
	 * enables the control flow described above.
	 */
	function createAsyncMiddleware$2(asyncMiddleware) {
	    return async (req, res, next, end) => {
	        // nextPromise is the key to the implementation
	        // it is resolved by the return handler passed to the
	        // "next" function
	        let resolveNextPromise;
	        const nextPromise = new Promise((resolve) => {
	            resolveNextPromise = resolve;
	        });
	        let returnHandlerCallback = null;
	        let nextWasCalled = false;
	        // This will be called by the consumer's async middleware.
	        const asyncNext = async () => {
	            nextWasCalled = true;
	            // We pass a return handler to next(). When it is called by the engine,
	            // the consumer's async middleware will resume executing.
	            // eslint-disable-next-line node/callback-return
	            next((runReturnHandlersCallback) => {
	                // This callback comes from JsonRpcEngine._runReturnHandlers
	                returnHandlerCallback = runReturnHandlersCallback;
	                resolveNextPromise();
	            });
	            await nextPromise;
	        };
	        try {
	            await asyncMiddleware(req, res, asyncNext);
	            if (nextWasCalled) {
	                await nextPromise; // we must wait until the return handler is called
	                returnHandlerCallback(null);
	            }
	            else {
	                end(null);
	            }
	        }
	        catch (error) {
	            if (returnHandlerCallback) {
	                returnHandlerCallback(error);
	            }
	            else {
	                end(error);
	            }
	        }
	    };
	}
	createAsyncMiddleware$3.createAsyncMiddleware = createAsyncMiddleware$2;

	var createScaffoldMiddleware$3 = {};

	Object.defineProperty(createScaffoldMiddleware$3, "__esModule", { value: true });
	createScaffoldMiddleware$3.createScaffoldMiddleware = void 0;
	function createScaffoldMiddleware$2(handlers) {
	    return (req, res, next, end) => {
	        const handler = handlers[req.method];
	        // if no handler, return
	        if (handler === undefined) {
	            return next();
	        }
	        // if handler is fn, call as middleware
	        if (typeof handler === 'function') {
	            return handler(req, res, next, end);
	        }
	        // if handler is some other value, use as result
	        res.result = handler;
	        return end();
	    };
	}
	createScaffoldMiddleware$3.createScaffoldMiddleware = createScaffoldMiddleware$2;

	var JsonRpcEngine$1 = {};

	var __importDefault$7 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(JsonRpcEngine$1, "__esModule", { value: true });
	JsonRpcEngine$1.JsonRpcEngine = void 0;
	const safe_event_emitter_1$1 = __importDefault$7(safeEventEmitter);
	const eth_rpc_errors_1 = dist$3;
	/**
	 * A JSON-RPC request and response processor.
	 * Give it a stack of middleware, pass it requests, and get back responses.
	 */
	class JsonRpcEngine extends safe_event_emitter_1$1.default {
	    constructor() {
	        super();
	        this._middleware = [];
	    }
	    /**
	     * Add a middleware function to the engine's middleware stack.
	     *
	     * @param middleware - The middleware function to add.
	     */
	    push(middleware) {
	        this._middleware.push(middleware);
	    }
	    handle(req, cb) {
	        if (cb && typeof cb !== 'function') {
	            throw new Error('"callback" must be a function if provided.');
	        }
	        if (Array.isArray(req)) {
	            if (cb) {
	                return this._handleBatch(req, cb);
	            }
	            return this._handleBatch(req);
	        }
	        if (cb) {
	            return this._handle(req, cb);
	        }
	        return this._promiseHandle(req);
	    }
	    /**
	     * Returns this engine as a middleware function that can be pushed to other
	     * engines.
	     *
	     * @returns This engine as a middleware function.
	     */
	    asMiddleware() {
	        return async (req, res, next, end) => {
	            try {
	                const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
	                if (isComplete) {
	                    await JsonRpcEngine._runReturnHandlers(returnHandlers);
	                    return end(middlewareError);
	                }
	                return next(async (handlerCallback) => {
	                    try {
	                        await JsonRpcEngine._runReturnHandlers(returnHandlers);
	                    }
	                    catch (error) {
	                        return handlerCallback(error);
	                    }
	                    return handlerCallback();
	                });
	            }
	            catch (error) {
	                return end(error);
	            }
	        };
	    }
	    async _handleBatch(reqs, cb) {
	        // The order here is important
	        try {
	            // 2. Wait for all requests to finish, or throw on some kind of fatal
	            // error
	            const responses = await Promise.all(
	            // 1. Begin executing each request in the order received
	            reqs.map(this._promiseHandle.bind(this)));
	            // 3. Return batch response
	            if (cb) {
	                return cb(null, responses);
	            }
	            return responses;
	        }
	        catch (error) {
	            if (cb) {
	                return cb(error);
	            }
	            throw error;
	        }
	    }
	    /**
	     * A promise-wrapped _handle.
	     */
	    _promiseHandle(req) {
	        return new Promise((resolve) => {
	            this._handle(req, (_err, res) => {
	                // There will always be a response, and it will always have any error
	                // that is caught and propagated.
	                resolve(res);
	            });
	        });
	    }
	    /**
	     * Ensures that the request object is valid, processes it, and passes any
	     * error and the response object to the given callback.
	     *
	     * Does not reject.
	     */
	    async _handle(callerReq, cb) {
	        if (!callerReq ||
	            Array.isArray(callerReq) ||
	            typeof callerReq !== 'object') {
	            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
	            return cb(error, { id: undefined, jsonrpc: '2.0', error });
	        }
	        if (typeof callerReq.method !== 'string') {
	            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
	            return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });
	        }
	        const req = Object.assign({}, callerReq);
	        const res = {
	            id: req.id,
	            jsonrpc: req.jsonrpc,
	        };
	        let error = null;
	        try {
	            await this._processRequest(req, res);
	        }
	        catch (_error) {
	            // A request handler error, a re-thrown middleware error, or something
	            // unexpected.
	            error = _error;
	        }
	        if (error) {
	            // Ensure no result is present on an errored response
	            delete res.result;
	            if (!res.error) {
	                res.error = eth_rpc_errors_1.serializeError(error);
	            }
	        }
	        return cb(error, res);
	    }
	    /**
	     * For the given request and response, runs all middleware and their return
	     * handlers, if any, and ensures that internal request processing semantics
	     * are satisfied.
	     */
	    async _processRequest(req, res) {
	        const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
	        // Throw if "end" was not called, or if the response has neither a result
	        // nor an error.
	        JsonRpcEngine._checkForCompletion(req, res, isComplete);
	        // The return handlers should run even if an error was encountered during
	        // middleware processing.
	        await JsonRpcEngine._runReturnHandlers(returnHandlers);
	        // Now we re-throw the middleware processing error, if any, to catch it
	        // further up the call chain.
	        if (error) {
	            throw error;
	        }
	    }
	    /**
	     * Serially executes the given stack of middleware.
	     *
	     * @returns An array of any error encountered during middleware execution,
	     * a boolean indicating whether the request was completed, and an array of
	     * middleware-defined return handlers.
	     */
	    static async _runAllMiddleware(req, res, middlewareStack) {
	        const returnHandlers = [];
	        let error = null;
	        let isComplete = false;
	        // Go down stack of middleware, call and collect optional returnHandlers
	        for (const middleware of middlewareStack) {
	            [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
	            if (isComplete) {
	                break;
	            }
	        }
	        return [error, isComplete, returnHandlers.reverse()];
	    }
	    /**
	     * Runs an individual middleware.
	     *
	     * @returns An array of any error encountered during middleware exection,
	     * and a boolean indicating whether the request should end.
	     */
	    static _runMiddleware(req, res, middleware, returnHandlers) {
	        return new Promise((resolve) => {
	            const end = (err) => {
	                const error = err || res.error;
	                if (error) {
	                    res.error = eth_rpc_errors_1.serializeError(error);
	                }
	                // True indicates that the request should end
	                resolve([error, true]);
	            };
	            const next = (returnHandler) => {
	                if (res.error) {
	                    end(res.error);
	                }
	                else {
	                    if (returnHandler) {
	                        if (typeof returnHandler !== 'function') {
	                            end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. ` +
	                                `Received "${typeof returnHandler}" for request:\n${jsonify$1(req)}`, { request: req }));
	                        }
	                        returnHandlers.push(returnHandler);
	                    }
	                    // False indicates that the request should not end
	                    resolve([null, false]);
	                }
	            };
	            try {
	                middleware(req, res, next, end);
	            }
	            catch (error) {
	                end(error);
	            }
	        });
	    }
	    /**
	     * Serially executes array of return handlers. The request and response are
	     * assumed to be in their scope.
	     */
	    static async _runReturnHandlers(handlers) {
	        for (const handler of handlers) {
	            await new Promise((resolve, reject) => {
	                handler((err) => (err ? reject(err) : resolve()));
	            });
	        }
	    }
	    /**
	     * Throws an error if the response has neither a result nor an error, or if
	     * the "isComplete" flag is falsy.
	     */
	    static _checkForCompletion(req, res, isComplete) {
	        if (!('result' in res) && !('error' in res)) {
	            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\n${jsonify$1(req)}`, { request: req });
	        }
	        if (!isComplete) {
	            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\n${jsonify$1(req)}`, { request: req });
	        }
	    }
	}
	JsonRpcEngine$1.JsonRpcEngine = JsonRpcEngine;
	function jsonify$1(request) {
	    return JSON.stringify(request, null, 2);
	}

	var mergeMiddleware$1 = {};

	Object.defineProperty(mergeMiddleware$1, "__esModule", { value: true });
	mergeMiddleware$1.mergeMiddleware = void 0;
	const JsonRpcEngine_1 = JsonRpcEngine$1;
	function mergeMiddleware(middlewareStack) {
	    const engine = new JsonRpcEngine_1.JsonRpcEngine();
	    middlewareStack.forEach((middleware) => engine.push(middleware));
	    return engine.asMiddleware();
	}
	mergeMiddleware$1.mergeMiddleware = mergeMiddleware;

	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(idRemapMiddleware, exports);
		__exportStar(createAsyncMiddleware$3, exports);
		__exportStar(createScaffoldMiddleware$3, exports);
		__exportStar(getUniqueId$1, exports);
		__exportStar(JsonRpcEngine$1, exports);
		__exportStar(mergeMiddleware$1, exports);
		
	} (dist$2));

	var loggingUtils = {};

	var dist$1 = {};

	var assert$3 = {};

	var lib$1 = {};

	Object.defineProperty(lib$1, '__esModule', { value: true });

	/**
	 * A `StructFailure` represents a single specific failure in validation.
	 */

	/**
	 * `StructError` objects are thrown (or returned) when validation fails.
	 *
	 * Validation logic is design to exit early for maximum performance. The error
	 * represents the first error encountered during validation. For more detail,
	 * the `error.failures` property is a generator function that can be run to
	 * continue validation and receive all the failures in the data.
	 */
	class StructError extends TypeError {
	  constructor(failure, failures) {
	    let cached;
	    const {
	      message,
	      ...rest
	    } = failure;
	    const {
	      path
	    } = failure;
	    const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
	    super(msg);
	    this.value = void 0;
	    this.key = void 0;
	    this.type = void 0;
	    this.refinement = void 0;
	    this.path = void 0;
	    this.branch = void 0;
	    this.failures = void 0;
	    Object.assign(this, rest);
	    this.name = this.constructor.name;

	    this.failures = () => {
	      return cached ?? (cached = [failure, ...failures()]);
	    };
	  }

	}

	/**
	 * Check if a value is an iterator.
	 */
	function isIterable(x) {
	  return isObject$1(x) && typeof x[Symbol.iterator] === 'function';
	}
	/**
	 * Check if a value is a plain object.
	 */


	function isObject$1(x) {
	  return typeof x === 'object' && x != null;
	}
	/**
	 * Check if a value is a plain object.
	 */

	function isPlainObject(x) {
	  if (Object.prototype.toString.call(x) !== '[object Object]') {
	    return false;
	  }

	  const prototype = Object.getPrototypeOf(x);
	  return prototype === null || prototype === Object.prototype;
	}
	/**
	 * Return a value as a printable string.
	 */

	function print(value) {
	  if (typeof value === 'symbol') {
	    return value.toString();
	  }

	  return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
	}
	/**
	 * Shifts (removes and returns) the first value from the `input` iterator.
	 * Like `Array.prototype.shift()` but for an `Iterator`.
	 */

	function shiftIterator(input) {
	  const {
	    done,
	    value
	  } = input.next();
	  return done ? undefined : value;
	}
	/**
	 * Convert a single validation result to a failure.
	 */

	function toFailure(result, context, struct, value) {
	  if (result === true) {
	    return;
	  } else if (result === false) {
	    result = {};
	  } else if (typeof result === 'string') {
	    result = {
	      message: result
	    };
	  }

	  const {
	    path,
	    branch
	  } = context;
	  const {
	    type
	  } = struct;
	  const {
	    refinement,
	    message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``
	  } = result;
	  return {
	    value,
	    type,
	    refinement,
	    key: path[path.length - 1],
	    path,
	    branch,
	    ...result,
	    message
	  };
	}
	/**
	 * Convert a validation result to an iterable of failures.
	 */

	function* toFailures(result, context, struct, value) {
	  if (!isIterable(result)) {
	    result = [result];
	  }

	  for (const r of result) {
	    const failure = toFailure(r, context, struct, value);

	    if (failure) {
	      yield failure;
	    }
	  }
	}
	/**
	 * Check a value against a struct, traversing deeply into nested values, and
	 * returning an iterator of failures or success.
	 */

	function* run(value, struct, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  const {
	    path = [],
	    branch = [value],
	    coerce = false,
	    mask = false
	  } = options;
	  const ctx = {
	    path,
	    branch
	  };

	  if (coerce) {
	    value = struct.coercer(value, ctx);

	    if (mask && struct.type !== 'type' && isObject$1(struct.schema) && isObject$1(value) && !Array.isArray(value)) {
	      for (const key in value) {
	        if (struct.schema[key] === undefined) {
	          delete value[key];
	        }
	      }
	    }
	  }

	  let status = 'valid';

	  for (const failure of struct.validator(value, ctx)) {
	    status = 'not_valid';
	    yield [failure, undefined];
	  }

	  for (let [k, v, s] of struct.entries(value, ctx)) {
	    const ts = run(v, s, {
	      path: k === undefined ? path : [...path, k],
	      branch: k === undefined ? branch : [...branch, v],
	      coerce,
	      mask
	    });

	    for (const t of ts) {
	      if (t[0]) {
	        status = t[0].refinement != null ? 'not_refined' : 'not_valid';
	        yield [t[0], undefined];
	      } else if (coerce) {
	        v = t[1];

	        if (k === undefined) {
	          value = v;
	        } else if (value instanceof Map) {
	          value.set(k, v);
	        } else if (value instanceof Set) {
	          value.add(v);
	        } else if (isObject$1(value)) {
	          if (v !== undefined || k in value) value[k] = v;
	        }
	      }
	    }
	  }

	  if (status !== 'not_valid') {
	    for (const failure of struct.refiner(value, ctx)) {
	      status = 'not_refined';
	      yield [failure, undefined];
	    }
	  }

	  if (status === 'valid') {
	    yield [undefined, value];
	  }
	}

	/**
	 * `Struct` objects encapsulate the validation logic for a specific type of
	 * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
	 * validate unknown input data against the struct.
	 */

	class Struct {
	  constructor(props) {
	    this.TYPE = void 0;
	    this.type = void 0;
	    this.schema = void 0;
	    this.coercer = void 0;
	    this.validator = void 0;
	    this.refiner = void 0;
	    this.entries = void 0;
	    const {
	      type,
	      schema,
	      validator,
	      refiner,
	      coercer = value => value,
	      entries = function* () {}
	    } = props;
	    this.type = type;
	    this.schema = schema;
	    this.entries = entries;
	    this.coercer = coercer;

	    if (validator) {
	      this.validator = (value, context) => {
	        const result = validator(value, context);
	        return toFailures(result, context, this, value);
	      };
	    } else {
	      this.validator = () => [];
	    }

	    if (refiner) {
	      this.refiner = (value, context) => {
	        const result = refiner(value, context);
	        return toFailures(result, context, this, value);
	      };
	    } else {
	      this.refiner = () => [];
	    }
	  }
	  /**
	   * Assert that a value passes the struct's validation, throwing if it doesn't.
	   */


	  assert(value) {
	    return assert$2(value, this);
	  }
	  /**
	   * Create a value with the struct's coercion logic, then validate it.
	   */


	  create(value) {
	    return create(value, this);
	  }
	  /**
	   * Check if a value passes the struct's validation.
	   */


	  is(value) {
	    return is(value, this);
	  }
	  /**
	   * Mask a value, coercing and validating it, but returning only the subset of
	   * properties defined by the struct's schema.
	   */


	  mask(value) {
	    return mask(value, this);
	  }
	  /**
	   * Validate a value with the struct's validation logic, returning a tuple
	   * representing the result.
	   *
	   * You may optionally pass `true` for the `withCoercion` argument to coerce
	   * the value before attempting to validate it. If you do, the result will
	   * contain the coerced result when successful.
	   */


	  validate(value, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    return validate(value, this, options);
	  }

	}
	/**
	 * Assert that a value passes a struct, throwing if it doesn't.
	 */

	function assert$2(value, struct) {
	  const result = validate(value, struct);

	  if (result[0]) {
	    throw result[0];
	  }
	}
	/**
	 * Create a value with the coercion logic of struct and validate it.
	 */

	function create(value, struct) {
	  const result = validate(value, struct, {
	    coerce: true
	  });

	  if (result[0]) {
	    throw result[0];
	  } else {
	    return result[1];
	  }
	}
	/**
	 * Mask a value, returning only the subset of properties defined by a struct.
	 */

	function mask(value, struct) {
	  const result = validate(value, struct, {
	    coerce: true,
	    mask: true
	  });

	  if (result[0]) {
	    throw result[0];
	  } else {
	    return result[1];
	  }
	}
	/**
	 * Check if a value passes a struct.
	 */

	function is(value, struct) {
	  const result = validate(value, struct);
	  return !result[0];
	}
	/**
	 * Validate a value against a struct, returning an error if invalid, or the
	 * value (with potential coercion) if valid.
	 */

	function validate(value, struct, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  const tuples = run(value, struct, options);
	  const tuple = shiftIterator(tuples);

	  if (tuple[0]) {
	    const error = new StructError(tuple[0], function* () {
	      for (const t of tuples) {
	        if (t[0]) {
	          yield t[0];
	        }
	      }
	    });
	    return [error, undefined];
	  } else {
	    const v = tuple[1];
	    return [undefined, v];
	  }
	}

	function assign() {
	  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {
	    Structs[_key] = arguments[_key];
	  }

	  const isType = Structs[0].type === 'type';
	  const schemas = Structs.map(s => s.schema);
	  const schema = Object.assign({}, ...schemas);
	  return isType ? type$1(schema) : object(schema);
	}
	/**
	 * Define a new struct type with a custom validation function.
	 */

	function define(name, validator) {
	  return new Struct({
	    type: name,
	    schema: null,
	    validator
	  });
	}
	/**
	 * Create a new struct based on an existing struct, but the value is allowed to
	 * be `undefined`. `log` will be called if the value is not `undefined`.
	 */

	function deprecated(struct, log) {
	  return new Struct({ ...struct,
	    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),

	    validator(value, ctx) {
	      if (value === undefined) {
	        return true;
	      } else {
	        log(value, ctx);
	        return struct.validator(value, ctx);
	      }
	    }

	  });
	}
	/**
	 * Create a struct with dynamic validation logic.
	 *
	 * The callback will receive the value currently being validated, and must
	 * return a struct object to validate it with. This can be useful to model
	 * validation logic that changes based on its input.
	 */

	function dynamic(fn) {
	  return new Struct({
	    type: 'dynamic',
	    schema: null,

	    *entries(value, ctx) {
	      const struct = fn(value, ctx);
	      yield* struct.entries(value, ctx);
	    },

	    validator(value, ctx) {
	      const struct = fn(value, ctx);
	      return struct.validator(value, ctx);
	    },

	    coercer(value, ctx) {
	      const struct = fn(value, ctx);
	      return struct.coercer(value, ctx);
	    },

	    refiner(value, ctx) {
	      const struct = fn(value, ctx);
	      return struct.refiner(value, ctx);
	    }

	  });
	}
	/**
	 * Create a struct with lazily evaluated validation logic.
	 *
	 * The first time validation is run with the struct, the callback will be called
	 * and must return a struct object to use. This is useful for cases where you
	 * want to have self-referential structs for nested data structures to avoid a
	 * circular definition problem.
	 */

	function lazy(fn) {
	  let struct;
	  return new Struct({
	    type: 'lazy',
	    schema: null,

	    *entries(value, ctx) {
	      struct ?? (struct = fn());
	      yield* struct.entries(value, ctx);
	    },

	    validator(value, ctx) {
	      struct ?? (struct = fn());
	      return struct.validator(value, ctx);
	    },

	    coercer(value, ctx) {
	      struct ?? (struct = fn());
	      return struct.coercer(value, ctx);
	    },

	    refiner(value, ctx) {
	      struct ?? (struct = fn());
	      return struct.refiner(value, ctx);
	    }

	  });
	}
	/**
	 * Create a new struct based on an existing object struct, but excluding
	 * specific properties.
	 *
	 * Like TypeScript's `Omit` utility.
	 */

	function omit(struct, keys) {
	  const {
	    schema
	  } = struct;
	  const subschema = { ...schema
	  };

	  for (const key of keys) {
	    delete subschema[key];
	  }

	  switch (struct.type) {
	    case 'type':
	      return type$1(subschema);

	    default:
	      return object(subschema);
	  }
	}
	/**
	 * Create a new struct based on an existing object struct, but with all of its
	 * properties allowed to be `undefined`.
	 *
	 * Like TypeScript's `Partial` utility.
	 */

	function partial(struct) {
	  const schema = struct instanceof Struct ? { ...struct.schema
	  } : { ...struct
	  };

	  for (const key in schema) {
	    schema[key] = optional(schema[key]);
	  }

	  return object(schema);
	}
	/**
	 * Create a new struct based on an existing object struct, but only including
	 * specific properties.
	 *
	 * Like TypeScript's `Pick` utility.
	 */

	function pick(struct, keys) {
	  const {
	    schema
	  } = struct;
	  const subschema = {};

	  for (const key of keys) {
	    subschema[key] = schema[key];
	  }

	  return object(subschema);
	}
	/**
	 * Define a new struct type with a custom validation function.
	 *
	 * @deprecated This function has been renamed to `define`.
	 */

	function struct(name, validator) {
	  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
	  return define(name, validator);
	}

	/**
	 * Ensure that any value passes validation.
	 */

	function any() {
	  return define('any', () => true);
	}
	function array(Element) {
	  return new Struct({
	    type: 'array',
	    schema: Element,

	    *entries(value) {
	      if (Element && Array.isArray(value)) {
	        for (const [i, v] of value.entries()) {
	          yield [i, v, Element];
	        }
	      }
	    },

	    coercer(value) {
	      return Array.isArray(value) ? value.slice() : value;
	    },

	    validator(value) {
	      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
	    }

	  });
	}
	/**
	 * Ensure that a value is a bigint.
	 */

	function bigint() {
	  return define('bigint', value => {
	    return typeof value === 'bigint';
	  });
	}
	/**
	 * Ensure that a value is a boolean.
	 */

	function boolean() {
	  return define('boolean', value => {
	    return typeof value === 'boolean';
	  });
	}
	/**
	 * Ensure that a value is a valid `Date`.
	 *
	 * Note: this also ensures that the value is *not* an invalid `Date` object,
	 * which can occur when parsing a date fails but still returns a `Date`.
	 */

	function date() {
	  return define('date', value => {
	    return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
	  });
	}
	function enums(values) {
	  const schema = {};
	  const description = values.map(v => print(v)).join();

	  for (const key of values) {
	    schema[key] = key;
	  }

	  return new Struct({
	    type: 'enums',
	    schema,

	    validator(value) {
	      return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
	    }

	  });
	}
	/**
	 * Ensure that a value is a function.
	 */

	function func() {
	  return define('func', value => {
	    return typeof value === 'function' || `Expected a function, but received: ${print(value)}`;
	  });
	}
	/**
	 * Ensure that a value is an instance of a specific class.
	 */

	function instance(Class) {
	  return define('instance', value => {
	    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
	  });
	}
	/**
	 * Ensure that a value is an integer.
	 */

	function integer() {
	  return define('integer', value => {
	    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
	  });
	}
	/**
	 * Ensure that a value matches all of a set of types.
	 */

	function intersection(Structs) {
	  return new Struct({
	    type: 'intersection',
	    schema: null,

	    *entries(value, ctx) {
	      for (const S of Structs) {
	        yield* S.entries(value, ctx);
	      }
	    },

	    *validator(value, ctx) {
	      for (const S of Structs) {
	        yield* S.validator(value, ctx);
	      }
	    },

	    *refiner(value, ctx) {
	      for (const S of Structs) {
	        yield* S.refiner(value, ctx);
	      }
	    }

	  });
	}
	function literal(constant) {
	  const description = print(constant);
	  const t = typeof constant;
	  return new Struct({
	    type: 'literal',
	    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,

	    validator(value) {
	      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
	    }

	  });
	}
	function map(Key, Value) {
	  return new Struct({
	    type: 'map',
	    schema: null,

	    *entries(value) {
	      if (Key && Value && value instanceof Map) {
	        for (const [k, v] of value.entries()) {
	          yield [k, k, Key];
	          yield [k, v, Value];
	        }
	      }
	    },

	    coercer(value) {
	      return value instanceof Map ? new Map(value) : value;
	    },

	    validator(value) {
	      return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
	    }

	  });
	}
	/**
	 * Ensure that no value ever passes validation.
	 */

	function never() {
	  return define('never', () => false);
	}
	/**
	 * Augment an existing struct to allow `null` values.
	 */

	function nullable(struct) {
	  return new Struct({ ...struct,
	    validator: (value, ctx) => value === null || struct.validator(value, ctx),
	    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
	  });
	}
	/**
	 * Ensure that a value is a number.
	 */

	function number$1() {
	  return define('number', value => {
	    return typeof value === 'number' && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
	  });
	}
	function object(schema) {
	  const knowns = schema ? Object.keys(schema) : [];
	  const Never = never();
	  return new Struct({
	    type: 'object',
	    schema: schema ? schema : null,

	    *entries(value) {
	      if (schema && isObject$1(value)) {
	        const unknowns = new Set(Object.keys(value));

	        for (const key of knowns) {
	          unknowns.delete(key);
	          yield [key, value[key], schema[key]];
	        }

	        for (const key of unknowns) {
	          yield [key, value[key], Never];
	        }
	      }
	    },

	    validator(value) {
	      return isObject$1(value) || `Expected an object, but received: ${print(value)}`;
	    },

	    coercer(value) {
	      return isObject$1(value) ? { ...value
	      } : value;
	    }

	  });
	}
	/**
	 * Augment a struct to allow `undefined` values.
	 */

	function optional(struct) {
	  return new Struct({ ...struct,
	    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
	    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
	  });
	}
	/**
	 * Ensure that a value is an object with keys and values of specific types, but
	 * without ensuring any specific shape of properties.
	 *
	 * Like TypeScript's `Record` utility.
	 */

	function record(Key, Value) {
	  return new Struct({
	    type: 'record',
	    schema: null,

	    *entries(value) {
	      if (isObject$1(value)) {
	        for (const k in value) {
	          const v = value[k];
	          yield [k, k, Key];
	          yield [k, v, Value];
	        }
	      }
	    },

	    validator(value) {
	      return isObject$1(value) || `Expected an object, but received: ${print(value)}`;
	    }

	  });
	}
	/**
	 * Ensure that a value is a `RegExp`.
	 *
	 * Note: this does not test the value against the regular expression! For that
	 * you need to use the `pattern()` refinement.
	 */

	function regexp() {
	  return define('regexp', value => {
	    return value instanceof RegExp;
	  });
	}
	function set(Element) {
	  return new Struct({
	    type: 'set',
	    schema: null,

	    *entries(value) {
	      if (Element && value instanceof Set) {
	        for (const v of value) {
	          yield [v, v, Element];
	        }
	      }
	    },

	    coercer(value) {
	      return value instanceof Set ? new Set(value) : value;
	    },

	    validator(value) {
	      return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
	    }

	  });
	}
	/**
	 * Ensure that a value is a string.
	 */

	function string() {
	  return define('string', value => {
	    return typeof value === 'string' || `Expected a string, but received: ${print(value)}`;
	  });
	}
	/**
	 * Ensure that a value is a tuple of a specific length, and that each of its
	 * elements is of a specific type.
	 */

	function tuple(Structs) {
	  const Never = never();
	  return new Struct({
	    type: 'tuple',
	    schema: null,

	    *entries(value) {
	      if (Array.isArray(value)) {
	        const length = Math.max(Structs.length, value.length);

	        for (let i = 0; i < length; i++) {
	          yield [i, value[i], Structs[i] || Never];
	        }
	      }
	    },

	    validator(value) {
	      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
	    }

	  });
	}
	/**
	 * Ensure that a value has a set of known properties of specific types.
	 *
	 * Note: Unrecognized properties are allowed and untouched. This is similar to
	 * how TypeScript's structural typing works.
	 */

	function type$1(schema) {
	  const keys = Object.keys(schema);
	  return new Struct({
	    type: 'type',
	    schema,

	    *entries(value) {
	      if (isObject$1(value)) {
	        for (const k of keys) {
	          yield [k, value[k], schema[k]];
	        }
	      }
	    },

	    validator(value) {
	      return isObject$1(value) || `Expected an object, but received: ${print(value)}`;
	    }

	  });
	}
	/**
	 * Ensure that a value matches one of a set of types.
	 */

	function union(Structs) {
	  const description = Structs.map(s => s.type).join(' | ');
	  return new Struct({
	    type: 'union',
	    schema: null,

	    coercer(value, ctx) {
	      const firstMatch = Structs.find(s => {
	        const [e] = s.validate(value, {
	          coerce: true
	        });
	        return !e;
	      }) || unknown();
	      return firstMatch.coercer(value, ctx);
	    },

	    validator(value, ctx) {
	      const failures = [];

	      for (const S of Structs) {
	        const [...tuples] = run(value, S, ctx);
	        const [first] = tuples;

	        if (!first[0]) {
	          return [];
	        } else {
	          for (const [failure] of tuples) {
	            if (failure) {
	              failures.push(failure);
	            }
	          }
	        }
	      }

	      return [`Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`, ...failures];
	    }

	  });
	}
	/**
	 * Ensure that any value passes validation, without widening its type to `any`.
	 */

	function unknown() {
	  return define('unknown', () => true);
	}

	/**
	 * Augment a `Struct` to add an additional coercion step to its input.
	 *
	 * This allows you to transform input data before validating it, to increase the
	 * likelihood that it passes validation—for example for default values, parsing
	 * different formats, etc.
	 *
	 * Note: You must use `create(value, Struct)` on the value to have the coercion
	 * take effect! Using simply `assert()` or `is()` will not use coercion.
	 */

	function coerce(struct, condition, coercer) {
	  return new Struct({ ...struct,
	    coercer: (value, ctx) => {
	      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
	    }
	  });
	}
	/**
	 * Augment a struct to replace `undefined` values with a default.
	 *
	 * Note: You must use `create(value, Struct)` on the value to have the coercion
	 * take effect! Using simply `assert()` or `is()` will not use coercion.
	 */

	function defaulted(struct, fallback, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  return coerce(struct, unknown(), x => {
	    const f = typeof fallback === 'function' ? fallback() : fallback;

	    if (x === undefined) {
	      return f;
	    }

	    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
	      const ret = { ...x
	      };
	      let changed = false;

	      for (const key in f) {
	        if (ret[key] === undefined) {
	          ret[key] = f[key];
	          changed = true;
	        }
	      }

	      if (changed) {
	        return ret;
	      }
	    }

	    return x;
	  });
	}
	/**
	 * Augment a struct to trim string inputs.
	 *
	 * Note: You must use `create(value, Struct)` on the value to have the coercion
	 * take effect! Using simply `assert()` or `is()` will not use coercion.
	 */

	function trimmed(struct) {
	  return coerce(struct, string(), x => x.trim());
	}

	/**
	 * Ensure that a string, array, map, or set is empty.
	 */

	function empty(struct) {
	  return refine(struct, 'empty', value => {
	    const size = getSize(value);
	    return size === 0 || `Expected an empty ${struct.type} but received one with a size of \`${size}\``;
	  });
	}

	function getSize(value) {
	  if (value instanceof Map || value instanceof Set) {
	    return value.size;
	  } else {
	    return value.length;
	  }
	}
	/**
	 * Ensure that a number or date is below a threshold.
	 */


	function max(struct, threshold, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  const {
	    exclusive
	  } = options;
	  return refine(struct, 'max', value => {
	    return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
	  });
	}
	/**
	 * Ensure that a number or date is above a threshold.
	 */

	function min(struct, threshold, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  const {
	    exclusive
	  } = options;
	  return refine(struct, 'min', value => {
	    return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
	  });
	}
	/**
	 * Ensure that a string, array, map or set is not empty.
	 */

	function nonempty(struct) {
	  return refine(struct, 'nonempty', value => {
	    const size = getSize(value);
	    return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;
	  });
	}
	/**
	 * Ensure that a string matches a regular expression.
	 */

	function pattern(struct, regexp) {
	  return refine(struct, 'pattern', value => {
	    return regexp.test(value) || `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`;
	  });
	}
	/**
	 * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
	 */

	function size(struct, min, max) {
	  if (max === void 0) {
	    max = min;
	  }

	  const expected = `Expected a ${struct.type}`;
	  const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
	  return refine(struct, 'size', value => {
	    if (typeof value === 'number' || value instanceof Date) {
	      return min <= value && value <= max || `${expected} ${of} but received \`${value}\``;
	    } else if (value instanceof Map || value instanceof Set) {
	      const {
	        size
	      } = value;
	      return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \`${size}\``;
	    } else {
	      const {
	        length
	      } = value;
	      return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \`${length}\``;
	    }
	  });
	}
	/**
	 * Augment a `Struct` to add an additional refinement to the validation.
	 *
	 * The refiner function is guaranteed to receive a value of the struct's type,
	 * because the struct's existing validation will already have passed. This
	 * allows you to layer additional validation on top of existing structs.
	 */

	function refine(struct, name, refiner) {
	  return new Struct({ ...struct,

	    *refiner(value, ctx) {
	      yield* struct.refiner(value, ctx);
	      const result = refiner(value, ctx);
	      const failures = toFailures(result, ctx, struct, value);

	      for (const failure of failures) {
	        yield { ...failure,
	          refinement: name
	        };
	      }
	    }

	  });
	}

	lib$1.Struct = Struct;
	lib$1.StructError = StructError;
	lib$1.any = any;
	lib$1.array = array;
	lib$1.assert = assert$2;
	lib$1.assign = assign;
	lib$1.bigint = bigint;
	lib$1.boolean = boolean;
	lib$1.coerce = coerce;
	lib$1.create = create;
	lib$1.date = date;
	lib$1.defaulted = defaulted;
	lib$1.define = define;
	lib$1.deprecated = deprecated;
	lib$1.dynamic = dynamic;
	lib$1.empty = empty;
	lib$1.enums = enums;
	lib$1.func = func;
	lib$1.instance = instance;
	lib$1.integer = integer;
	lib$1.intersection = intersection;
	lib$1.is = is;
	lib$1.lazy = lazy;
	lib$1.literal = literal;
	lib$1.map = map;
	lib$1.mask = mask;
	lib$1.max = max;
	lib$1.min = min;
	lib$1.never = never;
	lib$1.nonempty = nonempty;
	lib$1.nullable = nullable;
	lib$1.number = number$1;
	lib$1.object = object;
	lib$1.omit = omit;
	lib$1.optional = optional;
	lib$1.partial = partial;
	lib$1.pattern = pattern;
	lib$1.pick = pick;
	lib$1.record = record;
	lib$1.refine = refine;
	lib$1.regexp = regexp;
	lib$1.set = set;
	lib$1.size = size;
	lib$1.string = string;
	lib$1.struct = struct;
	lib$1.trimmed = trimmed;
	lib$1.tuple = tuple;
	lib$1.type = type$1;
	lib$1.union = union;
	lib$1.unknown = unknown;
	lib$1.validate = validate;

	Object.defineProperty(assert$3, "__esModule", { value: true });
	assert$3.assertExhaustive = assert$3.assertStruct = assert$3.assert = assert$3.AssertionError = void 0;
	const superstruct_1$1 = lib$1;
	/**
	 * Type guard for determining whether the given value is an error object with a
	 * `message` property, such as an instance of Error.
	 *
	 * @param error - The object to check.
	 * @returns True or false, depending on the result.
	 */
	function isErrorWithMessage(error) {
	    return typeof error === 'object' && error !== null && 'message' in error;
	}
	/**
	 * Check if a value is a constructor, i.e., a function that can be called with
	 * the `new` keyword.
	 *
	 * @param fn - The value to check.
	 * @returns `true` if the value is a constructor, or `false` otherwise.
	 */
	function isConstructable(fn) {
	    var _a, _b;
	    /* istanbul ignore next */
	    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
	}
	/**
	 * Get the error message from an unknown error object. If the error object has
	 * a `message` property, that property is returned. Otherwise, the stringified
	 * error object is returned.
	 *
	 * @param error - The error object to get the message from.
	 * @returns The error message.
	 */
	function getErrorMessage(error) {
	    const message = isErrorWithMessage(error) ? error.message : String(error);
	    // If the error ends with a period, remove it, as we'll add our own period.
	    if (message.endsWith('.')) {
	        return message.slice(0, -1);
	    }
	    return message;
	}
	/**
	 * Initialise an {@link AssertionErrorConstructor} error.
	 *
	 * @param ErrorWrapper - The error class to use.
	 * @param message - The error message.
	 * @returns The error object.
	 */
	function getError(ErrorWrapper, message) {
	    if (isConstructable(ErrorWrapper)) {
	        return new ErrorWrapper({
	            message,
	        });
	    }
	    return ErrorWrapper({
	        message,
	    });
	}
	/**
	 * The default error class that is thrown if an assertion fails.
	 */
	class AssertionError extends Error {
	    constructor(options) {
	        super(options.message);
	        this.code = 'ERR_ASSERTION';
	    }
	}
	assert$3.AssertionError = AssertionError;
	/**
	 * Same as Node.js assert.
	 * If the value is falsy, throws an error, does nothing otherwise.
	 *
	 * @throws {@link AssertionError} If value is falsy.
	 * @param value - The test that should be truthy to pass.
	 * @param message - Message to be passed to {@link AssertionError} or an
	 * {@link Error} instance to throw.
	 * @param ErrorWrapper - The error class to throw if the assertion fails.
	 * Defaults to {@link AssertionError}. If a custom error class is provided for
	 * the `message` argument, this argument is ignored.
	 */
	function assert$1(value, message = 'Assertion failed.', ErrorWrapper = AssertionError) {
	    if (!value) {
	        if (message instanceof Error) {
	            throw message;
	        }
	        throw getError(ErrorWrapper, message);
	    }
	}
	assert$3.assert = assert$1;
	/**
	 * Assert a value against a Superstruct struct.
	 *
	 * @param value - The value to validate.
	 * @param struct - The struct to validate against.
	 * @param errorPrefix - A prefix to add to the error message. Defaults to
	 * "Assertion failed".
	 * @param ErrorWrapper - The error class to throw if the assertion fails.
	 * Defaults to {@link AssertionError}.
	 * @throws If the value is not valid.
	 */
	function assertStruct(value, struct, errorPrefix = 'Assertion failed', ErrorWrapper = AssertionError) {
	    try {
	        (0, superstruct_1$1.assert)(value, struct);
	    }
	    catch (error) {
	        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
	    }
	}
	assert$3.assertStruct = assertStruct;
	/**
	 * Use in the default case of a switch that you want to be fully exhaustive.
	 * Using this function forces the compiler to enforce exhaustivity during
	 * compile-time.
	 *
	 * @example
	 * ```
	 * const number = 1;
	 * switch (number) {
	 *   case 0:
	 *     ...
	 *   case 1:
	 *     ...
	 *   default:
	 *     assertExhaustive(snapPrefix);
	 * }
	 * ```
	 * @param _object - The object on which the switch is being operated.
	 */
	function assertExhaustive(_object) {
	    throw new Error('Invalid branch reached. Should be detected during compilation.');
	}
	assert$3.assertExhaustive = assertExhaustive;

	var bytes = {};

	var hex = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
		const superstruct_1 = lib$1;
		const assert_1 = assert$3;
		exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
		exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
		/**
		 * Check if a string is a valid hex string.
		 *
		 * @param value - The value to check.
		 * @returns Whether the value is a valid hex string.
		 */
		function isHexString(value) {
		    return (0, superstruct_1.is)(value, exports.HexStruct);
		}
		exports.isHexString = isHexString;
		/**
		 * Strictly check if a string is a valid hex string. A valid hex string must
		 * start with the "0x"-prefix.
		 *
		 * @param value - The value to check.
		 * @returns Whether the value is a valid hex string.
		 */
		function isStrictHexString(value) {
		    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
		}
		exports.isStrictHexString = isStrictHexString;
		/**
		 * Assert that a value is a valid hex string.
		 *
		 * @param value - The value to check.
		 * @throws If the value is not a valid hex string.
		 */
		function assertIsHexString(value) {
		    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
		}
		exports.assertIsHexString = assertIsHexString;
		/**
		 * Assert that a value is a valid hex string. A valid hex string must start with
		 * the "0x"-prefix.
		 *
		 * @param value - The value to check.
		 * @throws If the value is not a valid hex string.
		 */
		function assertIsStrictHexString(value) {
		    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
		}
		exports.assertIsStrictHexString = assertIsStrictHexString;
		/**
		 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
		 * prefix, it is returned as-is.
		 *
		 * @param hex - The hexadecimal string to add the prefix to.
		 * @returns The prefixed hexadecimal string.
		 */
		function add0x(hex) {
		    if (hex.startsWith('0x')) {
		        return hex;
		    }
		    if (hex.startsWith('0X')) {
		        return `0x${hex.substring(2)}`;
		    }
		    return `0x${hex}`;
		}
		exports.add0x = add0x;
		/**
		 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
		 * the prefix, it is returned as-is.
		 *
		 * @param hex - The hexadecimal string to remove the prefix from.
		 * @returns The un-prefixed hexadecimal string.
		 */
		function remove0x(hex) {
		    if (hex.startsWith('0x') || hex.startsWith('0X')) {
		        return hex.substring(2);
		    }
		    return hex;
		}
		exports.remove0x = remove0x;
		
	} (hex));

	Object.defineProperty(bytes, "__esModule", { value: true });
	bytes.createDataView = bytes.concatBytes = bytes.valueToBytes = bytes.stringToBytes = bytes.numberToBytes = bytes.signedBigIntToBytes = bytes.bigIntToBytes = bytes.hexToBytes = bytes.bytesToString = bytes.bytesToNumber = bytes.bytesToSignedBigInt = bytes.bytesToBigInt = bytes.bytesToHex = bytes.assertIsBytes = bytes.isBytes = void 0;
	const assert_1$2 = assert$3;
	const hex_1$2 = hex;
	// '0'.charCodeAt(0) === 48
	const HEX_MINIMUM_NUMBER_CHARACTER = 48;
	// '9'.charCodeAt(0) === 57
	const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
	const HEX_CHARACTER_OFFSET = 87;
	/**
	 * Memoized function that returns an array to be used as a lookup table for
	 * converting bytes to hexadecimal values.
	 *
	 * The array is created lazily and then cached for future use. The benefit of
	 * this approach is that the performance of converting bytes to hex is much
	 * better than if we were to call `toString(16)` on each byte.
	 *
	 * The downside is that the array is created once and then never garbage
	 * collected. This is not a problem in practice because the array is only 256
	 * elements long.
	 *
	 * @returns A function that returns the lookup table.
	 */
	function getPrecomputedHexValuesBuilder() {
	    // To avoid issues with tree shaking, we need to use a function to return the
	    // array. This is because the array is only used in the `bytesToHex` function
	    // and if we were to use a global variable, the array might be removed by the
	    // tree shaker.
	    const lookupTable = [];
	    return () => {
	        if (lookupTable.length === 0) {
	            for (let i = 0; i < 256; i++) {
	                lookupTable.push(i.toString(16).padStart(2, '0'));
	            }
	        }
	        return lookupTable;
	    };
	}
	/**
	 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
	 * function.
	 */
	const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
	/**
	 * Check if a value is a `Uint8Array`.
	 *
	 * @param value - The value to check.
	 * @returns Whether the value is a `Uint8Array`.
	 */
	function isBytes(value) {
	    return value instanceof Uint8Array;
	}
	bytes.isBytes = isBytes;
	/**
	 * Assert that a value is a `Uint8Array`.
	 *
	 * @param value - The value to check.
	 * @throws If the value is not a `Uint8Array`.
	 */
	function assertIsBytes(value) {
	    (0, assert_1$2.assert)(isBytes(value), 'Value must be a Uint8Array.');
	}
	bytes.assertIsBytes = assertIsBytes;
	/**
	 * Convert a `Uint8Array` to a hexadecimal string.
	 *
	 * @param bytes - The bytes to convert to a hexadecimal string.
	 * @returns The hexadecimal string.
	 */
	function bytesToHex(bytes) {
	    assertIsBytes(bytes);
	    if (bytes.length === 0) {
	        return '0x';
	    }
	    const lookupTable = getPrecomputedHexValues();
	    const hex = new Array(bytes.length);
	    for (let i = 0; i < bytes.length; i++) {
	        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	        hex[i] = lookupTable[bytes[i]];
	    }
	    return (0, hex_1$2.add0x)(hex.join(''));
	}
	bytes.bytesToHex = bytesToHex;
	/**
	 * Convert a `Uint8Array` to a `bigint`.
	 *
	 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
	 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
	 * {@link bytesToSignedBigInt}.
	 *
	 * @param bytes - The bytes to convert to a `bigint`.
	 * @returns The `bigint`.
	 */
	function bytesToBigInt(bytes) {
	    assertIsBytes(bytes);
	    const hex = bytesToHex(bytes);
	    return BigInt(hex);
	}
	bytes.bytesToBigInt = bytesToBigInt;
	/**
	 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
	 * encoded in two's complement.
	 *
	 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
	 * {@link bytesToBigInt}.
	 *
	 * @see https://en.wikipedia.org/wiki/Two%27s_complement
	 * @param bytes - The bytes to convert to a signed `bigint`.
	 * @returns The signed `bigint`.
	 */
	function bytesToSignedBigInt(bytes) {
	    assertIsBytes(bytes);
	    let value = BigInt(0);
	    for (const byte of bytes) {
	        // eslint-disable-next-line no-bitwise
	        value = (value << BigInt(8)) + BigInt(byte);
	    }
	    return BigInt.asIntN(bytes.length * 8, value);
	}
	bytes.bytesToSignedBigInt = bytesToSignedBigInt;
	/**
	 * Convert a `Uint8Array` to a `number`.
	 *
	 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
	 *
	 * @param bytes - The bytes to convert to a number.
	 * @returns The number.
	 * @throws If the resulting number is not a safe integer.
	 */
	function bytesToNumber(bytes) {
	    assertIsBytes(bytes);
	    const bigint = bytesToBigInt(bytes);
	    (0, assert_1$2.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
	    return Number(bigint);
	}
	bytes.bytesToNumber = bytesToNumber;
	/**
	 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
	 *
	 * @param bytes - The bytes to convert to a string.
	 * @returns The string.
	 */
	function bytesToString(bytes) {
	    assertIsBytes(bytes);
	    return new TextDecoder().decode(bytes);
	}
	bytes.bytesToString = bytesToString;
	/**
	 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
	 * prefixed with `0x`. It accepts even and odd length strings.
	 *
	 * If the value is "0x", an empty `Uint8Array` is returned.
	 *
	 * @param value - The hexadecimal string to convert to bytes.
	 * @returns The bytes as `Uint8Array`.
	 */
	function hexToBytes(value) {
	    var _a;
	    // "0x" is often used as empty byte array.
	    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
	        return new Uint8Array();
	    }
	    (0, hex_1$2.assertIsHexString)(value);
	    // Remove the `0x` prefix if it exists, and pad the string to have an even
	    // number of characters.
	    const strippedValue = (0, hex_1$2.remove0x)(value).toLowerCase();
	    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
	    const bytes = new Uint8Array(normalizedValue.length / 2);
	    for (let i = 0; i < bytes.length; i++) {
	        // While this is not the prettiest way to convert a hexadecimal string to a
	        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
	        // character.
	        const c1 = normalizedValue.charCodeAt(i * 2);
	        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
	        const n1 = c1 -
	            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
	                ? HEX_MINIMUM_NUMBER_CHARACTER
	                : HEX_CHARACTER_OFFSET);
	        const n2 = c2 -
	            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
	                ? HEX_MINIMUM_NUMBER_CHARACTER
	                : HEX_CHARACTER_OFFSET);
	        bytes[i] = n1 * 16 + n2;
	    }
	    return bytes;
	}
	bytes.hexToBytes = hexToBytes;
	/**
	 * Convert a `bigint` to a `Uint8Array`.
	 *
	 * This assumes that the `bigint` is an unsigned integer. To convert a signed
	 * `bigint` instead, use {@link signedBigIntToBytes}.
	 *
	 * @param value - The bigint to convert to bytes.
	 * @returns The bytes as `Uint8Array`.
	 */
	function bigIntToBytes(value) {
	    (0, assert_1$2.assert)(typeof value === 'bigint', 'Value must be a bigint.');
	    (0, assert_1$2.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
	    const hex = value.toString(16);
	    return hexToBytes(hex);
	}
	bytes.bigIntToBytes = bigIntToBytes;
	/**
	 * Check if a `bigint` fits in a certain number of bytes.
	 *
	 * @param value - The `bigint` to check.
	 * @param bytes - The number of bytes.
	 * @returns Whether the `bigint` fits in the number of bytes.
	 */
	function bigIntFits(value, bytes) {
	    (0, assert_1$2.assert)(bytes > 0);
	    /* eslint-disable no-bitwise */
	    const mask = value >> BigInt(31);
	    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
	    /* eslint-enable no-bitwise */
	}
	/**
	 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
	 * encoding to represent negative numbers.
	 *
	 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
	 * {@link bigIntToBytes}.
	 *
	 * @see https://en.wikipedia.org/wiki/Two%27s_complement
	 * @param value - The number to convert to bytes.
	 * @param byteLength - The length of the resulting `Uint8Array`. If the number
	 * is larger than the maximum value that can be represented by the given length,
	 * an error is thrown.
	 * @returns The bytes as `Uint8Array`.
	 */
	function signedBigIntToBytes(value, byteLength) {
	    (0, assert_1$2.assert)(typeof value === 'bigint', 'Value must be a bigint.');
	    (0, assert_1$2.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
	    (0, assert_1$2.assert)(byteLength > 0, 'Byte length must be greater than 0.');
	    (0, assert_1$2.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
	    // ESLint doesn't like mutating function parameters, so to avoid having to
	    // disable the rule, we create a new variable.
	    let numberValue = value;
	    const bytes = new Uint8Array(byteLength);
	    for (let i = 0; i < bytes.length; i++) {
	        bytes[i] = Number(BigInt.asUintN(8, numberValue));
	        // eslint-disable-next-line no-bitwise
	        numberValue >>= BigInt(8);
	    }
	    return bytes.reverse();
	}
	bytes.signedBigIntToBytes = signedBigIntToBytes;
	/**
	 * Convert a `number` to a `Uint8Array`.
	 *
	 * @param value - The number to convert to bytes.
	 * @returns The bytes as `Uint8Array`.
	 * @throws If the number is not a safe integer.
	 */
	function numberToBytes(value) {
	    (0, assert_1$2.assert)(typeof value === 'number', 'Value must be a number.');
	    (0, assert_1$2.assert)(value >= 0, 'Value must be a non-negative number.');
	    (0, assert_1$2.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
	    const hex = value.toString(16);
	    return hexToBytes(hex);
	}
	bytes.numberToBytes = numberToBytes;
	/**
	 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
	 *
	 * @param value - The string to convert to bytes.
	 * @returns The bytes as `Uint8Array`.
	 */
	function stringToBytes(value) {
	    (0, assert_1$2.assert)(typeof value === 'string', 'Value must be a string.');
	    return new TextEncoder().encode(value);
	}
	bytes.stringToBytes = stringToBytes;
	/**
	 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
	 * a `bigint`, a `number`, or a `string`.
	 *
	 * This will attempt to guess the type of the value based on its type and
	 * contents. For more control over the conversion, use the more specific
	 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
	 *
	 * If the value is a `string`, and it is prefixed with `0x`, it will be
	 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
	 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
	 * it as a UTF-8 string, use {@link hexToBytes} instead.
	 *
	 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
	 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
	 *
	 * If the value is a `Uint8Array`, it will be returned as-is.
	 *
	 * @param value - The value to convert to bytes.
	 * @returns The bytes as `Uint8Array`.
	 */
	function valueToBytes(value) {
	    if (typeof value === 'bigint') {
	        return bigIntToBytes(value);
	    }
	    if (typeof value === 'number') {
	        return numberToBytes(value);
	    }
	    if (typeof value === 'string') {
	        if (value.startsWith('0x')) {
	            return hexToBytes(value);
	        }
	        return stringToBytes(value);
	    }
	    if (isBytes(value)) {
	        return value;
	    }
	    throw new TypeError(`Unsupported value type: "${typeof value}".`);
	}
	bytes.valueToBytes = valueToBytes;
	/**
	 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
	 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
	 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
	 * the documentation of that function for more information.
	 *
	 * @param values - The values to concatenate.
	 * @returns The concatenated bytes as `Uint8Array`.
	 */
	function concatBytes(values) {
	    const normalizedValues = new Array(values.length);
	    let byteLength = 0;
	    for (let i = 0; i < values.length; i++) {
	        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	        const value = valueToBytes(values[i]);
	        normalizedValues[i] = value;
	        byteLength += value.length;
	    }
	    const bytes = new Uint8Array(byteLength);
	    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
	        // While we could simply spread the values into an array and use
	        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
	        bytes.set(normalizedValues[i], offset);
	        offset += normalizedValues[i].length;
	    }
	    return bytes;
	}
	bytes.concatBytes = concatBytes;
	/**
	 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
	 * function that avoids having to create a {@link DataView} manually, which
	 * requires passing the `byteOffset` and `byteLength` parameters every time.
	 *
	 * Not passing the `byteOffset` and `byteLength` parameters can result in
	 * unexpected behavior when the {@link Uint8Array} is a view of a larger
	 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
	 *
	 * This function also supports Node.js {@link Buffer}s.
	 *
	 * @example
	 * ```typescript
	 * const bytes = new Uint8Array([1, 2, 3]);
	 *
	 * // This is equivalent to:
	 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
	 * const dataView = createDataView(bytes);
	 * ```
	 * @param bytes - The bytes to create the {@link DataView} from.
	 * @returns The {@link DataView}.
	 */
	function createDataView(bytes) {
	    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
	        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
	        return new DataView(buffer);
	    }
	    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
	}
	bytes.createDataView = createDataView;

	var coercers = {};

	Object.defineProperty(coercers, "__esModule", { value: true });
	coercers.createHex = coercers.createBytes = coercers.createBigInt = coercers.createNumber = void 0;
	const superstruct_1 = lib$1;
	const hex_1$1 = hex;
	const assert_1$1 = assert$3;
	const bytes_1 = bytes;
	const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1$1.StrictHexStruct]);
	const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
	const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
	(0, superstruct_1.union)([hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
	const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1$1.StrictHexStruct]), bytes_1.hexToBytes);
	const HexCoercer = (0, superstruct_1.coerce)(hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
	/**
	 * Create a number from a number-like value.
	 *
	 * - If the value is a number, it is returned as-is.
	 * - If the value is a `bigint`, it is converted to a number.
	 * - If the value is a string, it is interpreted as a decimal number.
	 * - If the value is a hex string (i.e., it starts with "0x"), it is
	 * interpreted as a hexadecimal number.
	 *
	 * This validates that the value is a number-like value, and that the resulting
	 * number is not `NaN` or `Infinity`.
	 *
	 * @example
	 * ```typescript
	 * const value = createNumber('0x010203');
	 * console.log(value); // 66051
	 *
	 * const otherValue = createNumber(123n);
	 * console.log(otherValue); // 123
	 * ```
	 * @param value - The value to create the number from.
	 * @returns The created number.
	 * @throws If the value is not a number-like value, or if the resulting number
	 * is `NaN` or `Infinity`.
	 */
	function createNumber(value) {
	    try {
	        const result = (0, superstruct_1.create)(value, NumberCoercer);
	        (0, assert_1$1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
	        return result;
	    }
	    catch (error) {
	        if (error instanceof superstruct_1.StructError) {
	            throw new Error(`Expected a number-like value, got "${value}".`);
	        }
	        /* istanbul ignore next */
	        throw error;
	    }
	}
	coercers.createNumber = createNumber;
	/**
	 * Create a `bigint` from a number-like value.
	 *
	 * - If the value is a number, it is converted to a `bigint`.
	 * - If the value is a `bigint`, it is returned as-is.
	 * - If the value is a string, it is interpreted as a decimal number and
	 * converted to a `bigint`.
	 * - If the value is a hex string (i.e., it starts with "0x"), it is
	 * interpreted as a hexadecimal number and converted to a `bigint`.
	 *
	 * @example
	 * ```typescript
	 * const value = createBigInt('0x010203');
	 * console.log(value); // 16909060n
	 *
	 * const otherValue = createBigInt(123);
	 * console.log(otherValue); // 123n
	 * ```
	 * @param value - The value to create the bigint from.
	 * @returns The created bigint.
	 * @throws If the value is not a number-like value.
	 */
	function createBigInt(value) {
	    try {
	        // The `BigInt` constructor throws if the value is not a number-like value.
	        // There is no need to validate the value manually.
	        return (0, superstruct_1.create)(value, BigIntCoercer);
	    }
	    catch (error) {
	        if (error instanceof superstruct_1.StructError) {
	            throw new Error(`Expected a number-like value, got "${error.value}".`);
	        }
	        /* istanbul ignore next */
	        throw error;
	    }
	}
	coercers.createBigInt = createBigInt;
	/**
	 * Create a byte array from a bytes-like value.
	 *
	 * - If the value is a byte array, it is returned as-is.
	 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
	 * as a hexadecimal number and converted to a byte array.
	 *
	 * @example
	 * ```typescript
	 * const value = createBytes('0x010203');
	 * console.log(value); // Uint8Array [ 1, 2, 3 ]
	 *
	 * const otherValue = createBytes('0x010203');
	 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
	 * ```
	 * @param value - The value to create the byte array from.
	 * @returns The created byte array.
	 * @throws If the value is not a bytes-like value.
	 */
	function createBytes(value) {
	    if (typeof value === 'string' && value.toLowerCase() === '0x') {
	        return new Uint8Array();
	    }
	    try {
	        return (0, superstruct_1.create)(value, BytesCoercer);
	    }
	    catch (error) {
	        if (error instanceof superstruct_1.StructError) {
	            throw new Error(`Expected a bytes-like value, got "${error.value}".`);
	        }
	        /* istanbul ignore next */
	        throw error;
	    }
	}
	coercers.createBytes = createBytes;
	/**
	 * Create a hexadecimal string from a bytes-like value.
	 *
	 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
	 * as-is.
	 * - If the value is a `Uint8Array`, it is converted to a hex string.
	 *
	 * @example
	 * ```typescript
	 * const value = createHex(new Uint8Array([1, 2, 3]));
	 * console.log(value); // '0x010203'
	 *
	 * const otherValue = createHex('0x010203');
	 * console.log(otherValue); // '0x010203'
	 * ```
	 * @param value - The value to create the hex string from.
	 * @returns The created hex string.
	 * @throws If the value is not a bytes-like value.
	 */
	function createHex(value) {
	    if ((value instanceof Uint8Array && value.length === 0) ||
	        (typeof value === 'string' && value.toLowerCase() === '0x')) {
	        return '0x';
	    }
	    try {
	        return (0, superstruct_1.create)(value, HexCoercer);
	    }
	    catch (error) {
	        if (error instanceof superstruct_1.StructError) {
	            throw new Error(`Expected a bytes-like value, got "${error.value}".`);
	        }
	        /* istanbul ignore next */
	        throw error;
	    }
	}
	coercers.createHex = createHex;

	var collections = {};

	var __classPrivateFieldSet$1 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
	    if (kind === "m") throw new TypeError("Private method is not writable");
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
	};
	var __classPrivateFieldGet$1 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var _FrozenMap_map, _FrozenSet_set;
	Object.defineProperty(collections, "__esModule", { value: true });
	collections.FrozenSet = collections.FrozenMap = void 0;
	/**
	 * A {@link ReadonlyMap} that cannot be modified after instantiation.
	 * The implementation uses an inner map hidden via a private field, and the
	 * immutability guarantee relies on it being impossible to get a reference
	 * to this map.
	 */
	class FrozenMap {
	    constructor(entries) {
	        _FrozenMap_map.set(this, void 0);
	        __classPrivateFieldSet$1(this, _FrozenMap_map, new Map(entries), "f");
	        Object.freeze(this);
	    }
	    get size() {
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f").size;
	    }
	    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f")[Symbol.iterator]();
	    }
	    entries() {
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f").entries();
	    }
	    forEach(callbackfn, thisArg) {
	        // We have to wrap the specified callback in order to prevent it from
	        // receiving a reference to the inner map.
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
	    }
	    get(key) {
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f").get(key);
	    }
	    has(key) {
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f").has(key);
	    }
	    keys() {
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f").keys();
	    }
	    values() {
	        return __classPrivateFieldGet$1(this, _FrozenMap_map, "f").values();
	    }
	    toString() {
	        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
	    }
	}
	collections.FrozenMap = FrozenMap;
	/**
	 * A {@link ReadonlySet} that cannot be modified after instantiation.
	 * The implementation uses an inner set hidden via a private field, and the
	 * immutability guarantee relies on it being impossible to get a reference
	 * to this set.
	 */
	class FrozenSet {
	    constructor(values) {
	        _FrozenSet_set.set(this, void 0);
	        __classPrivateFieldSet$1(this, _FrozenSet_set, new Set(values), "f");
	        Object.freeze(this);
	    }
	    get size() {
	        return __classPrivateFieldGet$1(this, _FrozenSet_set, "f").size;
	    }
	    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
	        return __classPrivateFieldGet$1(this, _FrozenSet_set, "f")[Symbol.iterator]();
	    }
	    entries() {
	        return __classPrivateFieldGet$1(this, _FrozenSet_set, "f").entries();
	    }
	    forEach(callbackfn, thisArg) {
	        // We have to wrap the specified callback in order to prevent it from
	        // receiving a reference to the inner set.
	        return __classPrivateFieldGet$1(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
	    }
	    has(value) {
	        return __classPrivateFieldGet$1(this, _FrozenSet_set, "f").has(value);
	    }
	    keys() {
	        return __classPrivateFieldGet$1(this, _FrozenSet_set, "f").keys();
	    }
	    values() {
	        return __classPrivateFieldGet$1(this, _FrozenSet_set, "f").values();
	    }
	    toString() {
	        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
	    }
	}
	collections.FrozenSet = FrozenSet;
	Object.freeze(FrozenMap);
	Object.freeze(FrozenMap.prototype);
	Object.freeze(FrozenSet);
	Object.freeze(FrozenSet.prototype);

	var json$1 = {};

	var misc = {};

	(function (exports) {
		//
		// Types
		//
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
		//
		// Type Guards
		//
		/**
		 * A {@link NonEmptyArray} type guard.
		 *
		 * @template Element - The non-empty array member type.
		 * @param value - The value to check.
		 * @returns Whether the value is a non-empty array.
		 */
		function isNonEmptyArray(value) {
		    return Array.isArray(value) && value.length > 0;
		}
		exports.isNonEmptyArray = isNonEmptyArray;
		/**
		 * Type guard for "nullishness".
		 *
		 * @param value - Any value.
		 * @returns `true` if the value is null or undefined, `false` otherwise.
		 */
		function isNullOrUndefined(value) {
		    return value === null || value === undefined;
		}
		exports.isNullOrUndefined = isNullOrUndefined;
		/**
		 * A type guard for {@link RuntimeObject}.
		 *
		 * @param value - The value to check.
		 * @returns Whether the specified value has a runtime type of `object` and is
		 * neither `null` nor an `Array`.
		 */
		function isObject(value) {
		    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
		}
		exports.isObject = isObject;
		//
		// Other utility functions
		//
		/**
		 * An alias for {@link Object.hasOwnProperty}.
		 *
		 * @param object - The object to check.
		 * @param name - The property name to check for.
		 * @returns Whether the specified object has an own property with the specified
		 * name, regardless of whether it is enumerable or not.
		 */
		const hasProperty = (object, name) => Object.hasOwnProperty.call(object, name);
		exports.hasProperty = hasProperty;
		(function (JsonSize) {
		    JsonSize[JsonSize["Null"] = 4] = "Null";
		    JsonSize[JsonSize["Comma"] = 1] = "Comma";
		    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
		    JsonSize[JsonSize["True"] = 4] = "True";
		    JsonSize[JsonSize["False"] = 5] = "False";
		    JsonSize[JsonSize["Quote"] = 1] = "Quote";
		    JsonSize[JsonSize["Colon"] = 1] = "Colon";
		    // eslint-disable-next-line @typescript-eslint/no-shadow
		    JsonSize[JsonSize["Date"] = 24] = "Date";
		})(exports.JsonSize || (exports.JsonSize = {}));
		/**
		 * Regular expression with pattern matching for (special) escaped characters.
		 */
		exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
		/**
		 * Check if the value is plain object.
		 *
		 * @param value - Value to be checked.
		 * @returns True if an object is the plain JavaScript object,
		 * false if the object is not plain (e.g. function).
		 */
		function isPlainObject(value) {
		    if (typeof value !== 'object' || value === null) {
		        return false;
		    }
		    try {
		        let proto = value;
		        while (Object.getPrototypeOf(proto) !== null) {
		            proto = Object.getPrototypeOf(proto);
		        }
		        return Object.getPrototypeOf(value) === proto;
		    }
		    catch (_) {
		        return false;
		    }
		}
		exports.isPlainObject = isPlainObject;
		/**
		 * Check if character is ASCII.
		 *
		 * @param character - Character.
		 * @returns True if a character code is ASCII, false if not.
		 */
		function isASCII(character) {
		    return character.charCodeAt(0) <= 127;
		}
		exports.isASCII = isASCII;
		/**
		 * Calculate string size.
		 *
		 * @param value - String value to calculate size.
		 * @returns Number of bytes used to store whole string value.
		 */
		function calculateStringSize(value) {
		    var _a;
		    const size = value.split('').reduce((total, character) => {
		        if (isASCII(character)) {
		            return total + 1;
		        }
		        return total + 2;
		    }, 0);
		    // Also detect characters that need backslash escape
		    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
		}
		exports.calculateStringSize = calculateStringSize;
		/**
		 * Calculate size of a number ofter JSON serialization.
		 *
		 * @param value - Number value to calculate size.
		 * @returns Number of bytes used to store whole number in JSON.
		 */
		function calculateNumberSize(value) {
		    return value.toString().length;
		}
		exports.calculateNumberSize = calculateNumberSize;
		
	} (misc));

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
		const superstruct_1 = lib$1;
		const assert_1 = assert$3;
		const misc_1 = misc;
		exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
		    const [isValid] = validateJsonAndGetSize(value, true);
		    if (!isValid) {
		        return 'Expected a valid JSON-serializable value';
		    }
		    return true;
		});
		/**
		 * Check if the given value is a valid {@link Json} value, i.e., a value that is
		 * serializable to JSON.
		 *
		 * @param value - The value to check.
		 * @returns Whether the value is a valid {@link Json} value.
		 */
		function isValidJson(value) {
		    return (0, superstruct_1.is)(value, exports.JsonStruct);
		}
		exports.isValidJson = isValidJson;
		/**
		 * The string '2.0'.
		 */
		exports.jsonrpc2 = '2.0';
		exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
		exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
		exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
		    code: (0, superstruct_1.integer)(),
		    message: (0, superstruct_1.string)(),
		    data: (0, superstruct_1.optional)(exports.JsonStruct),
		    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
		});
		exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
		exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
		    id: exports.JsonRpcIdStruct,
		    jsonrpc: exports.JsonRpcVersionStruct,
		    method: (0, superstruct_1.string)(),
		    params: exports.JsonRpcParamsStruct,
		});
		exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
		/**
		 * Check if the given value is a valid {@link JsonRpcNotification} object.
		 *
		 * @param value - The value to check.
		 * @returns Whether the given value is a valid {@link JsonRpcNotification}
		 * object.
		 */
		function isJsonRpcNotification(value) {
		    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
		}
		exports.isJsonRpcNotification = isJsonRpcNotification;
		/**
		 * Assert that the given value is a valid {@link JsonRpcNotification} object.
		 *
		 * @param value - The value to check.
		 * @param ErrorWrapper - The error class to throw if the assertion fails.
		 * Defaults to {@link AssertionError}.
		 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
		 */
		function assertIsJsonRpcNotification(value, ErrorWrapper) {
		    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
		}
		exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
		/**
		 * Check if the given value is a valid {@link JsonRpcRequest} object.
		 *
		 * @param value - The value to check.
		 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
		 */
		function isJsonRpcRequest(value) {
		    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
		}
		exports.isJsonRpcRequest = isJsonRpcRequest;
		/**
		 * Assert that the given value is a valid {@link JsonRpcRequest} object.
		 *
		 * @param value - The JSON-RPC request or notification to check.
		 * @param ErrorWrapper - The error class to throw if the assertion fails.
		 * Defaults to {@link AssertionError}.
		 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
		 */
		function assertIsJsonRpcRequest(value, ErrorWrapper) {
		    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
		}
		exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
		exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
		    id: exports.JsonRpcIdStruct,
		    jsonrpc: exports.JsonRpcVersionStruct,
		    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
		    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
		});
		exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
		    id: exports.JsonRpcIdStruct,
		    jsonrpc: exports.JsonRpcVersionStruct,
		    result: exports.JsonStruct,
		});
		exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
		    id: exports.JsonRpcIdStruct,
		    jsonrpc: exports.JsonRpcVersionStruct,
		    error: exports.JsonRpcErrorStruct,
		});
		exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
		    exports.JsonRpcSuccessStruct,
		    exports.JsonRpcFailureStruct,
		]);
		/**
		 * Type guard to check whether specified JSON-RPC response is a
		 * {@link PendingJsonRpcResponse}.
		 *
		 * @param response - The JSON-RPC response to check.
		 * @returns Whether the specified JSON-RPC response is pending.
		 */
		function isPendingJsonRpcResponse(response) {
		    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
		}
		exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
		/**
		 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
		 *
		 * @param response - The JSON-RPC response to check.
		 * @param ErrorWrapper - The error class to throw if the assertion fails.
		 * Defaults to {@link AssertionError}.
		 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
		 * object.
		 */
		function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
		    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
		}
		exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
		/**
		 * Type guard to check if a value is a {@link JsonRpcResponse}.
		 *
		 * @param response - The object to check.
		 * @returns Whether the object is a JsonRpcResponse.
		 */
		function isJsonRpcResponse(response) {
		    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
		}
		exports.isJsonRpcResponse = isJsonRpcResponse;
		/**
		 * Assert that the given value is a valid {@link JsonRpcResponse} object.
		 *
		 * @param value - The value to check.
		 * @param ErrorWrapper - The error class to throw if the assertion fails.
		 * Defaults to {@link AssertionError}.
		 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
		 */
		function assertIsJsonRpcResponse(value, ErrorWrapper) {
		    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
		}
		exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
		/**
		 * Check if the given value is a valid {@link JsonRpcSuccess} object.
		 *
		 * @param value - The value to check.
		 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
		 */
		function isJsonRpcSuccess(value) {
		    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
		}
		exports.isJsonRpcSuccess = isJsonRpcSuccess;
		/**
		 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
		 *
		 * @param value - The value to check.
		 * @param ErrorWrapper - The error class to throw if the assertion fails.
		 * Defaults to {@link AssertionError}.
		 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
		 */
		function assertIsJsonRpcSuccess(value, ErrorWrapper) {
		    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
		}
		exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
		/**
		 * Check if the given value is a valid {@link JsonRpcFailure} object.
		 *
		 * @param value - The value to check.
		 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
		 */
		function isJsonRpcFailure(value) {
		    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
		}
		exports.isJsonRpcFailure = isJsonRpcFailure;
		/**
		 * Assert that the given value is a valid {@link JsonRpcFailure} object.
		 *
		 * @param value - The value to check.
		 * @param ErrorWrapper - The error class to throw if the assertion fails.
		 * Defaults to {@link AssertionError}.
		 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
		 */
		function assertIsJsonRpcFailure(value, ErrorWrapper) {
		    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
		}
		exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
		/**
		 * Check if the given value is a valid {@link JsonRpcError} object.
		 *
		 * @param value - The value to check.
		 * @returns Whether the given value is a valid {@link JsonRpcError} object.
		 */
		function isJsonRpcError(value) {
		    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
		}
		exports.isJsonRpcError = isJsonRpcError;
		/**
		 * Assert that the given value is a valid {@link JsonRpcError} object.
		 *
		 * @param value - The value to check.
		 * @param ErrorWrapper - The error class to throw if the assertion fails.
		 * Defaults to {@link AssertionError}.
		 * @throws If the given value is not a valid {@link JsonRpcError} object.
		 */
		function assertIsJsonRpcError(value, ErrorWrapper) {
		    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
		}
		exports.assertIsJsonRpcError = assertIsJsonRpcError;
		/**
		 * Gets a function for validating JSON-RPC request / response `id` values.
		 *
		 * By manipulating the options of this factory, you can control the behavior
		 * of the resulting validator for some edge cases. This is useful because e.g.
		 * `null` should sometimes but not always be permitted.
		 *
		 * Note that the empty string (`''`) is always permitted by the JSON-RPC
		 * specification, but that kind of sucks and you may want to forbid it in some
		 * instances anyway.
		 *
		 * For more details, see the
		 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
		 *
		 * @param options - An options object.
		 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
		 * should be treated as a valid ID. Default: `true`
		 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
		 * should be treated as valid IDs. Default: `false`
		 * @param options.permitNull - Whether `null` should be treated as a valid ID.
		 * Default: `true`
		 * @returns The JSON-RPC ID validator function.
		 */
		function getJsonRpcIdValidator(options) {
		    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
		    /**
		     * Type guard for {@link JsonRpcId}.
		     *
		     * @param id - The JSON-RPC ID value to check.
		     * @returns Whether the given ID is valid per the options given to the
		     * factory.
		     */
		    const isValidJsonRpcId = (id) => {
		        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
		            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
		            (permitNull && id === null));
		    };
		    return isValidJsonRpcId;
		}
		exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
		/**
		 * Checks whether a value is JSON serializable and counts the total number
		 * of bytes needed to store the serialized version of the value.
		 *
		 * @param jsObject - Potential JSON serializable object.
		 * @param skipSizingProcess - Skip JSON size calculation (default: false).
		 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
		 * the value was serializable and a number of bytes that it will use when serialized to JSON.
		 */
		function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
		    const seenObjects = new Set();
		    /**
		     * Checks whether a value is JSON serializable and counts the total number
		     * of bytes needed to store the serialized version of the value.
		     *
		     * This function assumes the encoding of the JSON is done in UTF-8.
		     *
		     * @param value - Potential JSON serializable value.
		     * @param skipSizing - Skip JSON size calculation (default: false).
		     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
		     * the value was serializable and a number of bytes that it will use when serialized to JSON.
		     */
		    function getJsonSerializableInfo(value, skipSizing) {
		        if (value === undefined) {
		            return [false, 0];
		        }
		        else if (value === null) {
		            // Return already specified constant size for null (special object)
		            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
		        }
		        // Check and calculate sizes for basic (and some special) types
		        const typeOfValue = typeof value;
		        try {
		            if (typeOfValue === 'function') {
		                return [false, 0];
		            }
		            else if (typeOfValue === 'string' || value instanceof String) {
		                return [
		                    true,
		                    skipSizing
		                        ? 0
		                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
		                ];
		            }
		            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
		                if (skipSizing) {
		                    return [true, 0];
		                }
		                // eslint-disable-next-line eqeqeq
		                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
		            }
		            else if (typeOfValue === 'number' || value instanceof Number) {
		                if (skipSizing) {
		                    return [true, 0];
		                }
		                return [true, (0, misc_1.calculateNumberSize)(value)];
		            }
		            else if (value instanceof Date) {
		                if (skipSizing) {
		                    return [true, 0];
		                }
		                return [
		                    true,
		                    // Note: Invalid dates will serialize to null
		                    isNaN(value.getDate())
		                        ? misc_1.JsonSize.Null
		                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
		                ];
		            }
		        }
		        catch (_) {
		            return [false, 0];
		        }
		        // If object is not plain and cannot be serialized properly,
		        // stop here and return false for serialization
		        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
		            return [false, 0];
		        }
		        // Circular object detection (handling)
		        // Check if the same object already exists
		        if (seenObjects.has(value)) {
		            return [false, 0];
		        }
		        // Add new object to the seen objects set
		        // Only the plain objects should be added (Primitive types are skipped)
		        seenObjects.add(value);
		        // Continue object decomposition
		        try {
		            return [
		                true,
		                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
		                    // Recursively process next nested object or primitive type
		                    // eslint-disable-next-line prefer-const
		                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
		                    if (!valid) {
		                        throw new Error('JSON validation did not pass. Validation process stopped.');
		                    }
		                    // Circular object detection
		                    // Once a child node is visited and processed remove it from the set.
		                    // This will prevent false positives with the same adjacent objects.
		                    seenObjects.delete(value);
		                    if (skipSizing) {
		                        return 0;
		                    }
		                    // Objects will have be serialized with "key": value,
		                    // therefore we include the key in the calculation here
		                    const keySize = Array.isArray(value)
		                        ? 0
		                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
		                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
		                    return sum + keySize + size + separator;
		                }, 
		                // Starts at 2 because the serialized JSON string data (plain text)
		                // will minimally contain {}/[]
		                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
		            ];
		        }
		        catch (_) {
		            return [false, 0];
		        }
		    }
		    return getJsonSerializableInfo(jsObject, skipSizingProcess);
		}
		exports.validateJsonAndGetSize = validateJsonAndGetSize;
		
	} (json$1));

	var logging = {};

	var src = {exports: {}};

	var browser$2 = {exports: {}};

	/**
	 * Helpers.
	 */

	var ms;
	var hasRequiredMs;

	function requireMs () {
		if (hasRequiredMs) return ms;
		hasRequiredMs = 1;
		var s = 1000;
		var m = s * 60;
		var h = m * 60;
		var d = h * 24;
		var w = d * 7;
		var y = d * 365.25;

		/**
		 * Parse or format the given `val`.
		 *
		 * Options:
		 *
		 *  - `long` verbose formatting [false]
		 *
		 * @param {String|Number} val
		 * @param {Object} [options]
		 * @throws {Error} throw an error if val is not a non-empty string or a number
		 * @return {String|Number}
		 * @api public
		 */

		ms = function(val, options) {
		  options = options || {};
		  var type = typeof val;
		  if (type === 'string' && val.length > 0) {
		    return parse(val);
		  } else if (type === 'number' && isFinite(val)) {
		    return options.long ? fmtLong(val) : fmtShort(val);
		  }
		  throw new Error(
		    'val is not a non-empty string or a valid number. val=' +
		      JSON.stringify(val)
		  );
		};

		/**
		 * Parse the given `str` and return milliseconds.
		 *
		 * @param {String} str
		 * @return {Number}
		 * @api private
		 */

		function parse(str) {
		  str = String(str);
		  if (str.length > 100) {
		    return;
		  }
		  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
		    str
		  );
		  if (!match) {
		    return;
		  }
		  var n = parseFloat(match[1]);
		  var type = (match[2] || 'ms').toLowerCase();
		  switch (type) {
		    case 'years':
		    case 'year':
		    case 'yrs':
		    case 'yr':
		    case 'y':
		      return n * y;
		    case 'weeks':
		    case 'week':
		    case 'w':
		      return n * w;
		    case 'days':
		    case 'day':
		    case 'd':
		      return n * d;
		    case 'hours':
		    case 'hour':
		    case 'hrs':
		    case 'hr':
		    case 'h':
		      return n * h;
		    case 'minutes':
		    case 'minute':
		    case 'mins':
		    case 'min':
		    case 'm':
		      return n * m;
		    case 'seconds':
		    case 'second':
		    case 'secs':
		    case 'sec':
		    case 's':
		      return n * s;
		    case 'milliseconds':
		    case 'millisecond':
		    case 'msecs':
		    case 'msec':
		    case 'ms':
		      return n;
		    default:
		      return undefined;
		  }
		}

		/**
		 * Short format for `ms`.
		 *
		 * @param {Number} ms
		 * @return {String}
		 * @api private
		 */

		function fmtShort(ms) {
		  var msAbs = Math.abs(ms);
		  if (msAbs >= d) {
		    return Math.round(ms / d) + 'd';
		  }
		  if (msAbs >= h) {
		    return Math.round(ms / h) + 'h';
		  }
		  if (msAbs >= m) {
		    return Math.round(ms / m) + 'm';
		  }
		  if (msAbs >= s) {
		    return Math.round(ms / s) + 's';
		  }
		  return ms + 'ms';
		}

		/**
		 * Long format for `ms`.
		 *
		 * @param {Number} ms
		 * @return {String}
		 * @api private
		 */

		function fmtLong(ms) {
		  var msAbs = Math.abs(ms);
		  if (msAbs >= d) {
		    return plural(ms, msAbs, d, 'day');
		  }
		  if (msAbs >= h) {
		    return plural(ms, msAbs, h, 'hour');
		  }
		  if (msAbs >= m) {
		    return plural(ms, msAbs, m, 'minute');
		  }
		  if (msAbs >= s) {
		    return plural(ms, msAbs, s, 'second');
		  }
		  return ms + ' ms';
		}

		/**
		 * Pluralization helper.
		 */

		function plural(ms, msAbs, n, name) {
		  var isPlural = msAbs >= n * 1.5;
		  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
		}
		return ms;
	}

	var common;
	var hasRequiredCommon;

	function requireCommon () {
		if (hasRequiredCommon) return common;
		hasRequiredCommon = 1;
		/**
		 * This is the common logic for both the Node.js and web browser
		 * implementations of `debug()`.
		 */

		function setup(env) {
			createDebug.debug = createDebug;
			createDebug.default = createDebug;
			createDebug.coerce = coerce;
			createDebug.disable = disable;
			createDebug.enable = enable;
			createDebug.enabled = enabled;
			createDebug.humanize = requireMs();
			createDebug.destroy = destroy;

			Object.keys(env).forEach(key => {
				createDebug[key] = env[key];
			});

			/**
			* The currently active debug mode names, and names to skip.
			*/

			createDebug.names = [];
			createDebug.skips = [];

			/**
			* Map of special "%n" handling functions, for the debug "format" argument.
			*
			* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
			*/
			createDebug.formatters = {};

			/**
			* Selects a color for a debug namespace
			* @param {String} namespace The namespace string for the debug instance to be colored
			* @return {Number|String} An ANSI color code for the given namespace
			* @api private
			*/
			function selectColor(namespace) {
				let hash = 0;

				for (let i = 0; i < namespace.length; i++) {
					hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
					hash |= 0; // Convert to 32bit integer
				}

				return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
			}
			createDebug.selectColor = selectColor;

			/**
			* Create a debugger with the given `namespace`.
			*
			* @param {String} namespace
			* @return {Function}
			* @api public
			*/
			function createDebug(namespace) {
				let prevTime;
				let enableOverride = null;
				let namespacesCache;
				let enabledCache;

				function debug(...args) {
					// Disabled?
					if (!debug.enabled) {
						return;
					}

					const self = debug;

					// Set `diff` timestamp
					const curr = Number(new Date());
					const ms = curr - (prevTime || curr);
					self.diff = ms;
					self.prev = prevTime;
					self.curr = curr;
					prevTime = curr;

					args[0] = createDebug.coerce(args[0]);

					if (typeof args[0] !== 'string') {
						// Anything else let's inspect with %O
						args.unshift('%O');
					}

					// Apply any `formatters` transformations
					let index = 0;
					args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
						// If we encounter an escaped % then don't increase the array index
						if (match === '%%') {
							return '%';
						}
						index++;
						const formatter = createDebug.formatters[format];
						if (typeof formatter === 'function') {
							const val = args[index];
							match = formatter.call(self, val);

							// Now we need to remove `args[index]` since it's inlined in the `format`
							args.splice(index, 1);
							index--;
						}
						return match;
					});

					// Apply env-specific formatting (colors, etc.)
					createDebug.formatArgs.call(self, args);

					const logFn = self.log || createDebug.log;
					logFn.apply(self, args);
				}

				debug.namespace = namespace;
				debug.useColors = createDebug.useColors();
				debug.color = createDebug.selectColor(namespace);
				debug.extend = extend;
				debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

				Object.defineProperty(debug, 'enabled', {
					enumerable: true,
					configurable: false,
					get: () => {
						if (enableOverride !== null) {
							return enableOverride;
						}
						if (namespacesCache !== createDebug.namespaces) {
							namespacesCache = createDebug.namespaces;
							enabledCache = createDebug.enabled(namespace);
						}

						return enabledCache;
					},
					set: v => {
						enableOverride = v;
					}
				});

				// Env-specific initialization logic for debug instances
				if (typeof createDebug.init === 'function') {
					createDebug.init(debug);
				}

				return debug;
			}

			function extend(namespace, delimiter) {
				const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
				newDebug.log = this.log;
				return newDebug;
			}

			/**
			* Enables a debug mode by namespaces. This can include modes
			* separated by a colon and wildcards.
			*
			* @param {String} namespaces
			* @api public
			*/
			function enable(namespaces) {
				createDebug.save(namespaces);
				createDebug.namespaces = namespaces;

				createDebug.names = [];
				createDebug.skips = [];

				let i;
				const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
				const len = split.length;

				for (i = 0; i < len; i++) {
					if (!split[i]) {
						// ignore empty strings
						continue;
					}

					namespaces = split[i].replace(/\*/g, '.*?');

					if (namespaces[0] === '-') {
						createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
					} else {
						createDebug.names.push(new RegExp('^' + namespaces + '$'));
					}
				}
			}

			/**
			* Disable debug output.
			*
			* @return {String} namespaces
			* @api public
			*/
			function disable() {
				const namespaces = [
					...createDebug.names.map(toNamespace),
					...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
				].join(',');
				createDebug.enable('');
				return namespaces;
			}

			/**
			* Returns true if the given mode name is enabled, false otherwise.
			*
			* @param {String} name
			* @return {Boolean}
			* @api public
			*/
			function enabled(name) {
				if (name[name.length - 1] === '*') {
					return true;
				}

				let i;
				let len;

				for (i = 0, len = createDebug.skips.length; i < len; i++) {
					if (createDebug.skips[i].test(name)) {
						return false;
					}
				}

				for (i = 0, len = createDebug.names.length; i < len; i++) {
					if (createDebug.names[i].test(name)) {
						return true;
					}
				}

				return false;
			}

			/**
			* Convert regexp to namespace
			*
			* @param {RegExp} regxep
			* @return {String} namespace
			* @api private
			*/
			function toNamespace(regexp) {
				return regexp.toString()
					.substring(2, regexp.toString().length - 2)
					.replace(/\.\*\?$/, '*');
			}

			/**
			* Coerce `val`.
			*
			* @param {Mixed} val
			* @return {Mixed}
			* @api private
			*/
			function coerce(val) {
				if (val instanceof Error) {
					return val.stack || val.message;
				}
				return val;
			}

			/**
			* XXX DO NOT USE. This is a temporary stub function.
			* XXX It WILL be removed in the next major release.
			*/
			function destroy() {
				console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
			}

			createDebug.enable(createDebug.load());

			return createDebug;
		}

		common = setup;
		return common;
	}

	/* eslint-env browser */

	var hasRequiredBrowser;

	function requireBrowser () {
		if (hasRequiredBrowser) return browser$2.exports;
		hasRequiredBrowser = 1;
		(function (module, exports) {
			/**
			 * This is the web browser implementation of `debug()`.
			 */

			exports.formatArgs = formatArgs;
			exports.save = save;
			exports.load = load;
			exports.useColors = useColors;
			exports.storage = localstorage();
			exports.destroy = (() => {
				let warned = false;

				return () => {
					if (!warned) {
						warned = true;
						console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
					}
				};
			})();

			/**
			 * Colors.
			 */

			exports.colors = [
				'#0000CC',
				'#0000FF',
				'#0033CC',
				'#0033FF',
				'#0066CC',
				'#0066FF',
				'#0099CC',
				'#0099FF',
				'#00CC00',
				'#00CC33',
				'#00CC66',
				'#00CC99',
				'#00CCCC',
				'#00CCFF',
				'#3300CC',
				'#3300FF',
				'#3333CC',
				'#3333FF',
				'#3366CC',
				'#3366FF',
				'#3399CC',
				'#3399FF',
				'#33CC00',
				'#33CC33',
				'#33CC66',
				'#33CC99',
				'#33CCCC',
				'#33CCFF',
				'#6600CC',
				'#6600FF',
				'#6633CC',
				'#6633FF',
				'#66CC00',
				'#66CC33',
				'#9900CC',
				'#9900FF',
				'#9933CC',
				'#9933FF',
				'#99CC00',
				'#99CC33',
				'#CC0000',
				'#CC0033',
				'#CC0066',
				'#CC0099',
				'#CC00CC',
				'#CC00FF',
				'#CC3300',
				'#CC3333',
				'#CC3366',
				'#CC3399',
				'#CC33CC',
				'#CC33FF',
				'#CC6600',
				'#CC6633',
				'#CC9900',
				'#CC9933',
				'#CCCC00',
				'#CCCC33',
				'#FF0000',
				'#FF0033',
				'#FF0066',
				'#FF0099',
				'#FF00CC',
				'#FF00FF',
				'#FF3300',
				'#FF3333',
				'#FF3366',
				'#FF3399',
				'#FF33CC',
				'#FF33FF',
				'#FF6600',
				'#FF6633',
				'#FF9900',
				'#FF9933',
				'#FFCC00',
				'#FFCC33'
			];

			/**
			 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
			 * and the Firebug extension (any Firefox version) are known
			 * to support "%c" CSS customizations.
			 *
			 * TODO: add a `localStorage` variable to explicitly enable/disable colors
			 */

			// eslint-disable-next-line complexity
			function useColors() {
				// NB: In an Electron preload script, document will be defined but not fully
				// initialized. Since we know we're in Chrome, we'll just detect this case
				// explicitly
				if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
					return true;
				}

				// Internet Explorer and Edge do not support colors.
				if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
					return false;
				}

				// Is webkit? http://stackoverflow.com/a/16459606/376773
				// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
				return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
					// Is firebug? http://stackoverflow.com/a/398120/376773
					(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
					// Is firefox >= v31?
					// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
					(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
					// Double check webkit in userAgent just in case we are in a worker
					(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
			}

			/**
			 * Colorize log arguments if enabled.
			 *
			 * @api public
			 */

			function formatArgs(args) {
				args[0] = (this.useColors ? '%c' : '') +
					this.namespace +
					(this.useColors ? ' %c' : ' ') +
					args[0] +
					(this.useColors ? '%c ' : ' ') +
					'+' + module.exports.humanize(this.diff);

				if (!this.useColors) {
					return;
				}

				const c = 'color: ' + this.color;
				args.splice(1, 0, c, 'color: inherit');

				// The final "%c" is somewhat tricky, because there could be other
				// arguments passed either before or after the %c, so we need to
				// figure out the correct index to insert the CSS into
				let index = 0;
				let lastC = 0;
				args[0].replace(/%[a-zA-Z%]/g, match => {
					if (match === '%%') {
						return;
					}
					index++;
					if (match === '%c') {
						// We only are interested in the *last* %c
						// (the user may have provided their own)
						lastC = index;
					}
				});

				args.splice(lastC, 0, c);
			}

			/**
			 * Invokes `console.debug()` when available.
			 * No-op when `console.debug` is not a "function".
			 * If `console.debug` is not available, falls back
			 * to `console.log`.
			 *
			 * @api public
			 */
			exports.log = console.debug || console.log || (() => {});

			/**
			 * Save `namespaces`.
			 *
			 * @param {String} namespaces
			 * @api private
			 */
			function save(namespaces) {
				try {
					if (namespaces) {
						exports.storage.setItem('debug', namespaces);
					} else {
						exports.storage.removeItem('debug');
					}
				} catch (error) {
					// Swallow
					// XXX (@Qix-) should we be logging these?
				}
			}

			/**
			 * Load `namespaces`.
			 *
			 * @return {String} returns the previously persisted debug modes
			 * @api private
			 */
			function load() {
				let r;
				try {
					r = exports.storage.getItem('debug');
				} catch (error) {
					// Swallow
					// XXX (@Qix-) should we be logging these?
				}

				// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
				if (!r && typeof process !== 'undefined' && 'env' in process) {
					r = process.env.DEBUG;
				}

				return r;
			}

			/**
			 * Localstorage attempts to return the localstorage.
			 *
			 * This is necessary because safari throws
			 * when a user disables cookies/localstorage
			 * and you attempt to access it.
			 *
			 * @return {LocalStorage}
			 * @api private
			 */

			function localstorage() {
				try {
					// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
					// The Browser also has localStorage in the global context.
					return localStorage;
				} catch (error) {
					// Swallow
					// XXX (@Qix-) should we be logging these?
				}
			}

			module.exports = requireCommon()(exports);

			const {formatters} = module.exports;

			/**
			 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
			 */

			formatters.j = function (v) {
				try {
					return JSON.stringify(v);
				} catch (error) {
					return '[UnexpectedJSONParseError]: ' + error.message;
				}
			};
	} (browser$2, browser$2.exports));
		return browser$2.exports;
	}

	var node = {exports: {}};

	// MIT lisence
	// from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js

	function isatty() {
	  return false;
	}

	function ReadStream() {
	  throw new Error('tty.ReadStream is not implemented');
	}

	function WriteStream() {
	  throw new Error('tty.ReadStream is not implemented');
	}

	var tty = {
	  isatty: isatty,
	  ReadStream: ReadStream,
	  WriteStream: WriteStream
	};

	var tty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		isatty: isatty,
		ReadStream: ReadStream,
		WriteStream: WriteStream,
		default: tty
	});

	var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(tty$1);

	var global$1 = (typeof global !== "undefined" ? global :
	            typeof self !== "undefined" ? self :
	            typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform$1 = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release$1 = {};
	var config = {};

	function noop() {}

	var on = noop;
	var addListener = noop;
	var once = noop;
	var off = noop;
	var removeListener = noop;
	var removeAllListeners = noop;
	var emit = noop;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime$1() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var browser$1 = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform$1,
	  release: release$1,
	  config: config,
	  uptime: uptime$1
	};

	var process$1 = browser$1;

	var inherits;
	if (typeof Object.create === 'function'){
	  inherits = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	var inherits$1 = inherits;

	var formatRegExp = /%[sdj%]/g;
	function format(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global$1.process)) {
	    return function() {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process$1.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process$1.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process$1.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function() {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray$2(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty$1(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty$1(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray$2(ar) {
	  return Array.isArray(ar);
	}

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}

	function isNull(arg) {
	  return arg === null;
	}

	function isNullOrUndefined(arg) {
	  return arg == null;
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isString(arg) {
	  return typeof arg === 'string';
	}

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}

	function isBuffer(maybeBuf) {
	  return Buffer.isBuffer(maybeBuf);
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	function log$3() {
	  console.log('%s - %s', timestamp(), format.apply(null, arguments));
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty$1(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	var util = {
	  inherits: inherits$1,
	  _extend: _extend,
	  log: log$3,
	  isBuffer: isBuffer,
	  isPrimitive: isPrimitive,
	  isFunction: isFunction,
	  isError: isError,
	  isDate: isDate,
	  isObject: isObject,
	  isRegExp: isRegExp,
	  isUndefined: isUndefined,
	  isSymbol: isSymbol,
	  isString: isString,
	  isNumber: isNumber,
	  isNullOrUndefined: isNullOrUndefined,
	  isNull: isNull,
	  isBoolean: isBoolean,
	  isArray: isArray$2,
	  inspect: inspect,
	  deprecate: deprecate,
	  format: format,
	  debuglog: debuglog
	};

	var util$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		format: format,
		deprecate: deprecate,
		debuglog: debuglog,
		inspect: inspect,
		isArray: isArray$2,
		isBoolean: isBoolean,
		isNull: isNull,
		isNullOrUndefined: isNullOrUndefined,
		isNumber: isNumber,
		isString: isString,
		isSymbol: isSymbol,
		isUndefined: isUndefined,
		isRegExp: isRegExp,
		isObject: isObject,
		isDate: isDate,
		isError: isError,
		isFunction: isFunction,
		isPrimitive: isPrimitive,
		isBuffer: isBuffer,
		log: log$3,
		inherits: inherits$1,
		_extend: _extend,
		default: util
	});

	var require$$1 = /*@__PURE__*/getAugmentedNamespace(util$1);

	/*
	The MIT License (MIT)

	Copyright (c) 2016 CoderPuppy

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

	*/
	var _endianness;
	function endianness() {
	  if (typeof _endianness === 'undefined') {
	    var a = new ArrayBuffer(2);
	    var b = new Uint8Array(a);
	    var c = new Uint16Array(a);
	    b[0] = 1;
	    b[1] = 2;
	    if (c[0] === 258) {
	      _endianness = 'BE';
	    } else if (c[0] === 513){
	      _endianness = 'LE';
	    } else {
	      throw new Error('unable to figure out endianess');
	    }
	  }
	  return _endianness;
	}

	function hostname() {
	  if (typeof global$1.location !== 'undefined') {
	    return global$1.location.hostname
	  } else return '';
	}

	function loadavg() {
	  return [];
	}

	function uptime() {
	  return 0;
	}

	function freemem() {
	  return Number.MAX_VALUE;
	}

	function totalmem() {
	  return Number.MAX_VALUE;
	}

	function cpus() {
	  return [];
	}

	function type() {
	  return 'Browser';
	}

	function release () {
	  if (typeof global$1.navigator !== 'undefined') {
	    return global$1.navigator.appVersion;
	  }
	  return '';
	}

	function networkInterfaces(){}
	function getNetworkInterfaces(){}

	function arch() {
	  return 'javascript';
	}

	function platform() {
	  return 'browser';
	}

	function tmpDir() {
	  return '/tmp';
	}
	var tmpdir = tmpDir;

	var EOL = '\n';
	var os = {
	  EOL: EOL,
	  tmpdir: tmpdir,
	  tmpDir: tmpDir,
	  networkInterfaces:networkInterfaces,
	  getNetworkInterfaces: getNetworkInterfaces,
	  release: release,
	  type: type,
	  cpus: cpus,
	  totalmem: totalmem,
	  freemem: freemem,
	  uptime: uptime,
	  loadavg: loadavg,
	  hostname: hostname,
	  endianness: endianness,
	};

	var os$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		endianness: endianness,
		hostname: hostname,
		loadavg: loadavg,
		uptime: uptime,
		freemem: freemem,
		totalmem: totalmem,
		cpus: cpus,
		type: type,
		release: release,
		networkInterfaces: networkInterfaces,
		getNetworkInterfaces: getNetworkInterfaces,
		arch: arch,
		platform: platform,
		tmpDir: tmpDir,
		tmpdir: tmpdir,
		EOL: EOL,
		default: os
	});

	var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(os$1);

	var hasFlag;
	var hasRequiredHasFlag;

	function requireHasFlag () {
		if (hasRequiredHasFlag) return hasFlag;
		hasRequiredHasFlag = 1;
		hasFlag = (flag, argv) => {
			argv = argv || process.argv;
			const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
			const pos = argv.indexOf(prefix + flag);
			const terminatorPos = argv.indexOf('--');
			return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
		};
		return hasFlag;
	}

	var supportsColor_1;
	var hasRequiredSupportsColor;

	function requireSupportsColor () {
		if (hasRequiredSupportsColor) return supportsColor_1;
		hasRequiredSupportsColor = 1;
		const os = require$$0$1;
		const hasFlag = requireHasFlag();

		const env = process.env;

		let forceColor;
		if (hasFlag('no-color') ||
			hasFlag('no-colors') ||
			hasFlag('color=false')) {
			forceColor = false;
		} else if (hasFlag('color') ||
			hasFlag('colors') ||
			hasFlag('color=true') ||
			hasFlag('color=always')) {
			forceColor = true;
		}
		if ('FORCE_COLOR' in env) {
			forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
		}

		function translateLevel(level) {
			if (level === 0) {
				return false;
			}

			return {
				level,
				hasBasic: true,
				has256: level >= 2,
				has16m: level >= 3
			};
		}

		function supportsColor(stream) {
			if (forceColor === false) {
				return 0;
			}

			if (hasFlag('color=16m') ||
				hasFlag('color=full') ||
				hasFlag('color=truecolor')) {
				return 3;
			}

			if (hasFlag('color=256')) {
				return 2;
			}

			if (stream && !stream.isTTY && forceColor !== true) {
				return 0;
			}

			const min = forceColor ? 1 : 0;

			if (process.platform === 'win32') {
				// Node.js 7.5.0 is the first version of Node.js to include a patch to
				// libuv that enables 256 color output on Windows. Anything earlier and it
				// won't work. However, here we target Node.js 8 at minimum as it is an LTS
				// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
				// release that supports 256 colors. Windows 10 build 14931 is the first release
				// that supports 16m/TrueColor.
				const osRelease = os.release().split('.');
				if (
					Number(process.versions.node.split('.')[0]) >= 8 &&
					Number(osRelease[0]) >= 10 &&
					Number(osRelease[2]) >= 10586
				) {
					return Number(osRelease[2]) >= 14931 ? 3 : 2;
				}

				return 1;
			}

			if ('CI' in env) {
				if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
					return 1;
				}

				return min;
			}

			if ('TEAMCITY_VERSION' in env) {
				return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
			}

			if (env.COLORTERM === 'truecolor') {
				return 3;
			}

			if ('TERM_PROGRAM' in env) {
				const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

				switch (env.TERM_PROGRAM) {
					case 'iTerm.app':
						return version >= 3 ? 3 : 2;
					case 'Apple_Terminal':
						return 2;
					// No default
				}
			}

			if (/-256(color)?$/i.test(env.TERM)) {
				return 2;
			}

			if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
				return 1;
			}

			if ('COLORTERM' in env) {
				return 1;
			}

			if (env.TERM === 'dumb') {
				return min;
			}

			return min;
		}

		function getSupportLevel(stream) {
			const level = supportsColor(stream);
			return translateLevel(level);
		}

		supportsColor_1 = {
			supportsColor: getSupportLevel,
			stdout: getSupportLevel(process.stdout),
			stderr: getSupportLevel(process.stderr)
		};
		return supportsColor_1;
	}

	/**
	 * Module dependencies.
	 */

	var hasRequiredNode;

	function requireNode () {
		if (hasRequiredNode) return node.exports;
		hasRequiredNode = 1;
		(function (module, exports) {
			const tty = require$$0$2;
			const util = require$$1;

			/**
			 * This is the Node.js implementation of `debug()`.
			 */

			exports.init = init;
			exports.log = log;
			exports.formatArgs = formatArgs;
			exports.save = save;
			exports.load = load;
			exports.useColors = useColors;
			exports.destroy = util.deprecate(
				() => {},
				'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
			);

			/**
			 * Colors.
			 */

			exports.colors = [6, 2, 3, 4, 5, 1];

			try {
				// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
				// eslint-disable-next-line import/no-extraneous-dependencies
				const supportsColor = requireSupportsColor();

				if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
					exports.colors = [
						20,
						21,
						26,
						27,
						32,
						33,
						38,
						39,
						40,
						41,
						42,
						43,
						44,
						45,
						56,
						57,
						62,
						63,
						68,
						69,
						74,
						75,
						76,
						77,
						78,
						79,
						80,
						81,
						92,
						93,
						98,
						99,
						112,
						113,
						128,
						129,
						134,
						135,
						148,
						149,
						160,
						161,
						162,
						163,
						164,
						165,
						166,
						167,
						168,
						169,
						170,
						171,
						172,
						173,
						178,
						179,
						184,
						185,
						196,
						197,
						198,
						199,
						200,
						201,
						202,
						203,
						204,
						205,
						206,
						207,
						208,
						209,
						214,
						215,
						220,
						221
					];
				}
			} catch (error) {
				// Swallow - we only care if `supports-color` is available; it doesn't have to be.
			}

			/**
			 * Build up the default `inspectOpts` object from the environment variables.
			 *
			 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
			 */

			exports.inspectOpts = Object.keys(process.env).filter(key => {
				return /^debug_/i.test(key);
			}).reduce((obj, key) => {
				// Camel-case
				const prop = key
					.substring(6)
					.toLowerCase()
					.replace(/_([a-z])/g, (_, k) => {
						return k.toUpperCase();
					});

				// Coerce string value into JS value
				let val = process.env[key];
				if (/^(yes|on|true|enabled)$/i.test(val)) {
					val = true;
				} else if (/^(no|off|false|disabled)$/i.test(val)) {
					val = false;
				} else if (val === 'null') {
					val = null;
				} else {
					val = Number(val);
				}

				obj[prop] = val;
				return obj;
			}, {});

			/**
			 * Is stdout a TTY? Colored output is enabled when `true`.
			 */

			function useColors() {
				return 'colors' in exports.inspectOpts ?
					Boolean(exports.inspectOpts.colors) :
					tty.isatty(process.stderr.fd);
			}

			/**
			 * Adds ANSI color escape codes if enabled.
			 *
			 * @api public
			 */

			function formatArgs(args) {
				const {namespace: name, useColors} = this;

				if (useColors) {
					const c = this.color;
					const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
					const prefix = `  ${colorCode};1m${name} \u001B[0m`;

					args[0] = prefix + args[0].split('\n').join('\n' + prefix);
					args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
				} else {
					args[0] = getDate() + name + ' ' + args[0];
				}
			}

			function getDate() {
				if (exports.inspectOpts.hideDate) {
					return '';
				}
				return new Date().toISOString() + ' ';
			}

			/**
			 * Invokes `util.format()` with the specified arguments and writes to stderr.
			 */

			function log(...args) {
				return process.stderr.write(util.format(...args) + '\n');
			}

			/**
			 * Save `namespaces`.
			 *
			 * @param {String} namespaces
			 * @api private
			 */
			function save(namespaces) {
				if (namespaces) {
					process.env.DEBUG = namespaces;
				} else {
					// If you set a process.env field to null or undefined, it gets cast to the
					// string 'null' or 'undefined'. Just delete instead.
					delete process.env.DEBUG;
				}
			}

			/**
			 * Load `namespaces`.
			 *
			 * @return {String} returns the previously persisted debug modes
			 * @api private
			 */

			function load() {
				return process.env.DEBUG;
			}

			/**
			 * Init logic for `debug` instances.
			 *
			 * Create a new `inspectOpts` object in case `useColors` is set
			 * differently for a particular `debug` instance.
			 */

			function init(debug) {
				debug.inspectOpts = {};

				const keys = Object.keys(exports.inspectOpts);
				for (let i = 0; i < keys.length; i++) {
					debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
				}
			}

			module.exports = requireCommon()(exports);

			const {formatters} = module.exports;

			/**
			 * Map %o to `util.inspect()`, all on a single line.
			 */

			formatters.o = function (v) {
				this.inspectOpts.colors = this.useColors;
				return util.inspect(v, this.inspectOpts)
					.split('\n')
					.map(str => str.trim())
					.join(' ');
			};

			/**
			 * Map %O to `util.inspect()`, allowing multiple lines if needed.
			 */

			formatters.O = function (v) {
				this.inspectOpts.colors = this.useColors;
				return util.inspect(v, this.inspectOpts);
			};
	} (node, node.exports));
		return node.exports;
	}

	/**
	 * Detect Electron renderer / nwjs process, which is node, but we should
	 * treat as a browser.
	 */

	(function (module) {
		if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
			module.exports = requireBrowser();
		} else {
			module.exports = requireNode();
		}
	} (src));

	var __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(logging, "__esModule", { value: true });
	logging.createModuleLogger = logging.createProjectLogger = void 0;
	const debug_1 = __importDefault$6(src.exports);
	const globalLogger = (0, debug_1.default)('metamask');
	/**
	 * Creates a logger via the `debug` library whose log messages will be tagged
	 * using the name of your project. By default, such messages will be
	 * suppressed, but you can reveal them by setting the `DEBUG` environment
	 * variable to `metamask:<projectName>`. You can also set this variable to
	 * `metamask:*` if you want to see log messages from all MetaMask projects that
	 * are also using this function to create their loggers.
	 *
	 * @param projectName - The name of your project. This should be the name of
	 * your NPM package if you're developing one.
	 * @returns An instance of `debug`.
	 */
	function createProjectLogger(projectName) {
	    return globalLogger.extend(projectName);
	}
	logging.createProjectLogger = createProjectLogger;
	/**
	 * Creates a logger via the `debug` library which is derived from the logger for
	 * the whole project whose log messages will be tagged using the name of your
	 * module. By default, such messages will be suppressed, but you can reveal them
	 * by setting the `DEBUG` environment variable to
	 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
	 * `metamask:<projectName>:*` if you want to see log messages from the project,
	 * or `metamask:*` if you want to see log messages from all MetaMask projects.
	 *
	 * @param projectLogger - The logger created via {@link createProjectLogger}.
	 * @param moduleName - The name of your module. You could use the name of the
	 * file where you're using this logger or some other name.
	 * @returns An instance of `debug`.
	 */
	function createModuleLogger(projectLogger, moduleName) {
	    return projectLogger.extend(moduleName);
	}
	logging.createModuleLogger = createModuleLogger;

	var number = {};

	Object.defineProperty(number, "__esModule", { value: true });
	number.hexToBigInt = number.hexToNumber = number.bigIntToHex = number.numberToHex = void 0;
	const hex_1 = hex;
	const assert_1 = assert$3;
	/**
	 * Convert a number to a hexadecimal string. This verifies that the number is a
	 * non-negative safe integer.
	 *
	 * To convert a `bigint` to a hexadecimal string instead, use
	 * {@link bigIntToHex}.
	 *
	 * @example
	 * ```typescript
	 * numberToHex(0); // '0x0'
	 * numberToHex(1); // '0x1'
	 * numberToHex(16); // '0x10'
	 * ```
	 * @param value - The number to convert to a hexadecimal string.
	 * @returns The hexadecimal string, with the "0x"-prefix.
	 * @throws If the number is not a non-negative safe integer.
	 */
	const numberToHex = (value) => {
	    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
	    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
	    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
	    return (0, hex_1.add0x)(value.toString(16));
	};
	number.numberToHex = numberToHex;
	/**
	 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
	 * is a non-negative integer.
	 *
	 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
	 *
	 * @example
	 * ```typescript
	 * bigIntToHex(0n); // '0x0'
	 * bigIntToHex(1n); // '0x1'
	 * bigIntToHex(16n); // '0x10'
	 * ```
	 * @param value - The `bigint` to convert to a hexadecimal string.
	 * @returns The hexadecimal string, with the "0x"-prefix.
	 * @throws If the `bigint` is not a non-negative integer.
	 */
	const bigIntToHex = (value) => {
	    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
	    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
	    return (0, hex_1.add0x)(value.toString(16));
	};
	number.bigIntToHex = bigIntToHex;
	/**
	 * Convert a hexadecimal string to a number. This verifies that the string is a
	 * valid hex string, and that the resulting number is a safe integer. Both
	 * "0x"-prefixed and unprefixed strings are supported.
	 *
	 * To convert a hexadecimal string to a `bigint` instead, use
	 * {@link hexToBigInt}.
	 *
	 * @example
	 * ```typescript
	 * hexToNumber('0x0'); // 0
	 * hexToNumber('0x1'); // 1
	 * hexToNumber('0x10'); // 16
	 * ```
	 * @param value - The hexadecimal string to convert to a number.
	 * @returns The number.
	 * @throws If the value is not a valid hexadecimal string, or if the resulting
	 * number is not a safe integer.
	 */
	const hexToNumber = (value) => {
	    (0, hex_1.assertIsHexString)(value);
	    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
	    // not. Using this is slightly faster than `Number(add0x(value))`.
	    const numberValue = parseInt(value, 16);
	    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
	    return numberValue;
	};
	number.hexToNumber = hexToNumber;
	/**
	 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
	 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
	 *
	 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
	 *
	 * @example
	 * ```typescript
	 * hexToBigInt('0x0'); // 0n
	 * hexToBigInt('0x1'); // 1n
	 * hexToBigInt('0x10'); // 16n
	 * ```
	 * @param value - The hexadecimal string to convert to a `bigint`.
	 * @returns The `bigint`.
	 * @throws If the value is not a valid hexadecimal string.
	 */
	const hexToBigInt = (value) => {
	    (0, hex_1.assertIsHexString)(value);
	    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
	    return BigInt((0, hex_1.add0x)(value));
	};
	number.hexToBigInt = hexToBigInt;

	var time = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
		(function (Duration) {
		    /**
		     * A millisecond.
		     */
		    Duration[Duration["Millisecond"] = 1] = "Millisecond";
		    /**
		     * A second, in milliseconds.
		     */
		    Duration[Duration["Second"] = 1000] = "Second";
		    /**
		     * A minute, in milliseconds.
		     */
		    Duration[Duration["Minute"] = 60000] = "Minute";
		    /**
		     * An hour, in milliseconds.
		     */
		    Duration[Duration["Hour"] = 3600000] = "Hour";
		    /**
		     * A day, in milliseconds.
		     */
		    Duration[Duration["Day"] = 86400000] = "Day";
		    /**
		     * A week, in milliseconds.
		     */
		    Duration[Duration["Week"] = 604800000] = "Week";
		    /**
		     * A year, in milliseconds.
		     */
		    Duration[Duration["Year"] = 31536000000] = "Year";
		})(exports.Duration || (exports.Duration = {}));
		const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
		const assertIsNonNegativeInteger = (number, name) => {
		    if (!isNonNegativeInteger(number)) {
		        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
		    }
		};
		/**
		 * Calculates the millisecond value of the specified number of units of time.
		 *
		 * @param count - The number of units of time.
		 * @param duration - The unit of time to count.
		 * @returns The count multiplied by the specified duration.
		 */
		function inMilliseconds(count, duration) {
		    assertIsNonNegativeInteger(count, 'count');
		    return count * duration;
		}
		exports.inMilliseconds = inMilliseconds;
		/**
		 * Gets the milliseconds since a particular Unix epoch timestamp.
		 *
		 * @param timestamp - A Unix millisecond timestamp.
		 * @returns The number of milliseconds elapsed since the specified timestamp.
		 */
		function timeSince(timestamp) {
		    assertIsNonNegativeInteger(timestamp, 'timestamp');
		    return Date.now() - timestamp;
		}
		exports.timeSince = timeSince;
		
	} (time));

	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(assert$3, exports);
		__exportStar(bytes, exports);
		__exportStar(coercers, exports);
		__exportStar(collections, exports);
		__exportStar(hex, exports);
		__exportStar(json$1, exports);
		__exportStar(logging, exports);
		__exportStar(misc, exports);
		__exportStar(number, exports);
		__exportStar(time, exports);
		
	} (dist$1));

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createModuleLogger = exports.projectLogger = void 0;
		const utils_1 = dist$1;
		Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
		exports.projectLogger = utils_1.createProjectLogger('eth-json-rpc-middleware');
		
	} (loggingUtils));

	var cache = {};

	var jsonify = {};

	var parse;
	var hasRequiredParse;

	function requireParse () {
		if (hasRequiredParse) return parse;
		hasRequiredParse = 1;
		var at, // The index of the current character
		    ch, // The current character
		    escapee = {
		        '"':  '"',
		        '\\': '\\',
		        '/':  '/',
		        b:    '\b',
		        f:    '\f',
		        n:    '\n',
		        r:    '\r',
		        t:    '\t'
		    },
		    text,

		    error = function (m) {
		        // Call error when something is wrong.
		        throw {
		            name:    'SyntaxError',
		            message: m,
		            at:      at,
		            text:    text
		        };
		    },
		    
		    next = function (c) {
		        // If a c parameter is provided, verify that it matches the current character.
		        if (c && c !== ch) {
		            error("Expected '" + c + "' instead of '" + ch + "'");
		        }
		        
		        // Get the next character. When there are no more characters,
		        // return the empty string.
		        
		        ch = text.charAt(at);
		        at += 1;
		        return ch;
		    },
		    
		    number = function () {
		        // Parse a number value.
		        var number,
		            string = '';
		        
		        if (ch === '-') {
		            string = '-';
		            next('-');
		        }
		        while (ch >= '0' && ch <= '9') {
		            string += ch;
		            next();
		        }
		        if (ch === '.') {
		            string += '.';
		            while (next() && ch >= '0' && ch <= '9') {
		                string += ch;
		            }
		        }
		        if (ch === 'e' || ch === 'E') {
		            string += ch;
		            next();
		            if (ch === '-' || ch === '+') {
		                string += ch;
		                next();
		            }
		            while (ch >= '0' && ch <= '9') {
		                string += ch;
		                next();
		            }
		        }
		        number = +string;
		        if (!isFinite(number)) {
		            error("Bad number");
		        } else {
		            return number;
		        }
		    },
		    
		    string = function () {
		        // Parse a string value.
		        var hex,
		            i,
		            string = '',
		            uffff;
		        
		        // When parsing for string values, we must look for " and \ characters.
		        if (ch === '"') {
		            while (next()) {
		                if (ch === '"') {
		                    next();
		                    return string;
		                } else if (ch === '\\') {
		                    next();
		                    if (ch === 'u') {
		                        uffff = 0;
		                        for (i = 0; i < 4; i += 1) {
		                            hex = parseInt(next(), 16);
		                            if (!isFinite(hex)) {
		                                break;
		                            }
		                            uffff = uffff * 16 + hex;
		                        }
		                        string += String.fromCharCode(uffff);
		                    } else if (typeof escapee[ch] === 'string') {
		                        string += escapee[ch];
		                    } else {
		                        break;
		                    }
		                } else {
		                    string += ch;
		                }
		            }
		        }
		        error("Bad string");
		    },

		    white = function () {

		// Skip whitespace.

		        while (ch && ch <= ' ') {
		            next();
		        }
		    },

		    word = function () {

		// true, false, or null.

		        switch (ch) {
		        case 't':
		            next('t');
		            next('r');
		            next('u');
		            next('e');
		            return true;
		        case 'f':
		            next('f');
		            next('a');
		            next('l');
		            next('s');
		            next('e');
		            return false;
		        case 'n':
		            next('n');
		            next('u');
		            next('l');
		            next('l');
		            return null;
		        }
		        error("Unexpected '" + ch + "'");
		    },

		    value,  // Place holder for the value function.

		    array = function () {

		// Parse an array value.

		        var array = [];

		        if (ch === '[') {
		            next('[');
		            white();
		            if (ch === ']') {
		                next(']');
		                return array;   // empty array
		            }
		            while (ch) {
		                array.push(value());
		                white();
		                if (ch === ']') {
		                    next(']');
		                    return array;
		                }
		                next(',');
		                white();
		            }
		        }
		        error("Bad array");
		    },

		    object = function () {

		// Parse an object value.

		        var key,
		            object = {};

		        if (ch === '{') {
		            next('{');
		            white();
		            if (ch === '}') {
		                next('}');
		                return object;   // empty object
		            }
		            while (ch) {
		                key = string();
		                white();
		                next(':');
		                if (Object.hasOwnProperty.call(object, key)) {
		                    error('Duplicate key "' + key + '"');
		                }
		                object[key] = value();
		                white();
		                if (ch === '}') {
		                    next('}');
		                    return object;
		                }
		                next(',');
		                white();
		            }
		        }
		        error("Bad object");
		    };

		value = function () {

		// Parse a JSON value. It could be an object, an array, a string, a number,
		// or a word.

		    white();
		    switch (ch) {
		    case '{':
		        return object();
		    case '[':
		        return array();
		    case '"':
		        return string();
		    case '-':
		        return number();
		    default:
		        return ch >= '0' && ch <= '9' ? number() : word();
		    }
		};

		// Return the json_parse function. It will have access to all of the above
		// functions and variables.

		parse = function (source, reviver) {
		    var result;
		    
		    text = source;
		    at = 0;
		    ch = ' ';
		    result = value();
		    white();
		    if (ch) {
		        error("Syntax error");
		    }

		    // If there is a reviver function, we recursively walk the new structure,
		    // passing each name/value pair to the reviver function for possible
		    // transformation, starting with a temporary root object that holds the result
		    // in an empty key. If there is not a reviver function, we simply return the
		    // result.

		    return typeof reviver === 'function' ? (function walk(holder, key) {
		        var k, v, value = holder[key];
		        if (value && typeof value === 'object') {
		            for (k in value) {
		                if (Object.prototype.hasOwnProperty.call(value, k)) {
		                    v = walk(value, k);
		                    if (v !== undefined) {
		                        value[k] = v;
		                    } else {
		                        delete value[k];
		                    }
		                }
		            }
		        }
		        return reviver.call(holder, key, value);
		    }({'': result}, '')) : result;
		};
		return parse;
	}

	var stringify;
	var hasRequiredStringify;

	function requireStringify () {
		if (hasRequiredStringify) return stringify;
		hasRequiredStringify = 1;
		var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
		    gap,
		    indent,
		    meta = {    // table of character substitutions
		        '\b': '\\b',
		        '\t': '\\t',
		        '\n': '\\n',
		        '\f': '\\f',
		        '\r': '\\r',
		        '"' : '\\"',
		        '\\': '\\\\'
		    },
		    rep;

		function quote(string) {
		    // If the string contains no control characters, no quote characters, and no
		    // backslash characters, then we can safely slap some quotes around it.
		    // Otherwise we must also replace the offending characters with safe escape
		    // sequences.
		    
		    escapable.lastIndex = 0;
		    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
		        var c = meta[a];
		        return typeof c === 'string' ? c :
		            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
		    }) + '"' : '"' + string + '"';
		}

		function str(key, holder) {
		    // Produce a string from holder[key].
		    var i,          // The loop counter.
		        k,          // The member key.
		        v,          // The member value.
		        length,
		        mind = gap,
		        partial,
		        value = holder[key];
		    
		    // If the value has a toJSON method, call it to obtain a replacement value.
		    if (value && typeof value === 'object' &&
		            typeof value.toJSON === 'function') {
		        value = value.toJSON(key);
		    }
		    
		    // If we were called with a replacer function, then call the replacer to
		    // obtain a replacement value.
		    if (typeof rep === 'function') {
		        value = rep.call(holder, key, value);
		    }
		    
		    // What happens next depends on the value's type.
		    switch (typeof value) {
		        case 'string':
		            return quote(value);
		        
		        case 'number':
		            // JSON numbers must be finite. Encode non-finite numbers as null.
		            return isFinite(value) ? String(value) : 'null';
		        
		        case 'boolean':
		        case 'null':
		            // If the value is a boolean or null, convert it to a string. Note:
		            // typeof null does not produce 'null'. The case is included here in
		            // the remote chance that this gets fixed someday.
		            return String(value);
		            
		        case 'object':
		            if (!value) return 'null';
		            gap += indent;
		            partial = [];
		            
		            // Array.isArray
		            if (Object.prototype.toString.apply(value) === '[object Array]') {
		                length = value.length;
		                for (i = 0; i < length; i += 1) {
		                    partial[i] = str(i, value) || 'null';
		                }
		                
		                // Join all of the elements together, separated with commas, and
		                // wrap them in brackets.
		                v = partial.length === 0 ? '[]' : gap ?
		                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
		                    '[' + partial.join(',') + ']';
		                gap = mind;
		                return v;
		            }
		            
		            // If the replacer is an array, use it to select the members to be
		            // stringified.
		            if (rep && typeof rep === 'object') {
		                length = rep.length;
		                for (i = 0; i < length; i += 1) {
		                    k = rep[i];
		                    if (typeof k === 'string') {
		                        v = str(k, value);
		                        if (v) {
		                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
		                        }
		                    }
		                }
		            }
		            else {
		                // Otherwise, iterate through all of the keys in the object.
		                for (k in value) {
		                    if (Object.prototype.hasOwnProperty.call(value, k)) {
		                        v = str(k, value);
		                        if (v) {
		                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
		                        }
		                    }
		                }
		            }
		            
		        // Join all of the member texts together, separated with commas,
		        // and wrap them in braces.

		        v = partial.length === 0 ? '{}' : gap ?
		            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
		            '{' + partial.join(',') + '}';
		        gap = mind;
		        return v;
		    }
		}

		stringify = function (value, replacer, space) {
		    var i;
		    gap = '';
		    indent = '';
		    
		    // If the space parameter is a number, make an indent string containing that
		    // many spaces.
		    if (typeof space === 'number') {
		        for (i = 0; i < space; i += 1) {
		            indent += ' ';
		        }
		    }
		    // If the space parameter is a string, it will be used as the indent string.
		    else if (typeof space === 'string') {
		        indent = space;
		    }

		    // If there is a replacer, it must be a function or an array.
		    // Otherwise, throw an error.
		    rep = replacer;
		    if (replacer && typeof replacer !== 'function'
		    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
		        throw new Error('JSON.stringify');
		    }
		    
		    // Make a fake root object containing our value under the key of ''.
		    // Return the result of stringifying the value.
		    return str('', {'': value});
		};
		return stringify;
	}

	var hasRequiredJsonify;

	function requireJsonify () {
		if (hasRequiredJsonify) return jsonify;
		hasRequiredJsonify = 1;
		jsonify.parse = requireParse();
		jsonify.stringify = requireStringify();
		return jsonify;
	}

	var json = typeof JSON !== 'undefined' ? JSON : requireJsonify();

	var jsonStableStringify = function (obj, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var space = opts.space || '';
	    if (typeof space === 'number') space = Array(space+1).join(' ');
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var replacer = opts.replacer || function(key, value) { return value; };

	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);

	    var seen = [];
	    return (function stringify (parent, key, node, level) {
	        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
	        var colonSeparator = space ? ': ' : ':';

	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }

	        node = replacer.call(parent, key, node);

	        if (node === undefined) {
	            return;
	        }
	        if (typeof node !== 'object' || node === null) {
	            return json.stringify(node);
	        }
	        if (isArray$1(node)) {
	            var out = [];
	            for (var i = 0; i < node.length; i++) {
	                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
	                out.push(indent + space + item);
	            }
	            return '[' + out.join(',') + indent + ']';
	        }
	        else {
	            if (seen.indexOf(node) !== -1) {
	                if (cycles) return json.stringify('__cycle__');
	                throw new TypeError('Converting circular structure to JSON');
	            }
	            else seen.push(node);

	            var keys = objectKeys(node).sort(cmp && cmp(node));
	            var out = [];
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                var value = stringify(node, key, node[key], level+1);

	                if(!value) continue;

	                var keyValue = json.stringify(key)
	                    + colonSeparator
	                    + value;
	                out.push(indent + space + keyValue);
	            }
	            seen.splice(seen.indexOf(node), 1);
	            return '{' + out.join(',') + indent + '}';
	        }
	    })({ '': obj }, '', obj, 0);
	};

	var isArray$1 = Array.isArray || function (x) {
	    return {}.toString.call(x) === '[object Array]';
	};

	var objectKeys = Object.keys || function (obj) {
	    var has = Object.prototype.hasOwnProperty || function () { return true };
	    var keys = [];
	    for (var key in obj) {
	        if (has.call(obj, key)) keys.push(key);
	    }
	    return keys;
	};

	var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(cache, "__esModule", { value: true });
	cache.cacheTypeForPayload = cache.blockTagParamIndex = cache.paramsWithoutBlockTag = cache.blockTagForPayload = cache.canCache = cache.cacheIdentifierForPayload = void 0;
	const json_stable_stringify_1 = __importDefault$5(jsonStableStringify);
	function cacheIdentifierForPayload(payload, skipBlockRef) {
	    var _a;
	    const simpleParams = skipBlockRef
	        ? paramsWithoutBlockTag(payload)
	        : (_a = payload.params) !== null && _a !== void 0 ? _a : [];
	    if (canCache(payload)) {
	        return `${payload.method}:${json_stable_stringify_1.default(simpleParams)}`;
	    }
	    return null;
	}
	cache.cacheIdentifierForPayload = cacheIdentifierForPayload;
	function canCache(payload) {
	    return cacheTypeForPayload(payload) !== 'never';
	}
	cache.canCache = canCache;
	function blockTagForPayload(payload) {
	    if (!payload.params) {
	        return undefined;
	    }
	    const index = blockTagParamIndex(payload);
	    // Block tag param not passed.
	    if (index === undefined || index >= payload.params.length) {
	        return undefined;
	    }
	    return payload.params[index];
	}
	cache.blockTagForPayload = blockTagForPayload;
	function paramsWithoutBlockTag(payload) {
	    if (!payload.params) {
	        return [];
	    }
	    const index = blockTagParamIndex(payload);
	    // Block tag param not passed.
	    if (index === undefined || index >= payload.params.length) {
	        return payload.params;
	    }
	    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
	    if (payload.method === 'eth_getBlockByNumber') {
	        return payload.params.slice(1);
	    }
	    return payload.params.slice(0, index);
	}
	cache.paramsWithoutBlockTag = paramsWithoutBlockTag;
	function blockTagParamIndex(payload) {
	    switch (payload.method) {
	        // blockTag is at index 2
	        case 'eth_getStorageAt':
	            return 2;
	        // blockTag is at index 1
	        case 'eth_getBalance':
	        case 'eth_getCode':
	        case 'eth_getTransactionCount':
	        case 'eth_call':
	            return 1;
	        // blockTag is at index 0
	        case 'eth_getBlockByNumber':
	            return 0;
	        // there is no blockTag
	        default:
	            return undefined;
	    }
	}
	cache.blockTagParamIndex = blockTagParamIndex;
	function cacheTypeForPayload(payload) {
	    switch (payload.method) {
	        // cache permanently
	        case 'web3_clientVersion':
	        case 'web3_sha3':
	        case 'eth_protocolVersion':
	        case 'eth_getBlockTransactionCountByHash':
	        case 'eth_getUncleCountByBlockHash':
	        case 'eth_getCode':
	        case 'eth_getBlockByHash':
	        case 'eth_getTransactionByHash':
	        case 'eth_getTransactionByBlockHashAndIndex':
	        case 'eth_getTransactionReceipt':
	        case 'eth_getUncleByBlockHashAndIndex':
	        case 'eth_getCompilers':
	        case 'eth_compileLLL':
	        case 'eth_compileSolidity':
	        case 'eth_compileSerpent':
	        case 'shh_version':
	        case 'test_permaCache':
	            return 'perma';
	        // cache until fork
	        case 'eth_getBlockByNumber':
	        case 'eth_getBlockTransactionCountByNumber':
	        case 'eth_getUncleCountByBlockNumber':
	        case 'eth_getTransactionByBlockNumberAndIndex':
	        case 'eth_getUncleByBlockNumberAndIndex':
	        case 'test_forkCache':
	            return 'fork';
	        // cache for block
	        case 'eth_gasPrice':
	        case 'eth_blockNumber':
	        case 'eth_getBalance':
	        case 'eth_getStorageAt':
	        case 'eth_getTransactionCount':
	        case 'eth_call':
	        case 'eth_estimateGas':
	        case 'eth_getFilterLogs':
	        case 'eth_getLogs':
	        case 'test_blockCache':
	            return 'block';
	        // never cache
	        default:
	            return 'never';
	    }
	}
	cache.cacheTypeForPayload = cacheTypeForPayload;

	var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(inflightCache, "__esModule", { value: true });
	var createInflightCacheMiddleware_1 = inflightCache.createInflightCacheMiddleware = void 0;
	const clone_1 = __importDefault$4(clone.exports);
	const json_rpc_engine_1$1 = dist$2;
	const logging_utils_1$1 = loggingUtils;
	const cache_1$1 = cache;
	const log$2 = logging_utils_1$1.createModuleLogger(logging_utils_1$1.projectLogger, 'inflight-cache');
	function createInflightCacheMiddleware() {
	    const inflightRequests = {};
	    return json_rpc_engine_1$1.createAsyncMiddleware(async (req, res, next) => {
	        // allow cach to be skipped if so specified
	        if (req.skipCache) {
	            return next();
	        }
	        // get cacheId, if cacheable
	        const cacheId = cache_1$1.cacheIdentifierForPayload(req);
	        // if not cacheable, skip
	        if (!cacheId) {
	            log$2('Request is not cacheable, proceeding. req = %o', req);
	            return next();
	        }
	        // check for matching requests
	        let activeRequestHandlers = inflightRequests[cacheId];
	        // if found, wait for the active request to be handled
	        if (activeRequestHandlers) {
	            // setup the response listener and wait for it to be called
	            // it will handle copying the result and request fields
	            log$2('Running %i handler(s) for request %o', activeRequestHandlers.length, req);
	            await createActiveRequestHandler(res, activeRequestHandlers);
	            return undefined;
	        }
	        // setup response handler array for subsequent requests
	        activeRequestHandlers = [];
	        inflightRequests[cacheId] = activeRequestHandlers;
	        // allow request to be handled normally
	        log$2('Carrying original request forward %o', req);
	        // eslint-disable-next-line node/callback-return
	        await next();
	        // clear inflight requests
	        delete inflightRequests[cacheId];
	        // schedule activeRequestHandlers to be handled
	        log$2('Running %i collected handler(s) for request %o', activeRequestHandlers.length, req);
	        handleActiveRequest(res, activeRequestHandlers);
	        // complete
	        return undefined;
	    });
	    function createActiveRequestHandler(res, activeRequestHandlers) {
	        const { resolve, promise } = deferredPromise();
	        activeRequestHandlers.push((handledRes) => {
	            // append a copy of the result and error to the response
	            res.result = clone_1.default(handledRes.result);
	            res.error = clone_1.default(handledRes.error);
	            resolve();
	        });
	        return promise;
	    }
	    function handleActiveRequest(res, activeRequestHandlers) {
	        // use setTimeout so we can resolve our original request first
	        setTimeout(() => {
	            activeRequestHandlers.forEach((handler) => {
	                try {
	                    handler(res);
	                }
	                catch (err) {
	                    // catch error so all requests are handled correctly
	                    console.error(err);
	                }
	            });
	        });
	    }
	}
	createInflightCacheMiddleware_1 = inflightCache.createInflightCacheMiddleware = createInflightCacheMiddleware;
	function deferredPromise() {
	    let resolve;
	    const promise = new Promise((_resolve) => {
	        resolve = _resolve;
	    });
	    return { resolve, promise };
	}

	var blockCache = {};

	Object.defineProperty(blockCache, "__esModule", { value: true });
	var createBlockCacheMiddleware_1 = blockCache.createBlockCacheMiddleware = void 0;
	const json_rpc_engine_1 = dist$2;
	const logging_utils_1 = loggingUtils;
	const cache_1 = cache;
	const log$1 = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-cache');
	// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
	const emptyValues = [undefined, null, '\u003cnil\u003e'];
	//
	// Cache Strategies
	//
	class BlockCacheStrategy {
	    constructor() {
	        this.cache = {};
	    }
	    getBlockCacheForPayload(_payload, blockNumberHex) {
	        const blockNumber = Number.parseInt(blockNumberHex, 16);
	        let blockCache = this.cache[blockNumber];
	        // create new cache if necesary
	        if (!blockCache) {
	            const newCache = {};
	            this.cache[blockNumber] = newCache;
	            blockCache = newCache;
	        }
	        return blockCache;
	    }
	    async get(payload, requestedBlockNumber) {
	        // lookup block cache
	        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
	        // lookup payload in block cache
	        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
	        return identifier ? blockCache[identifier] : undefined;
	    }
	    async set(payload, requestedBlockNumber, result) {
	        // check if we can cached this result
	        const canCacheResult = this.canCacheResult(payload, result);
	        if (!canCacheResult) {
	            return;
	        }
	        // set the value in the cache
	        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
	        if (!identifier) {
	            return;
	        }
	        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
	        blockCache[identifier] = result;
	    }
	    canCacheRequest(payload) {
	        // check request method
	        if (!cache_1.canCache(payload)) {
	            return false;
	        }
	        // check blockTag
	        const blockTag = cache_1.blockTagForPayload(payload);
	        if (blockTag === 'pending') {
	            return false;
	        }
	        // can be cached
	        return true;
	    }
	    canCacheResult(payload, result) {
	        // never cache empty values (e.g. undefined)
	        if (emptyValues.includes(result)) {
	            return false;
	        }
	        // check if transactions have block reference before caching
	        if (payload.method &&
	            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
	            if (!result ||
	                !result.blockHash ||
	                result.blockHash ===
	                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
	                return false;
	            }
	        }
	        // otherwise true
	        return true;
	    }
	    // removes all block caches with block number lower than `oldBlockHex`
	    clearBefore(oldBlockHex) {
	        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
	        // clear old caches
	        Object.keys(this.cache)
	            .map(Number)
	            .filter((num) => num < oldBlockNumber)
	            .forEach((num) => delete this.cache[num]);
	    }
	}
	function createBlockCacheMiddleware$1({ blockTracker, } = {}) {
	    // validate options
	    if (!blockTracker) {
	        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
	    }
	    // create caching strategies
	    const blockCache = new BlockCacheStrategy();
	    const strategies = {
	        perma: blockCache,
	        block: blockCache,
	        fork: blockCache,
	    };
	    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
	        // allow cach to be skipped if so specified
	        if (req.skipCache) {
	            return next();
	        }
	        // check type and matching strategy
	        const type = cache_1.cacheTypeForPayload(req);
	        const strategy = strategies[type];
	        // If there's no strategy in place, pass it down the chain.
	        if (!strategy) {
	            return next();
	        }
	        // If the strategy can't cache this request, ignore it.
	        if (!strategy.canCacheRequest(req)) {
	            return next();
	        }
	        // get block reference (number or keyword)
	        let blockTag = cache_1.blockTagForPayload(req);
	        if (!blockTag) {
	            blockTag = 'latest';
	        }
	        log$1('blockTag = %o, req = %o', blockTag, req);
	        // get exact block number
	        let requestedBlockNumber;
	        if (blockTag === 'earliest') {
	            // this just exists for symmetry with "latest"
	            requestedBlockNumber = '0x00';
	        }
	        else if (blockTag === 'latest') {
	            // fetch latest block number
	            log$1('Fetching latest block number to determine cache key');
	            const latestBlockNumber = await blockTracker.getLatestBlock();
	            // clear all cache before latest block
	            log$1('Clearing values stored under block numbers before %o', latestBlockNumber);
	            blockCache.clearBefore(latestBlockNumber);
	            requestedBlockNumber = latestBlockNumber;
	        }
	        else {
	            // We have a hex number
	            requestedBlockNumber = blockTag;
	        }
	        // end on a hit, continue on a miss
	        const cacheResult = await strategy.get(req, requestedBlockNumber);
	        if (cacheResult === undefined) {
	            // cache miss
	            // wait for other middleware to handle request
	            log$1('No cache stored under block number %o, carrying request forward', requestedBlockNumber);
	            // eslint-disable-next-line node/callback-return
	            await next();
	            // add result to cache
	            // it's safe to cast res.result as Block, due to runtime type checks
	            // performed when strategy.set is called
	            log$1('Populating cache with', res);
	            await strategy.set(req, requestedBlockNumber, res.result);
	        }
	        else {
	            // fill in result from cache
	            log$1('Cache hit, reusing cache result stored under block number %o', requestedBlockNumber);
	            res.result = cacheResult;
	        }
	        return undefined;
	    });
	}
	createBlockCacheMiddleware_1 = blockCache.createBlockCacheMiddleware = createBlockCacheMiddleware$1;

	var dist = {};

	var BaseBlockTracker$1 = {};

	var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(BaseBlockTracker$1, "__esModule", { value: true });
	BaseBlockTracker$1.BaseBlockTracker = void 0;
	const safe_event_emitter_1 = __importDefault$3(safeEventEmitter);
	const sec$1 = 1000;
	const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
	const blockTrackerEvents = ['sync', 'latest'];
	class BaseBlockTracker extends safe_event_emitter_1.default {
	    constructor(opts = {}) {
	        super();
	        // config
	        this._blockResetDuration = opts.blockResetDuration || 20 * sec$1;
	        // state
	        this._currentBlock = null;
	        this._isRunning = false;
	        // bind functions for internal use
	        this._onNewListener = this._onNewListener.bind(this);
	        this._onRemoveListener = this._onRemoveListener.bind(this);
	        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
	        // listen for handler changes
	        this._setupInternalEvents();
	    }
	    isRunning() {
	        return this._isRunning;
	    }
	    getCurrentBlock() {
	        return this._currentBlock;
	    }
	    async getLatestBlock() {
	        // return if available
	        if (this._currentBlock) {
	            return this._currentBlock;
	        }
	        // wait for a new latest block
	        const latestBlock = await new Promise((resolve) => this.once('latest', resolve));
	        // return newly set current block
	        return latestBlock;
	    }
	    // dont allow module consumer to remove our internal event listeners
	    removeAllListeners(eventName) {
	        // perform default behavior, preserve fn arity
	        if (eventName) {
	            super.removeAllListeners(eventName);
	        }
	        else {
	            super.removeAllListeners();
	        }
	        // re-add internal events
	        this._setupInternalEvents();
	        // trigger stop check just in case
	        this._onRemoveListener();
	        return this;
	    }
	    /**
	     * To be implemented in subclass.
	     */
	    _start() {
	        // default behavior is noop
	    }
	    /**
	     * To be implemented in subclass.
	     */
	    _end() {
	        // default behavior is noop
	    }
	    _setupInternalEvents() {
	        // first remove listeners for idempotence
	        this.removeListener('newListener', this._onNewListener);
	        this.removeListener('removeListener', this._onRemoveListener);
	        // then add them
	        this.on('newListener', this._onNewListener);
	        this.on('removeListener', this._onRemoveListener);
	    }
	    _onNewListener(eventName) {
	        // `newListener` is called *before* the listener is added
	        if (blockTrackerEvents.includes(eventName)) {
	            this._maybeStart();
	        }
	    }
	    _onRemoveListener() {
	        // `removeListener` is called *after* the listener is removed
	        if (this._getBlockTrackerEventCount() > 0) {
	            return;
	        }
	        this._maybeEnd();
	    }
	    _maybeStart() {
	        if (this._isRunning) {
	            return;
	        }
	        this._isRunning = true;
	        // cancel setting latest block to stale
	        this._cancelBlockResetTimeout();
	        this._start();
	    }
	    _maybeEnd() {
	        if (!this._isRunning) {
	            return;
	        }
	        this._isRunning = false;
	        this._setupBlockResetTimeout();
	        this._end();
	    }
	    _getBlockTrackerEventCount() {
	        return blockTrackerEvents
	            .map((eventName) => this.listenerCount(eventName))
	            .reduce(calculateSum);
	    }
	    _newPotentialLatest(newBlock) {
	        const currentBlock = this._currentBlock;
	        // only update if blok number is higher
	        if (currentBlock && (hexToInt$4(newBlock) <= hexToInt$4(currentBlock))) {
	            return;
	        }
	        this._setCurrentBlock(newBlock);
	    }
	    _setCurrentBlock(newBlock) {
	        const oldBlock = this._currentBlock;
	        this._currentBlock = newBlock;
	        this.emit('latest', newBlock);
	        this.emit('sync', { oldBlock, newBlock });
	    }
	    _setupBlockResetTimeout() {
	        // clear any existing timeout
	        this._cancelBlockResetTimeout();
	        // clear latest block when stale
	        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
	        // nodejs - dont hold process open
	        if (this._blockResetTimeout.unref) {
	            this._blockResetTimeout.unref();
	        }
	    }
	    _cancelBlockResetTimeout() {
	        if (this._blockResetTimeout) {
	            clearTimeout(this._blockResetTimeout);
	        }
	    }
	    _resetCurrentBlock() {
	        this._currentBlock = null;
	    }
	}
	BaseBlockTracker$1.BaseBlockTracker = BaseBlockTracker;
	function hexToInt$4(hexInt) {
	    return Number.parseInt(hexInt, 16);
	}

	var PollingBlockTracker$1 = {};

	var jsonRpcRandomId = IdIterator;

	function IdIterator(opts){
	  opts = opts || {};
	  var max = opts.max || Number.MAX_SAFE_INTEGER;
	  var idCounter = typeof opts.start !== 'undefined' ? opts.start : Math.floor(Math.random() * max);

	  return function createRandomId () {
	    idCounter = idCounter % max;
	    return idCounter++
	  }

	}

	const processFn$1 = (fn, opts) => function () {
		const P = opts.promiseModule;
		const args = new Array(arguments.length);

		for (let i = 0; i < arguments.length; i++) {
			args[i] = arguments[i];
		}

		return new P((resolve, reject) => {
			if (opts.errorFirst) {
				args.push(function (err, result) {
					if (opts.multiArgs) {
						const results = new Array(arguments.length - 1);

						for (let i = 1; i < arguments.length; i++) {
							results[i - 1] = arguments[i];
						}

						if (err) {
							results.unshift(err);
							reject(results);
						} else {
							resolve(results);
						}
					} else if (err) {
						reject(err);
					} else {
						resolve(result);
					}
				});
			} else {
				args.push(function (result) {
					if (opts.multiArgs) {
						const results = new Array(arguments.length - 1);

						for (let i = 0; i < arguments.length; i++) {
							results[i] = arguments[i];
						}

						resolve(results);
					} else {
						resolve(result);
					}
				});
			}

			fn.apply(this, args);
		});
	};

	var pify$2 = (obj, opts) => {
		opts = Object.assign({
			exclude: [/.+(Sync|Stream)$/],
			errorFirst: true,
			promiseModule: Promise
		}, opts);

		const filter = key => {
			const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
			return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
		};

		let ret;
		if (typeof obj === 'function') {
			ret = function () {
				if (opts.excludeMain) {
					return obj.apply(this, arguments);
				}

				return processFn$1(obj, opts).apply(this, arguments);
			};
		} else {
			ret = Object.create(Object.getPrototypeOf(obj));
		}

		for (const key in obj) { // eslint-disable-line guard-for-in
			const x = obj[key];
			ret[key] = typeof x === 'function' && filter(key) ? processFn$1(x, opts) : x;
		}

		return ret;
	};

	var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(PollingBlockTracker$1, "__esModule", { value: true });
	PollingBlockTracker$1.PollingBlockTracker = void 0;
	const json_rpc_random_id_1$1 = __importDefault$2(jsonRpcRandomId);
	const pify_1 = __importDefault$2(pify$2);
	const BaseBlockTracker_1$1 = BaseBlockTracker$1;
	const createRandomId$2 = json_rpc_random_id_1$1.default();
	const sec = 1000;
	class PollingBlockTracker extends BaseBlockTracker_1$1.BaseBlockTracker {
	    constructor(opts = {}) {
	        // parse + validate args
	        if (!opts.provider) {
	            throw new Error('PollingBlockTracker - no provider specified.');
	        }
	        super({
	            blockResetDuration: opts.pollingInterval,
	        });
	        // config
	        this._provider = opts.provider;
	        this._pollingInterval = opts.pollingInterval || 20 * sec;
	        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
	        this._keepEventLoopActive = opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;
	        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
	    }
	    // trigger block polling
	    async checkForLatestBlock() {
	        await this._updateLatestBlock();
	        return await this.getLatestBlock();
	    }
	    _start() {
	        this._synchronize().catch((err) => this.emit('error', err));
	    }
	    async _synchronize() {
	        while (this._isRunning) {
	            try {
	                await this._updateLatestBlock();
	                await timeout(this._pollingInterval, !this._keepEventLoopActive);
	            }
	            catch (err) {
	                const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`);
	                try {
	                    this.emit('error', newErr);
	                }
	                catch (emitErr) {
	                    console.error(newErr);
	                }
	                await timeout(this._retryTimeout, !this._keepEventLoopActive);
	            }
	        }
	    }
	    async _updateLatestBlock() {
	        // fetch + set latest block
	        const latestBlock = await this._fetchLatestBlock();
	        this._newPotentialLatest(latestBlock);
	    }
	    async _fetchLatestBlock() {
	        const req = {
	            jsonrpc: '2.0',
	            id: createRandomId$2(),
	            method: 'eth_blockNumber',
	            params: [],
	        };
	        if (this._setSkipCacheFlag) {
	            req.skipCache = true;
	        }
	        const res = await pify_1.default((cb) => this._provider.sendAsync(req, cb))();
	        if (res.error) {
	            throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error}`);
	        }
	        return res.result;
	    }
	}
	PollingBlockTracker$1.PollingBlockTracker = PollingBlockTracker;
	function timeout(duration, unref) {
	    return new Promise((resolve) => {
	        const timeoutRef = setTimeout(resolve, duration);
	        // don't keep process open
	        if (timeoutRef.unref && unref) {
	            timeoutRef.unref();
	        }
	    });
	}

	var SubscribeBlockTracker$1 = {};

	var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SubscribeBlockTracker$1, "__esModule", { value: true });
	SubscribeBlockTracker$1.SubscribeBlockTracker = void 0;
	const json_rpc_random_id_1 = __importDefault$1(jsonRpcRandomId);
	const BaseBlockTracker_1 = BaseBlockTracker$1;
	const createRandomId$1 = json_rpc_random_id_1.default();
	class SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
	    constructor(opts = {}) {
	        // parse + validate args
	        if (!opts.provider) {
	            throw new Error('SubscribeBlockTracker - no provider specified.');
	        }
	        // BaseBlockTracker constructor
	        super(opts);
	        // config
	        this._provider = opts.provider;
	        this._subscriptionId = null;
	    }
	    async checkForLatestBlock() {
	        return await this.getLatestBlock();
	    }
	    async _start() {
	        if (this._subscriptionId === undefined || this._subscriptionId === null) {
	            try {
	                const blockNumber = await this._call('eth_blockNumber');
	                this._subscriptionId = await this._call('eth_subscribe', 'newHeads', {});
	                this._provider.on('data', this._handleSubData.bind(this));
	                this._newPotentialLatest(blockNumber);
	            }
	            catch (e) {
	                this.emit('error', e);
	            }
	        }
	    }
	    async _end() {
	        if (this._subscriptionId !== null && this._subscriptionId !== undefined) {
	            try {
	                await this._call('eth_unsubscribe', this._subscriptionId);
	                this._subscriptionId = null;
	            }
	            catch (e) {
	                this.emit('error', e);
	            }
	        }
	    }
	    _call(method, ...params) {
	        return new Promise((resolve, reject) => {
	            this._provider.sendAsync({
	                id: createRandomId$1(), method, params, jsonrpc: '2.0',
	            }, (err, res) => {
	                if (err) {
	                    reject(err);
	                }
	                else {
	                    resolve(res.result);
	                }
	            });
	        });
	    }
	    _handleSubData(_, response) {
	        var _a;
	        if (response.method === 'eth_subscription' && ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {
	            this._newPotentialLatest(response.params.result.number);
	        }
	    }
	}
	SubscribeBlockTracker$1.SubscribeBlockTracker = SubscribeBlockTracker;

	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(BaseBlockTracker$1, exports);
		__exportStar(PollingBlockTracker$1, exports);
		__exportStar(SubscribeBlockTracker$1, exports);
		
	} (dist));

	function expect(value, message) {
	    if (value === undefined || value === null) {
	        throw dist$3.ethErrors.rpc.invalidInput(message);
	    }
	    return value;
	}
	function assert(predicate, message) {
	    if (!predicate) {
	        throw dist$3.ethErrors.rpc.invalidInput(message);
	    }
	}

	const getRequestContext = (req) => {
	    return expect(req.context, 'no context found on this request');
	};

	class LegacyMiddlewareProvider {
	    constructor(context) {
	        this.context = context;
	        this.blockTracker = new dist.PollingBlockTracker({
	            // The only method used in block trackers is `sendAsync`
	            provider: this,
	            pollingInterval: context.config.pollingInterval,
	            setSkipCacheFlag: true,
	        });
	    }
	    sendAsync(
	    // Skip cache comes from block tracker and legacy middlewares
	    request, callback) {
	        this.context
	            .request({ method: request.method, params: request.params }, {
	            skipCache: request.skipCache,
	        })
	            .then((result) => {
	            callback(null, { result });
	        })
	            .catch((err) => {
	            callback(err);
	        });
	    }
	}
	const PROVIDERS = new Map();
	const getLegacyMiddlewareProviderFor = (context) => {
	    let provider = PROVIDERS.get(context.chain.chainId);
	    if (!provider) {
	        provider = new LegacyMiddlewareProvider(context);
	        PROVIDERS.set(context.chain.chainId, provider);
	    }
	    return provider;
	};
	const createLegacyMiddleware = (createMiddleware) => {
	    const MIDDLEWARES = new Map();
	    const getMiddlewareFor = (context) => {
	        let middleware = MIDDLEWARES.get(context.chain.chainId);
	        if (!middleware) {
	            const legacyProvider = getLegacyMiddlewareProviderFor(context);
	            middleware = createMiddleware({
	                context,
	                provider: legacyProvider,
	                blockTracker: legacyProvider.blockTracker,
	            });
	            MIDDLEWARES.set(context.chain.chainId, middleware);
	        }
	        return middleware;
	    };
	    return (req, res, next, end) => {
	        const context = getRequestContext(req);
	        const middleware = getMiddlewareFor(context);
	        middleware(req, res, next, end);
	    };
	};

	const createBlockCacheMiddleware = () => createLegacyMiddleware(({ blockTracker }) => {
	    // TODO type mismatch but they should be compatible
	    return createBlockCacheMiddleware_1({ blockTracker: blockTracker });
	});

	const createChainManagementMiddleware = () => {
	    return dist$2.createAsyncMiddleware(async (req, res, next) => {
	        var _a, _b;
	        const { method } = req;
	        const context = getRequestContext(req);
	        if (method === ethProviderTypes.EthMethod.eth_chainId) {
	            res.result = context.chain.chainId;
	            return;
	        }
	        if (method === ethProviderTypes.EthMethod.wallet_addEthereumChain) {
	            const definition = expect((_a = req.params) === null || _a === void 0 ? void 0 : _a[0], 'addEthereumChain requires a chain definition parameter');
	            await context.store.addChain(definition);
	            res.result = null;
	            return;
	        }
	        if (method === ethProviderTypes.EthMethod.wallet_switchEthereumChain) {
	            const chainDetails = expect((_b = req.params) === null || _b === void 0 ? void 0 : _b[0], 'switchEthereumChain requires a chainId');
	            const chain = await context.store.findChain(chainDetails.chainId);
	            if (!chain) {
	                throw dist$3.ethErrors.provider.userRejectedRequest({ message: 'Chain does not exist' });
	            }
	            await context.store.setCurrentChainId(chainDetails.chainId);
	            context.emit(ethProviderTypes.EthEvent.chainChanged, chainDetails.chainId);
	            res.result = null;
	            return;
	        }
	        return next();
	    });
	};

	const RETRIABLE_ERRORS = [
	    // ignore server overload errors
	    'Gateway timeout',
	    'ETIMEDOUT',
	    // ignore server sent html error pages
	    // or truncated json responses
	    'SyntaxError',
	    'failed to parse response body',
	    'ECONNRESET',
	    'EHOSTUNREACH',
	    'Timeout out while waiting for response',
	    // ignore errors where http req failed to establish
	    'Failed to fetch',
	    'ENOTFOUND', // DNS error
	];
	const isErrorRetriable = (err) => {
	    if (!(err instanceof Error) && typeof err !== 'string') {
	        return false;
	    }
	    const errMsg = typeof err === 'string' ? err : err.message;
	    return RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
	};
	const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
	const maybeGetErrorMessage = (text) => {
	    try {
	        const json = JSON.parse(text);
	        return json.error;
	    }
	    catch (err) {
	        return undefined;
	    }
	};
	const fetchJsonWithRetry = async (fetchFn, retryCount, url, init, waitBeforeRetryFor = 0) => {
	    try {
	        const response = await fetchFn(url, {
	            method: init.method,
	            body: init.body ? JSON.stringify(init.body) : undefined,
	            headers: Object.assign({ Accept: 'application/json', 'Content-Type': 'application/json' }, init.headers),
	        });
	        if (!response.ok) {
	            switch (response.status) {
	                case 405:
	                    throw dist$3.ethErrors.rpc.methodNotFound();
	                case 429:
	                    throw dist$3.ethErrors.rpc.limitExceeded('Request is being rate limited.');
	                case 503:
	                case 504:
	                    throw dist$3.ethErrors.rpc.internal('Gateway timeout. The request took too long to process. This can happen when querying logs over too wide a block range.');
	                default:
	                    // eslint-disable-next-line no-case-declarations
	                    const text = await response.text();
	                    // eslint-disable-next-line no-case-declarations
	                    const errorMessage = maybeGetErrorMessage(text);
	                    throw dist$3.ethErrors.rpc.internal(errorMessage !== null && errorMessage !== void 0 ? errorMessage : `Request failed, response status: ${response.status}, body: ${text}`);
	            }
	        }
	        return response.json();
	    }
	    catch (err) {
	        if (err && isErrorRetriable(err)) {
	            if (retryCount > 0) {
	                await sleep(waitBeforeRetryFor);
	                return fetchJsonWithRetry(fetchFn, retryCount - 1, url, init, waitBeforeRetryFor + 1000);
	            }
	            else {
	                throw dist$3.ethErrors.rpc.internal(`FetchSubprovider - cannot complete request. All retries exhausted.\nOriginal Error:\n${err}\n\n`);
	            }
	        }
	        else if (err instanceof dist$3.EthereumRpcError || err instanceof dist$3.EthereumProviderError) {
	            throw err;
	        }
	        else {
	            throw dist$3.ethErrors.rpc.internal(err instanceof Error ? err.message : 'Something went wrong');
	        }
	    }
	};
	const fetchJsonRpcWithRetry = async (fetchFn, retryCount, url, init) => {
	    if (init.body && !init.body.params) {
	        init.body.params = [];
	    }
	    const { result, error } = (await fetchJsonWithRetry(fetchFn, retryCount, url, init));
	    if (error) {
	        throw dist$3.ethErrors.rpc.internal(error);
	    }
	    else if (result === undefined) {
	        throw dist$3.ethErrors.rpc.internal('Missing result');
	    }
	    return result;
	};

	const REFRESH = Symbol();
	const ANON_USER = 'anonymous';
	// We fetch accounts directly in this middleware so that we ensure we're always
	// hitting Bitski direcly and not another RPC url (e.g. for custom RPCs/chains).
	const fetchAccounts = async (req, config) => {
	    const headers = Object.assign({}, config.additionalHeaders);
	    if (config.getAccessToken) {
	        headers['Authorization'] = `Bearer ${await config.getAccessToken()}`;
	    }
	    return (await fetchJsonRpcWithRetry(config.fetch, 5, `${BITSKI_RPC_BASE_URL}/mainnet`, {
	        method: 'POST',
	        headers,
	        body: {
	            id: req.id,
	            jsonrpc: req.jsonrpc,
	            method: ethProviderTypes.EthMethod.eth_accounts,
	            params: req.params,
	        },
	    }));
	};
	const createEthAccountsMiddleware = () => {
	    const cache = new Map();
	    return dist$2.createAsyncMiddleware(async (req, res, next) => {
	        var _a, _b;
	        if (req.method !== ethProviderTypes.EthMethod.eth_accounts && req.method !== ethProviderTypes.EthMethod.eth_requestAccounts) {
	            return next();
	        }
	        const { config } = getRequestContext(req);
	        const user = await ((_a = config.getUser) === null || _a === void 0 ? void 0 : _a.call(config));
	        const userId = (_b = user === null || user === void 0 ? void 0 : user.id) !== null && _b !== void 0 ? _b : ANON_USER;
	        let accounts = cache.get(userId);
	        if (!accounts || accounts === REFRESH) {
	            if (!accounts && (user === null || user === void 0 ? void 0 : user.accounts)) {
	                accounts = user.accounts;
	            }
	            else {
	                accounts = await fetchAccounts(req, config);
	            }
	            cache.set(userId, accounts);
	            setTimeout(() => cache.set(userId, REFRESH), 5 * 60 * 1000);
	        }
	        res.result = accounts;
	    });
	};

	const MATCHING_METHODS = [
	    ethProviderTypes.EthMethod.eth_getBlockByNumber,
	    ethProviderTypes.EthMethod.eth_blockNumber,
	    ethProviderTypes.EthMethod.net_version,
	    ethProviderTypes.EthMethod.eth_getLogs,
	];
	const createFetchRestMiddleware = () => {
	    return dist$2.createAsyncMiddleware(async (req, res, next) => {
	        var _a, _b;
	        if (!MATCHING_METHODS.includes(req.method)) {
	            return next();
	        }
	        const { config, chain } = getRequestContext(req);
	        const query = ((_b = (_a = req.params) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0
	            ? `?params=${encodeURIComponent(JSON.stringify(req.params))}`
	            : '';
	        const url = `${chain.rpcUrls[0]}/${req.method}${query}`;
	        const headers = Object.assign({}, config.additionalHeaders);
	        res.result = fetchJsonWithRetry(config.fetch, 5, url, {
	            method: 'GET',
	            headers,
	            credentials: 'omit',
	        });
	    });
	};

	const createFetchRpcMiddleware = () => {
	    return dist$2.createAsyncMiddleware(async (req, res) => {
	        const { config, chain } = getRequestContext(req);
	        const headers = Object.assign({}, config.additionalHeaders);
	        res.result = await fetchJsonRpcWithRetry(config.fetch, 5, chain.rpcUrls[0], {
	            method: 'POST',
	            headers,
	            body: {
	                id: req.id,
	                jsonrpc: req.jsonrpc,
	                method: req.method,
	                params: req.params,
	            },
	        });
	    });
	};

	var lib = {};

	var Mutex$2 = {};

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends$3(d, b) {
	    if (typeof b !== "function" && b !== null)
	        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	}

	function __decorate(decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function __param(paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	}

	function __metadata(metadataKey, metadataValue) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	}

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	var __createBinding = Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	        desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	});

	function __exportStar(m, o) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
	}

	function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	/** @deprecated */
	function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++)
	        ar = ar.concat(__read(arguments[i]));
	    return ar;
	}

	/** @deprecated */
	function __spreadArrays() {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	}

	function __spreadArray$1(to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	}

	function __await(v) {
	    return this instanceof __await ? (this.v = v, this) : new __await(v);
	}

	function __asyncGenerator(thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	}

	function __asyncDelegator(o) {
	    var i, p;
	    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
	    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
	}

	function __asyncValues(o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	}

	function __makeTemplateObject(cooked, raw) {
	    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
	    return cooked;
	}
	var __setModuleDefault = Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	};

	function __importStar(mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	}

	function __importDefault(mod) {
	    return (mod && mod.__esModule) ? mod : { default: mod };
	}

	function __classPrivateFieldGet(receiver, state, kind, f) {
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	}

	function __classPrivateFieldSet(receiver, state, value, kind, f) {
	    if (kind === "m") throw new TypeError("Private method is not writable");
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
	}

	function __classPrivateFieldIn(state, receiver) {
	    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
	    return typeof state === "function" ? receiver === state : state.has(receiver);
	}

	var tslib_es6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		__extends: __extends$3,
		get __assign () { return __assign; },
		__rest: __rest,
		__decorate: __decorate,
		__param: __param,
		__metadata: __metadata,
		__awaiter: __awaiter,
		__generator: __generator,
		__createBinding: __createBinding,
		__exportStar: __exportStar,
		__values: __values,
		__read: __read,
		__spread: __spread,
		__spreadArrays: __spreadArrays,
		__spreadArray: __spreadArray$1,
		__await: __await,
		__asyncGenerator: __asyncGenerator,
		__asyncDelegator: __asyncDelegator,
		__asyncValues: __asyncValues,
		__makeTemplateObject: __makeTemplateObject,
		__importStar: __importStar,
		__importDefault: __importDefault,
		__classPrivateFieldGet: __classPrivateFieldGet,
		__classPrivateFieldSet: __classPrivateFieldSet,
		__classPrivateFieldIn: __classPrivateFieldIn
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

	var Semaphore$1 = {};

	Object.defineProperty(Semaphore$1, "__esModule", { value: true });
	var tslib_1$2 = require$$0;
	var Semaphore = /** @class */ (function () {
	    function Semaphore(_maxConcurrency) {
	        this._maxConcurrency = _maxConcurrency;
	        this._queue = [];
	        if (_maxConcurrency <= 0) {
	            throw new Error('semaphore must be initialized to a positive value');
	        }
	        this._value = _maxConcurrency;
	    }
	    Semaphore.prototype.acquire = function () {
	        var _this = this;
	        var locked = this.isLocked();
	        var ticket = new Promise(function (r) { return _this._queue.push(r); });
	        if (!locked)
	            this._dispatch();
	        return ticket;
	    };
	    Semaphore.prototype.runExclusive = function (callback) {
	        return tslib_1$2.__awaiter(this, void 0, void 0, function () {
	            var _a, value, release;
	            return tslib_1$2.__generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0: return [4 /*yield*/, this.acquire()];
	                    case 1:
	                        _a = _b.sent(), value = _a[0], release = _a[1];
	                        _b.label = 2;
	                    case 2:
	                        _b.trys.push([2, , 4, 5]);
	                        return [4 /*yield*/, callback(value)];
	                    case 3: return [2 /*return*/, _b.sent()];
	                    case 4:
	                        release();
	                        return [7 /*endfinally*/];
	                    case 5: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    Semaphore.prototype.isLocked = function () {
	        return this._value <= 0;
	    };
	    Semaphore.prototype.release = function () {
	        if (this._maxConcurrency > 1) {
	            throw new Error('this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead');
	        }
	        if (this._currentReleaser) {
	            var releaser = this._currentReleaser;
	            this._currentReleaser = undefined;
	            releaser();
	        }
	    };
	    Semaphore.prototype._dispatch = function () {
	        var _this = this;
	        var nextConsumer = this._queue.shift();
	        if (!nextConsumer)
	            return;
	        var released = false;
	        this._currentReleaser = function () {
	            if (released)
	                return;
	            released = true;
	            _this._value++;
	            _this._dispatch();
	        };
	        nextConsumer([this._value--, this._currentReleaser]);
	    };
	    return Semaphore;
	}());
	Semaphore$1.default = Semaphore;

	Object.defineProperty(Mutex$2, "__esModule", { value: true });
	var tslib_1$1 = require$$0;
	var Semaphore_1 = Semaphore$1;
	var Mutex$1 = /** @class */ (function () {
	    function Mutex() {
	        this._semaphore = new Semaphore_1.default(1);
	    }
	    Mutex.prototype.acquire = function () {
	        return tslib_1$1.__awaiter(this, void 0, void 0, function () {
	            var _a, releaser;
	            return tslib_1$1.__generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0: return [4 /*yield*/, this._semaphore.acquire()];
	                    case 1:
	                        _a = _b.sent(), releaser = _a[1];
	                        return [2 /*return*/, releaser];
	                }
	            });
	        });
	    };
	    Mutex.prototype.runExclusive = function (callback) {
	        return this._semaphore.runExclusive(function () { return callback(); });
	    };
	    Mutex.prototype.isLocked = function () {
	        return this._semaphore.isLocked();
	    };
	    Mutex.prototype.release = function () {
	        this._semaphore.release();
	    };
	    return Mutex;
	}());
	Mutex$2.default = Mutex$1;

	var withTimeout$1 = {};

	Object.defineProperty(withTimeout$1, "__esModule", { value: true });
	withTimeout$1.withTimeout = void 0;
	var tslib_1 = require$$0;
	// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
	function withTimeout(sync, timeout, timeoutError) {
	    var _this = this;
	    if (timeoutError === void 0) { timeoutError = new Error('timeout'); }
	    return {
	        acquire: function () {
	            return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
	                var isTimeout, ticket, release;
	                return tslib_1.__generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            isTimeout = false;
	                            setTimeout(function () {
	                                isTimeout = true;
	                                reject(timeoutError);
	                            }, timeout);
	                            return [4 /*yield*/, sync.acquire()];
	                        case 1:
	                            ticket = _a.sent();
	                            if (isTimeout) {
	                                release = Array.isArray(ticket) ? ticket[1] : ticket;
	                                release();
	                            }
	                            else {
	                                resolve(ticket);
	                            }
	                            return [2 /*return*/];
	                    }
	                });
	            }); });
	        },
	        runExclusive: function (callback) {
	            return tslib_1.__awaiter(this, void 0, void 0, function () {
	                var release, ticket;
	                return tslib_1.__generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            release = function () { return undefined; };
	                            _a.label = 1;
	                        case 1:
	                            _a.trys.push([1, , 7, 8]);
	                            return [4 /*yield*/, this.acquire()];
	                        case 2:
	                            ticket = _a.sent();
	                            if (!Array.isArray(ticket)) return [3 /*break*/, 4];
	                            release = ticket[1];
	                            return [4 /*yield*/, callback(ticket[0])];
	                        case 3: return [2 /*return*/, _a.sent()];
	                        case 4:
	                            release = ticket;
	                            return [4 /*yield*/, callback()];
	                        case 5: return [2 /*return*/, _a.sent()];
	                        case 6: return [3 /*break*/, 8];
	                        case 7:
	                            release();
	                            return [7 /*endfinally*/];
	                        case 8: return [2 /*return*/];
	                    }
	                });
	            });
	        },
	        release: function () {
	            sync.release();
	        },
	        isLocked: function () { return sync.isLocked(); },
	    };
	}
	withTimeout$1.withTimeout = withTimeout;

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
		var Mutex_1 = Mutex$2;
		Object.defineProperty(exports, "Mutex", { enumerable: true, get: function () { return Mutex_1.default; } });
		var Semaphore_1 = Semaphore$1;
		Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function () { return Semaphore_1.default; } });
		var withTimeout_1 = withTimeout$1;
		Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function () { return withTimeout_1.withTimeout; } });
	} (lib));

	var scaffold = {exports: {}};

	var createScaffoldMiddleware$1 = function createScaffoldMiddleware (handlers) {
	  return (req, res, next, end) => {
	    const handler = handlers[req.method];
	    // if no handler, return
	    if (handler === undefined) {
	      return next()
	    }
	    // if handler is fn, call as middleware
	    if (typeof handler === 'function') {
	      return handler(req, res, next, end)
	    }
	    // if handler is some other value, use as result
	    res.result = handler;
	    return end()
	  }
	};

	(function (module) {
		// for backwards compat
		module.exports = createScaffoldMiddleware$1;
	} (scaffold));

	var immutable = extend$1;

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend$1() {
	    var target = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i];

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }

	    return target
	}

	const extend = immutable;
	const createRandomId = jsonRpcRandomId();

	var ethQuery = EthQuery$1;


	function EthQuery$1(provider){
	  const self = this;
	  self.currentProvider = provider;
	}

	//
	// base queries
	//

	// default block
	EthQuery$1.prototype.getBalance =                          generateFnWithDefaultBlockFor(2, 'eth_getBalance');
	EthQuery$1.prototype.getCode =                             generateFnWithDefaultBlockFor(2, 'eth_getCode');
	EthQuery$1.prototype.getTransactionCount =                 generateFnWithDefaultBlockFor(2, 'eth_getTransactionCount');
	EthQuery$1.prototype.getStorageAt =                        generateFnWithDefaultBlockFor(3, 'eth_getStorageAt');
	EthQuery$1.prototype.call =                                generateFnWithDefaultBlockFor(2, 'eth_call');
	// standard
	EthQuery$1.prototype.protocolVersion =                     generateFnFor('eth_protocolVersion');
	EthQuery$1.prototype.syncing =                             generateFnFor('eth_syncing');
	EthQuery$1.prototype.coinbase =                            generateFnFor('eth_coinbase');
	EthQuery$1.prototype.mining =                              generateFnFor('eth_mining');
	EthQuery$1.prototype.hashrate =                            generateFnFor('eth_hashrate');
	EthQuery$1.prototype.gasPrice =                            generateFnFor('eth_gasPrice');
	EthQuery$1.prototype.accounts =                            generateFnFor('eth_accounts');
	EthQuery$1.prototype.blockNumber =                         generateFnFor('eth_blockNumber');
	EthQuery$1.prototype.getBlockTransactionCountByHash =      generateFnFor('eth_getBlockTransactionCountByHash');
	EthQuery$1.prototype.getBlockTransactionCountByNumber =    generateFnFor('eth_getBlockTransactionCountByNumber');
	EthQuery$1.prototype.getUncleCountByBlockHash =            generateFnFor('eth_getUncleCountByBlockHash');
	EthQuery$1.prototype.getUncleCountByBlockNumber =          generateFnFor('eth_getUncleCountByBlockNumber');
	EthQuery$1.prototype.sign =                                generateFnFor('eth_sign');
	EthQuery$1.prototype.sendTransaction =                     generateFnFor('eth_sendTransaction');
	EthQuery$1.prototype.sendRawTransaction =                  generateFnFor('eth_sendRawTransaction');
	EthQuery$1.prototype.estimateGas =                         generateFnFor('eth_estimateGas');
	EthQuery$1.prototype.getBlockByHash =                      generateFnFor('eth_getBlockByHash');
	EthQuery$1.prototype.getBlockByNumber =                    generateFnFor('eth_getBlockByNumber');
	EthQuery$1.prototype.getTransactionByHash =                generateFnFor('eth_getTransactionByHash');
	EthQuery$1.prototype.getTransactionByBlockHashAndIndex =   generateFnFor('eth_getTransactionByBlockHashAndIndex');
	EthQuery$1.prototype.getTransactionByBlockNumberAndIndex = generateFnFor('eth_getTransactionByBlockNumberAndIndex');
	EthQuery$1.prototype.getTransactionReceipt =               generateFnFor('eth_getTransactionReceipt');
	EthQuery$1.prototype.getUncleByBlockHashAndIndex =         generateFnFor('eth_getUncleByBlockHashAndIndex');
	EthQuery$1.prototype.getUncleByBlockNumberAndIndex =       generateFnFor('eth_getUncleByBlockNumberAndIndex');
	EthQuery$1.prototype.getCompilers =                        generateFnFor('eth_getCompilers');
	EthQuery$1.prototype.compileLLL =                          generateFnFor('eth_compileLLL');
	EthQuery$1.prototype.compileSolidity =                     generateFnFor('eth_compileSolidity');
	EthQuery$1.prototype.compileSerpent =                      generateFnFor('eth_compileSerpent');
	EthQuery$1.prototype.newFilter =                           generateFnFor('eth_newFilter');
	EthQuery$1.prototype.newBlockFilter =                      generateFnFor('eth_newBlockFilter');
	EthQuery$1.prototype.newPendingTransactionFilter =         generateFnFor('eth_newPendingTransactionFilter');
	EthQuery$1.prototype.uninstallFilter =                     generateFnFor('eth_uninstallFilter');
	EthQuery$1.prototype.getFilterChanges =                    generateFnFor('eth_getFilterChanges');
	EthQuery$1.prototype.getFilterLogs =                       generateFnFor('eth_getFilterLogs');
	EthQuery$1.prototype.getLogs =                             generateFnFor('eth_getLogs');
	EthQuery$1.prototype.getWork =                             generateFnFor('eth_getWork');
	EthQuery$1.prototype.submitWork =                          generateFnFor('eth_submitWork');
	EthQuery$1.prototype.submitHashrate =                      generateFnFor('eth_submitHashrate');

	// network level

	EthQuery$1.prototype.sendAsync = function(opts, cb){
	  const self = this;
	  self.currentProvider.sendAsync(createPayload$1(opts), function(err, response){
	    if (!err && response.error) err = new Error('EthQuery - RPC Error - '+response.error.message);
	    if (err) return cb(err)
	    cb(null, response.result);
	  });
	};

	// util

	function generateFnFor(methodName){
	  return function(){
	    const self = this;
	    var args = [].slice.call(arguments);
	    var cb = args.pop();
	    self.sendAsync({
	      method: methodName,
	      params: args,
	    }, cb);
	  }
	}

	function generateFnWithDefaultBlockFor(argCount, methodName){
	  return function(){
	    const self = this;
	    var args = [].slice.call(arguments);
	    var cb = args.pop();
	    // set optional default block param
	    if (args.length < argCount) args.push('latest');
	    self.sendAsync({
	      method: methodName,
	      params: args,
	    }, cb);
	  }
	}

	function createPayload$1(data){
	  return extend({
	    // defaults
	    id: createRandomId(),
	    jsonrpc: '2.0',
	    params: [],
	    // user-specified
	  }, data)
	}

	const processFn = (fn, options, proxy, unwrapped) => function (...arguments_) {
		const P = options.promiseModule;

		return new P((resolve, reject) => {
			if (options.multiArgs) {
				arguments_.push((...result) => {
					if (options.errorFirst) {
						if (result[0]) {
							reject(result);
						} else {
							result.shift();
							resolve(result);
						}
					} else {
						resolve(result);
					}
				});
			} else if (options.errorFirst) {
				arguments_.push((error, result) => {
					if (error) {
						reject(error);
					} else {
						resolve(result);
					}
				});
			} else {
				arguments_.push(resolve);
			}

			const self = this === proxy ? unwrapped : this;
			Reflect.apply(fn, self, arguments_);
		});
	};

	const filterCache = new WeakMap();

	var pify$1 = (input, options) => {
		options = {
			exclude: [/.+(?:Sync|Stream)$/],
			errorFirst: true,
			promiseModule: Promise,
			...options
		};

		const objectType = typeof input;
		if (!(input !== null && (objectType === 'object' || objectType === 'function'))) {
			throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? 'null' : objectType}\``);
		}

		const filter = (target, key) => {
			let cached = filterCache.get(target);

			if (!cached) {
				cached = {};
				filterCache.set(target, cached);
			}

			if (key in cached) {
				return cached[key];
			}

			const match = pattern => (typeof pattern === 'string' || typeof key === 'symbol') ? key === pattern : pattern.test(key);
			const desc = Reflect.getOwnPropertyDescriptor(target, key);
			const writableOrConfigurableOwn = (desc === undefined || desc.writable || desc.configurable);
			const included = options.include ? options.include.some(match) : !options.exclude.some(match);
			const shouldFilter = included && writableOrConfigurableOwn;
			cached[key] = shouldFilter;
			return shouldFilter;
		};

		const cache = new WeakMap();

		const proxy = new Proxy(input, {
			apply(target, thisArg, args) {
				const cached = cache.get(target);

				if (cached) {
					return Reflect.apply(cached, thisArg, args);
				}

				const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
				cache.set(target, pified);
				return Reflect.apply(pified, thisArg, args);
			},

			get(target, key) {
				const property = target[key];

				// eslint-disable-next-line no-use-extend-native/no-use-extend-native
				if (!filter(target, key) || property === Function.prototype[key]) {
					return property;
				}

				const cached = cache.get(property);

				if (cached) {
					return cached;
				}

				if (typeof property === 'function') {
					const pified = processFn(property, options, proxy, target);
					cache.set(property, pified);
					return pified;
				}

				return property;
			}
		});

		return proxy;
	};

	const SafeEventEmitter$1 = safeEventEmitter.default;

	let BaseFilter$3 = class BaseFilter extends SafeEventEmitter$1 {

	  constructor () {
	    super();
	    this.updates = [];
	  }

	  async initialize () {}

	  async update () {
	    throw new Error('BaseFilter - no update method specified')
	  }

	  addResults (newResults) {
	    this.updates = this.updates.concat(newResults);
	    newResults.forEach(result => this.emit('update', result));
	  }

	  addInitialResults (newResults) {}

	  getChangesAndClear () {
	    const updates = this.updates;
	    this.updates = [];
	    return updates
	  }
	  
	};

	var baseFilter = BaseFilter$3;

	const BaseFilter$2 = baseFilter;

	// tracks all results ever recorded
	let BaseFilterWithHistory$1 = class BaseFilterWithHistory extends BaseFilter$2 {

	  constructor () {
	    super();
	    this.allResults = [];
	  }

	  async update () {
	    throw new Error('BaseFilterWithHistory - no update method specified')
	  }

	  addResults (newResults) {
	    this.allResults = this.allResults.concat(newResults);
	    super.addResults(newResults);
	  }

	  addInitialResults (newResults) {
	    this.allResults = this.allResults.concat(newResults);
	    super.addInitialResults(newResults);
	  }

	  getAllResults () {
	    return this.allResults
	  }

	};

	var baseFilterHistory = BaseFilterWithHistory$1;

	var hexUtils = {
	  minBlockRef: minBlockRef$1,
	  maxBlockRef,
	  sortBlockRefs,
	  bnToHex: bnToHex$1,
	  blockRefIsNumber: blockRefIsNumber$1,
	  hexToInt: hexToInt$3,
	  incrementHexInt: incrementHexInt$4,
	  intToHex: intToHex$2,
	  unsafeRandomBytes: unsafeRandomBytes$1,
	};

	function minBlockRef$1(...refs) {
	  const sortedRefs = sortBlockRefs(refs);
	  return sortedRefs[0]
	}

	function maxBlockRef(...refs) {
	  const sortedRefs = sortBlockRefs(refs);
	  return sortedRefs[sortedRefs.length-1]
	}

	function sortBlockRefs(refs) {
	  return refs.sort((refA, refB) => {
	    if (refA === 'latest' || refB === 'earliest') return 1
	    if (refB === 'latest' || refA === 'earliest') return -1
	    return hexToInt$3(refA) - hexToInt$3(refB)
	  })
	}

	function bnToHex$1(bn) {
	  return '0x' + bn.toString(16)
	}

	function blockRefIsNumber$1(blockRef){
	  return blockRef && !['earliest', 'latest', 'pending'].includes(blockRef)
	}

	function hexToInt$3(hexString) {
	  if (hexString === undefined || hexString === null) return hexString
	  return Number.parseInt(hexString, 16)
	}

	function incrementHexInt$4(hexString){
	  if (hexString === undefined || hexString === null) return hexString
	  const value = hexToInt$3(hexString);
	  return intToHex$2(value + 1)
	}

	function intToHex$2(int) {
	  if (int === undefined || int === null) return int
	  let hexString = int.toString(16);
	  const needsLeftPad = hexString.length % 2;
	  if (needsLeftPad) hexString = '0' + hexString;
	  return '0x' + hexString
	}

	function unsafeRandomBytes$1(byteCount) {
	  let result = '0x';
	  for (let i = 0; i < byteCount; i++) {
	    result += unsafeRandomNibble();
	    result += unsafeRandomNibble();
	  }
	  return result
	}

	function unsafeRandomNibble() {
	  return Math.floor(Math.random() * 16).toString(16)
	}

	const EthQuery = ethQuery;
	const pify = pify$1;
	const BaseFilterWithHistory = baseFilterHistory;
	const { bnToHex, hexToInt: hexToInt$2, incrementHexInt: incrementHexInt$3, minBlockRef, blockRefIsNumber } = hexUtils;

	let LogFilter$1 = class LogFilter extends BaseFilterWithHistory {

	  constructor ({ provider, params }) {
	    super();
	    this.type = 'log';
	    this.ethQuery = new EthQuery(provider);
	    this.params = Object.assign({
	      fromBlock: 'latest',
	      toBlock: 'latest',
	      address: undefined,
	      topics: [],
	    }, params);
	    // normalize address parameter
	    if (this.params.address) {
	      // ensure array
	      if (!Array.isArray(this.params.address)) {
	        this.params.address = [this.params.address];
	      }
	      // ensure lowercase
	      this.params.address = this.params.address.map(address => address.toLowerCase());
	    }
	  }

	  async initialize({ currentBlock }) {
	    // resolve params.fromBlock
	    let fromBlock = this.params.fromBlock;
	    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;
	    if ('earliest' === fromBlock) fromBlock = '0x0';
	    this.params.fromBlock = fromBlock;
	    // set toBlock for initial lookup
	    const toBlock = minBlockRef(this.params.toBlock, currentBlock);
	    const params = Object.assign({}, this.params, { toBlock });
	    // fetch logs and add to results
	    const newLogs = await this._fetchLogs(params);
	    this.addInitialResults(newLogs);
	  }

	  async update ({ oldBlock, newBlock }) {
	    // configure params for this update
	    const toBlock = newBlock;
	    let fromBlock;
	    // oldBlock is empty on first sync
	    if (oldBlock) {
	      fromBlock = incrementHexInt$3(oldBlock);
	    } else {
	      fromBlock = newBlock;
	    }
	    // fetch logs
	    const params = Object.assign({}, this.params, { fromBlock, toBlock });
	    const newLogs = await this._fetchLogs(params);
	    const matchingLogs = newLogs.filter(log => this.matchLog(log));

	    // add to results
	    this.addResults(matchingLogs);
	  }

	  async _fetchLogs (params) {
	    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))();
	    // add to results
	    return newLogs
	  }

	  matchLog(log) {
	    // check if block number in bounds:
	    if (hexToInt$2(this.params.fromBlock) >= hexToInt$2(log.blockNumber)) return false
	    if (blockRefIsNumber(this.params.toBlock) && hexToInt$2(this.params.toBlock) <= hexToInt$2(log.blockNumber)) return false

	    // address is correct:
	    const normalizedLogAddress = log.address && log.address.toLowerCase();
	    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false

	    // topics match:
	    // topics are position-dependant
	    // topics can be nested to represent `or` [[a || b], c]
	    // topics can be null, representing a wild card for that position
	    const topicsMatch = this.params.topics.every((topicPattern, index) => {
	      // pattern is longer than actual topics
	      let logTopic = log.topics[index];
	      if (!logTopic) return false
	      logTopic = logTopic.toLowerCase();
	      // normalize subTopics
	      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
	      // check for wild card
	      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
	      if (subtopicsIncludeWildcard) return true
	      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase());
	      // check each possible matching topic
	      const topicDoesMatch = subtopicsToMatch.includes(logTopic);
	      return topicDoesMatch
	    });

	    return topicsMatch
	  }

	};

	var logFilter = LogFilter$1;

	var getBlocksForRange_1 = getBlocksForRange$3;

	async function getBlocksForRange$3({ provider, fromBlock, toBlock }) {
	  if (!fromBlock) fromBlock = toBlock;

	  const fromBlockNumber = hexToInt$1(fromBlock);
	  const toBlockNumber = hexToInt$1(toBlock);
	  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
	  // load all blocks from old to new (inclusive)
	  const missingBlockNumbers = Array(blockCountToQuery).fill()
	                              .map((_,index) => fromBlockNumber + index)
	                              .map(intToHex$1);
	  const blockBodies = await Promise.all(
	    missingBlockNumbers.map(blockNum => query(provider, 'eth_getBlockByNumber', [blockNum, false]))
	  );
	  return blockBodies
	}

	function hexToInt$1(hexString) {
	  if (hexString === undefined || hexString === null) return hexString
	  return Number.parseInt(hexString, 16)
	}

	function intToHex$1(int) {
	  if (int === undefined || int === null) return int
	  const hexString = int.toString(16);
	  return '0x' + hexString
	}

	function sendAsync(provider, request) {
	  return new Promise((resolve, reject) => {
	    provider.sendAsync(request, (error, response) => {
	      if (error) {
	        reject(error);
	      } else if (response.error) {
	        reject(response.error);
	      } else if (response.result) {
	        resolve(response.result);
	      } else {
	        reject(new Error("Result was empty"));
	      }
	    });
	  });
	}

	async function query(provider, method, params) {
	  for (let i = 0; i < 3; i++) {
	    try {
	      return await sendAsync(provider, {
	        id: 1,
	        jsonrpc: "2.0",
	        method,
	        params,
	      });
	    } catch (error) {
	      console.error(
	        `provider.sendAsync failed: ${error.stack || error.message || error}`
	      );
	    }
	  }
	  throw new Error(`Block not found for params: ${JSON.stringify(params)}`);
	}

	const BaseFilter$1 = baseFilter;
	const getBlocksForRange$2 = getBlocksForRange_1;
	const { incrementHexInt: incrementHexInt$2 } = hexUtils;

	let BlockFilter$1 = class BlockFilter extends BaseFilter$1 {

	  constructor ({ provider, params }) {
	    super();
	    this.type = 'block';
	    this.provider = provider;
	  }

	  async update ({ oldBlock, newBlock }) {
	    const toBlock = newBlock;
	    const fromBlock = incrementHexInt$2(oldBlock);
	    const blockBodies = await getBlocksForRange$2({ provider: this.provider, fromBlock, toBlock });
	    const blockHashes = blockBodies.map((block) => block.hash);
	    this.addResults(blockHashes);
	  }

	};

	var blockFilter = BlockFilter$1;

	const BaseFilter = baseFilter;
	const getBlocksForRange$1 = getBlocksForRange_1;
	const { incrementHexInt: incrementHexInt$1 } = hexUtils;

	let TxFilter$1 = class TxFilter extends BaseFilter {

	  constructor ({ provider }) {
	    super();
	    this.type = 'tx';
	    this.provider = provider;
	  }

	  async update ({ oldBlock }) {
	    const toBlock = oldBlock;
	    const fromBlock = incrementHexInt$1(oldBlock);
	    const blocks = await getBlocksForRange$1({ provider: this.provider, fromBlock, toBlock });
	    const blockTxHashes = [];
	    for (const block of blocks) {
	      blockTxHashes.push(...block.transactions);
	    }
	    // add to results
	    this.addResults(blockTxHashes);
	  }

	};

	var txFilter = TxFilter$1;

	const Mutex = lib.Mutex;
	const { createAsyncMiddleware: createAsyncMiddleware$1 } = dist$2;
	const createJsonRpcMiddleware = scaffold.exports;
	const LogFilter = logFilter;
	const BlockFilter = blockFilter;
	const TxFilter = txFilter;
	const { intToHex, hexToInt } = hexUtils;

	var ethJsonRpcFilters = createEthFilterMiddleware;

	function createEthFilterMiddleware({ blockTracker, provider }) {

	  // create filter collection
	  let filterIndex = 0;
	  let filters = {};
	  // create update mutex
	  const mutex = new Mutex();
	  const waitForFree = mutexMiddlewareWrapper({ mutex });

	  const middleware = createJsonRpcMiddleware({
	    // install filters
	    eth_newFilter:                   waitForFree(toFilterCreationMiddleware(newLogFilter)),
	    eth_newBlockFilter:              waitForFree(toFilterCreationMiddleware(newBlockFilter)),
	    eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
	    // uninstall filters
	    eth_uninstallFilter:             waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
	    // checking filter changes
	    eth_getFilterChanges:            waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
	    eth_getFilterLogs:               waitForFree(toAsyncRpcMiddleware(getFilterLogs)),
	  });

	  // setup filter updating and destroy handler
	  const filterUpdater = async ({ oldBlock, newBlock }) => {
	    if (filters.length === 0) return
	    // lock update reads
	    const releaseLock = await mutex.acquire();
	    try {
	      // process all filters in parallel
	      await Promise.all(objValues(filters).map(async (filter) => {
	        try {
	         await filter.update({ oldBlock, newBlock });
	        } catch (err) {
	          // handle each error individually so filter update errors don't affect other filters
	          console.error(err);
	        }
	      }));
	    } catch (err) {
	      // log error so we don't skip the releaseLock
	      console.error(err);
	    }
	    // unlock update reads
	    releaseLock();
	  };

	  // expose filter methods directly
	  middleware.newLogFilter = newLogFilter;
	  middleware.newBlockFilter = newBlockFilter;
	  middleware.newPendingTransactionFilter = newPendingTransactionFilter;
	  middleware.uninstallFilter = uninstallFilterHandler;
	  middleware.getFilterChanges = getFilterChanges;
	  middleware.getFilterLogs = getFilterLogs;

	  // expose destroy method for cleanup
	  middleware.destroy = () => {
	    uninstallAllFilters();
	  };

	  return middleware

	  //
	  // new filters
	  //

	  async function newLogFilter(params) {
	    const filter = new LogFilter({ provider, params });
	    await installFilter(filter);
	    return filter
	  }

	  async function newBlockFilter() {
	    const filter = new BlockFilter({ provider });
	    await installFilter(filter);
	    return filter
	  }

	  async function newPendingTransactionFilter() {
	    const filter = new TxFilter({ provider });
	    await installFilter(filter);
	    return filter
	  }

	  //
	  // get filter changes
	  //

	  async function getFilterChanges(filterIndexHex) {
	    const filterIndex = hexToInt(filterIndexHex);
	    const filter = filters[filterIndex];
	    if (!filter) {
	      throw new Error(`No filter for index "${filterIndex}"`)
	    }
	    const results = filter.getChangesAndClear();
	    return results
	  }

	  async function getFilterLogs(filterIndexHex) {
	    const filterIndex = hexToInt(filterIndexHex);
	    const filter = filters[filterIndex];
	    if (!filter) {
	      throw new Error(`No filter for index "${filterIndex}"`)
	    }
	    // only return results for log filters
	    if (filter.type === 'log') {
	      results = filter.getAllResults();
	    } else {
	      results = [];
	    }
	    return results
	  }


	  //
	  // remove filters
	  //


	  async function uninstallFilterHandler(filterIndexHex) {
	    // check filter exists
	    const filterIndex = hexToInt(filterIndexHex);
	    const filter = filters[filterIndex];
	    const result = Boolean(filter);
	    // uninstall filter
	    if (result) {
	      await uninstallFilter(filterIndex);
	    }
	    return result
	  }

	  //
	  // utils
	  //

	  async function installFilter(filter) {
	    const prevFilterCount = objValues(filters).length;
	    // install filter
	    const currentBlock = await blockTracker.getLatestBlock();
	    await filter.initialize({ currentBlock });
	    filterIndex++;
	    filters[filterIndex] = filter;
	    filter.id = filterIndex;
	    filter.idHex = intToHex(filterIndex);
	    // update block tracker subs
	    const newFilterCount = objValues(filters).length;
	    updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
	    return filterIndex
	  }

	  async function uninstallFilter(filterIndex) {
	    const prevFilterCount = objValues(filters).length;
	    delete filters[filterIndex];
	    // update block tracker subs
	    const newFilterCount = objValues(filters).length;
	    updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
	  }

	  async function uninstallAllFilters() {
	    const prevFilterCount = objValues(filters).length;
	    filters = {};
	    // update block tracker subs
	    updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
	  }

	  function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
	    // subscribe
	    if (prevFilterCount === 0 && newFilterCount > 0) {
	      blockTracker.on('sync', filterUpdater);
	      return
	    }
	    // unsubscribe
	    if (prevFilterCount > 0 && newFilterCount === 0) {
	      blockTracker.removeListener('sync', filterUpdater);
	      return
	    }
	  }

	}

	// helper for turning filter constructors into rpc middleware
	function toFilterCreationMiddleware(createFilterFn) {
	  return toAsyncRpcMiddleware(async (...args) => {
	    const filter = await createFilterFn(...args);
	    const result = intToHex(filter.id);
	    return result
	  })
	}

	// helper for pulling out req.params and setting res.result
	function toAsyncRpcMiddleware(asyncFn) {
	  return createAsyncMiddleware$1(async (req, res) => {
	    const result = await asyncFn.apply(null, req.params);
	    res.result = result;
	  })
	}

	function mutexMiddlewareWrapper({ mutex }) {
	  return (middleware) => {
	    return async (req, res, next, end) => {
	      // wait for mutex available
	      // we can release immediately because
	      // we just need to make sure updates aren't active
	      const releaseLock = await mutex.acquire();
	      releaseLock();
	      middleware(req, res, next, end);
	    }
	  }
	}

	function objValues(obj, fn){
	  const values = [];
	  for (let key in obj) {
	    values.push(obj[key]);
	  }
	  return values
	}

	const createFilterMiddleware$1 = () => createLegacyMiddleware(({ blockTracker, provider, context }) => {
	    const middleware = ethJsonRpcFilters({
	        blockTracker,
	        provider,
	    });
	    context.addDestructor(middleware.destroy);
	    return middleware;
	});

	const DEFAULT_FIXTURES = {
	    [ethProviderTypes.EthMethod.web3_clientVersion]: 'Bitski/latest',
	    [ethProviderTypes.EthMethod.net_listening]: true,
	    [ethProviderTypes.EthMethod.eth_hashrate]: '0x00',
	    [ethProviderTypes.EthMethod.eth_mining]: false,
	};
	const createFixtureMiddleware = (fixtures = DEFAULT_FIXTURES) => {
	    return (req, res, next, end) => {
	        const fixture = fixtures[req.method];
	        if (fixture !== undefined) {
	            res.result = fixture;
	            return end();
	        }
	        else {
	            next();
	        }
	    };
	};

	const createSignatureMiddleware = () => {
	    return dist$2.createAsyncMiddleware(async (req, res, next) => {
	        if (!SIGN_METHODS.includes(req.method)) {
	            return next();
	        }
	        const context = getRequestContext(req);
	        const requiresLocalSend = !SUPPORTED_CHAIN_IDS.includes(context.chain.chainId) &&
	            req.method === ethProviderTypes.EthMethod.eth_sendTransaction;
	        // When we don't support a chain on the server (e.g. custom RPC url), we need
	        // to sign the transaction via our flow, then send the signed payload locally
	        const method = requiresLocalSend
	            ? ethProviderTypes.EthMethod.eth_signTransaction
	            : req.method;
	        const signedResponse = await context.config.sign(method, req.params, context);
	        res.result = requiresLocalSend
	            ? context.request({ method: ethProviderTypes.EthMethod.eth_sendRawTransaction, params: [signedResponse] })
	            : signedResponse;
	    });
	};

	const SafeEventEmitter = safeEventEmitter.default;
	const createScaffoldMiddleware = scaffold.exports;
	const { createAsyncMiddleware } = dist$2;
	const createFilterMiddleware = ethJsonRpcFilters;
	const { unsafeRandomBytes, incrementHexInt } = hexUtils;
	const getBlocksForRange = getBlocksForRange_1;

	var subscriptionManager = createSubscriptionMiddleware$1;


	function createSubscriptionMiddleware$1({ blockTracker, provider }) {
	  // state and utilities for handling subscriptions
	  const subscriptions = {};
	  const filterManager = createFilterMiddleware({ blockTracker, provider });

	  // internal flag
	  let isDestroyed = false;

	  // create subscriptionManager api object
	  const events = new SafeEventEmitter();
	  const middleware = createScaffoldMiddleware({
	    eth_subscribe: createAsyncMiddleware(subscribe),
	    eth_unsubscribe: createAsyncMiddleware(unsubscribe),
	  });
	  middleware.destroy = destroy;
	  return { events, middleware }

	  async function subscribe(req, res) {

	    if (isDestroyed) throw new Error(
	      'SubscriptionManager - attempting to use after destroying'
	    )

	    const subscriptionType = req.params[0];
	    // subId is 16 byte hex string
	    const subId = unsafeRandomBytes(16);

	    // create sub
	    let sub;
	    switch (subscriptionType) {
	      case 'newHeads':
	        sub = createSubNewHeads({ subId });
	        break
	      case 'logs':
	        const filterParams = req.params[1];
	        const filter = await filterManager.newLogFilter(filterParams);
	        sub = createSubFromFilter({ subId, filter });
	        break
	      default:
	        throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`)

	    }
	    subscriptions[subId] = sub;

	    res.result = subId;
	    return

	    function createSubNewHeads({ subId }) {
	      const sub = {
	        type: subscriptionType,
	        destroy: async () => {
	          blockTracker.removeListener('sync', sub.update);
	        },
	        update: async ({ oldBlock, newBlock }) => {
	          // for newHeads
	          const toBlock = newBlock;
	          const fromBlock = incrementHexInt(oldBlock);
	          const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
	          const results = rawBlocks.map(normalizeBlock);
	          results.forEach((value) => {
	            _emitSubscriptionResult(subId, value);
	          });
	        }
	      };
	      // check for subscription updates on new block
	      blockTracker.on('sync', sub.update);
	      return sub
	    }

	    function createSubFromFilter({ subId, filter }){
	      filter.on('update', result => _emitSubscriptionResult(subId, result));
	      const sub = {
	        type: subscriptionType,
	        destroy: async () => {
	          return await filterManager.uninstallFilter(filter.idHex)
	        },
	      };
	      return sub
	    }
	  }

	  async function unsubscribe(req, res) {

	    if (isDestroyed) throw new Error(
	      'SubscriptionManager - attempting to use after destroying'
	    )

	    const id = req.params[0];
	    const subscription = subscriptions[id];
	    // if missing, return "false" to indicate it was not removed
	    if (!subscription) {
	      res.result = false;
	      return
	    }
	    // cleanup subscription
	    delete subscriptions[id];
	    await subscription.destroy();
	    res.result = true;
	  }

	  function _emitSubscriptionResult(filterIdHex, value) {
	    events.emit('notification', {
	      jsonrpc: '2.0',
	      method: 'eth_subscription',
	      params: {
	        subscription: filterIdHex,
	        result: value,
	      },
	    });
	  }

	  function destroy () {
	    events.removeAllListeners();
	    for (const id in subscriptions) {
	      subscriptions[id].destroy();
	      delete subscriptions[id];
	    }
	    isDestroyed = true;
	  }
	}

	function normalizeBlock(block) {
	  return {
	    hash: block.hash,
	    parentHash: block.parentHash,
	    sha3Uncles: block.sha3Uncles,
	    miner: block.miner,
	    stateRoot: block.stateRoot,
	    transactionsRoot: block.transactionsRoot,
	    receiptsRoot: block.receiptsRoot,
	    logsBloom: block.logsBloom,
	    difficulty: block.difficulty,
	    number: block.number,
	    gasLimit: block.gasLimit,
	    gasUsed: block.gasUsed,
	    nonce: block.nonce,
	    mixHash: block.mixHash,
	    timestamp: block.timestamp,
	    extraData: block.extraData,
	  }
	}

	const createSubscriptionMiddleware = () => createLegacyMiddleware(({ blockTracker, provider, context }) => {
	    const manager = subscriptionManager({ blockTracker, provider });
	    manager.events.on('notification', (notification) => {
	        const data = Object.assign(Object.assign({}, notification.params), { subscription: `${context.chain.chainId}:${notification.params.subscription}` });
	        context.emit(ethProviderTypes.EthEvent.message, {
	            type: ethProviderTypes.EthProviderMessageType.eth_subscription,
	            data,
	        });
	        context.emit(ethProviderTypes.EthEvent.data, null, { params: data });
	    });
	    context.addDestructor(manager.middleware.destroy);
	    return manager.middleware;
	});

	const createTransactionValidatorMiddleware = () => {
	    return dist$2.createAsyncMiddleware(async (req, _res, next) => {
	        if (req.method === ethProviderTypes.EthMethod.eth_sendTransaction ||
	            req.method === ethProviderTypes.EthMethod.eth_signTransaction) {
	            const [transaction] = expect(req.params, `${req.method} request missing required parameters`);
	            const context = getRequestContext(req);
	            if (transaction.from === undefined) {
	                const accounts = await context.request({ method: ethProviderTypes.EthMethod.eth_accounts });
	                transaction.from = accounts[0];
	            }
	        }
	        next();
	    });
	};

	const createTypedDataSanitizerMiddleware = () => {
	    return (req, _res, next, end) => {
	        if (req.method === ethProviderTypes.EthMethod.eth_signTypedData ||
	            req.method === ethProviderTypes.EthMethod.eth_signTypedData_v1 ||
	            req.method === ethProviderTypes.EthMethod.eth_signTypedData_v3 ||
	            req.method === ethProviderTypes.EthMethod.eth_signTypedData_v4) {
	            try {
	                sanitizeRequest(req);
	            }
	            catch (err) {
	                return end(err);
	            }
	        }
	        next();
	    };
	};
	const sanitizeRequest = (payload) => {
	    const { params } = payload;
	    if (!params || params.length < 2) {
	        throw dist$3.ethErrors.provider.userRejectedRequest(`Missing params for ${payload.method}. The first parameter should be the address of the account to sign with, and the second parameter should be the data to sign.`);
	    }
	    const typedData = extractTypedData(params);
	    // create map of types
	    const typeMapping = createTypeMapping(typedData);
	    // sanitize domain if available
	    if (typedData.domain || typedData.types.EIP712Domain) {
	        sanitizeDomain(typedData, typeMapping);
	    }
	    // sanitize message
	    sanitizeMessage(typedData, typeMapping);
	    // Re-assign typed data to params in case it has been parsed
	    // from a string.
	    params[1] = typedData;
	};
	const extractTypedData = (params) => {
	    // Some implementations pass typed data as a string
	    if (typeof params[1] === 'string') {
	        return JSON.parse(params[1]);
	    }
	    return params[1];
	};
	/**
	 * Sanitizes the `domain` values from the TypedData
	 *
	 * @param typedData TypedData payload
	 * @param typeMapping a TypeMapping pre-generated from the TypedData
	 */
	const sanitizeDomain = (typedData, typeMapping) => {
	    if (typeof typedData.domain === 'undefined') {
	        throw dist$3.ethErrors.provider.userRejectedRequest('Missing domain for typed data');
	    }
	    sanitizeType('EIP712Domain', typedData.domain, typeMapping);
	};
	/**
	 * Sanitizes the `message` values from the TypedData
	 *
	 * @param typedData TypedData payload
	 * @param typeMapping a TypeMapping pre-generated from the TypedData
	 */
	const sanitizeMessage = (typedData, typeMapping) => {
	    if (typeof typedData.message === 'undefined') {
	        throw dist$3.ethErrors.provider.userRejectedRequest('Missing message in typed data');
	    }
	    if (typeof typedData.primaryType !== 'string') {
	        throw dist$3.ethErrors.provider.userRejectedRequest('Missing primary type in typed data');
	    }
	    sanitizeType(typedData.primaryType, typedData.message, typeMapping);
	};
	/**
	 * Recursively examines each value and determines type from the type mapping to
	 * format and sanitize the value if needed.
	 *
	 * Currently this will only convert number values into a consistent hex format,
	 * but in the future additional transformations may be necessary.
	 *
	 * @param typeName Name of the type we are starting from
	 * @param values The root object containing the keys and values
	 * @param typeMapping The type mapping that represents this data
	 */
	// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
	const sanitizeType = (typeName, values, typeMapping) => {
	    // For each key in the 'values' object...
	    Object.keys(values).forEach((key) => {
	        // Find the type name associated from the mapping
	        const type = typeMapping[typeName][key];
	        if (type === undefined) ;
	        else if (isArray(type)) {
	            // find the base type (left side of the brackets)
	            const baseType = type.split('[')[0];
	            if (typeof values[key].length === 'undefined') {
	                throw new TypeError(`Could not parse ${values[key]} for type ${type}. Expected array.`);
	            }
	            // If base type is a struct, iterate through each instance of struct
	            if (typeMapping[baseType]) {
	                // values[key] is expected to be an array, where each element
	                // is an object that represents the struct named baseType.
	                values[key].forEach((itemValues) => {
	                    sanitizeType(baseType, itemValues, typeMapping);
	                });
	            }
	            else if (baseType.startsWith('uint') || baseType.startsWith('int')) {
	                // If we have an array of primitive types that are numbers, we need to encode the numbers as hex
	                const numberValues = values[key].map((numberValue) => {
	                    return encodeNumber(numberValue, baseType, true);
	                });
	                values[key] = numberValues;
	            }
	            else ;
	        }
	        else if (typeMapping[type]) {
	            // If type name is a custom struct, it should live in the type mapping
	            // We need to recursively check the custom types until we get to primitive values
	            sanitizeType(type, values[key], typeMapping);
	        }
	        else if (type.startsWith('uint') || type.startsWith('int')) {
	            // Finally, if we have a primitive type that is a number, we need to encode the numbers as hex
	            values[key] = encodeNumber(values[key], type, true);
	        }
	    });
	};
	/**
	 * Returns true if type name indicates that an array
	 * @param typeName solidity type name
	 */
	function isArray(typeName) {
	    if (typeName.includes('[') && typeName.includes(']')) {
	        return true;
	    }
	    return false;
	}
	/**
	 * Maps the type definitions from the typed data for easy look-up.
	 * Top level keys represent the structs defined, while top-level values
	 * are an object keyed by property with string values of the type name.
	 *
	 * For example:
	 * {
	 *    EIP712Domain: {
	 *      name: 'string',
	 *      version: 'string',
	 *      chainId: 'uint256'
	 *    }
	 * }
	 * @param typedData The TypedData to map
	 * @returns {TypeMapping} the mapped data schema
	 */
	function createTypeMapping(typedData) {
	    if (typeof typedData.types === 'undefined') {
	        throw dist$3.ethErrors.provider.userRejectedRequest('Missing type definitions for typed data');
	    }
	    // Go through each of the top level keys. These represent the custom types.
	    return Object.keys(typedData.types).reduce((acc, current) => {
	        // Reduce into a new single object
	        // Set a key for each type, reduce array of property names and types to an object
	        acc[current] = typedData.types[current].reduce((acc2, typeDef) => {
	            // For each type, set the key as the property name, and the value as the type name
	            acc2[typeDef.name] = typeDef.type;
	            return acc2;
	        }, {});
	        return acc;
	    }, {});
	}

	/* tslint:disable */
	const css$1 = `
#bitski-dialog-container {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0);
  z-index: 1000;
  transition: background linear 0.2s;
  pointer-events: none;
}
#bitski-dialog-container.bitski-visible {
  background: rgba(0, 0, 0, 0.5);
  pointer-events: auto;
}
.bitski-dialog {
  opacity: 0;
  transform: translateY(100vh);
  transition: opacity 300ms linear, transform 400ms cubic-bezier(0.19, 1, 0.22, 1);
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
#bitski-dialog-container.bitski-visible .bitski-dialog {
  opacity: 1;
  transform: none;
  transition: opacity 300ms linear, transform 600ms cubic-bezier(0.19, 1, 0.22, 1);
  pointer-events: auto;
}
.bitski-dialog .bitski-close-button {
  background: transparent url('https://cdn.bitskistatic.com/sdk/close.svg') no-repeat 50% 50%;
  position: absolute;
  right: 12px;
  top: 12px;
  border: none;
  outline: none;
  margin: 0;
  cursor: pointer;
  padding: 0;
  width: 28px;
  height: 28px;
  z-index: 100;
  overflow: hidden;
  text-indent: -1000px;
}
.bitski-dialog-body {
  background: #fff;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 5;
  max-width: 100%;
}
.bitski-dialog-body.bitski-loading::after {
  content: "";
  background: url('https://cdn.bitskistatic.com/sdk/loading.svg') no-repeat 50% 50%;
  animation: rotate 600ms linear infinite;
  position: absolute;
  top: 50%;
  left: 50%;
  opacity: 0.3;
  width: 38px;
  height: 38px;
  margin-left: -19px;
  margin-top: -19px;
  z-index: -1;
}
@media (min-width: 600px) {
  #bitski-dialog-container {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .bitski-dialog {
    position: relative;
    width: 400px;
    height: 420px;
  }
  .bitski-dialog-body {
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0px 0px 0px 1px rgba(0,0,0,0.1), 0px 10px 50px rgba(0,0,0,0.4);
  }
}

@keyframes rotate {
  0% {
    transform: rotate(0deg);
  }
  50% {
    transform: rotate(180deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
`;

	const TEMPLATE = `
  <div class='bitski-dialog'>
      <button class='bitski-close-button'>Close</button>
      <div class='bitski-dialog-body'></div>
  </div>
`;
	/**
	 * Embeds Bitski's dialog styles
	 */
	const injectStyles = () => {
	    if (document.getElementById('BitskiSDKEmbeddedStyles')) {
	        return;
	    }
	    const style = document.createElement('style');
	    style.setAttribute('type', 'text/css');
	    style.setAttribute('id', 'BitskiSDKEmbeddedStyles');
	    style.appendChild(document.createTextNode(css$1));
	    const head = document.head || document.getElementsByTagName('head')[0];
	    head.appendChild(style);
	};
	/**
	 * Basic modal dialog
	 */
	class Dialog {
	    /**
	     * Creates and displays a new dialog
	     * @param content The content (HTMLElement, selector, or text) to embed in the dialog
	     * @param dynamicContent Set to true to show loading state
	     */
	    constructor(content, dynamicContent = false) {
	        // check for an element passed as content or a selector corresponding to an element
	        this.content = this.parseContent(content);
	        // Find or create dialog container
	        this.container = this.createContainer();
	        injectStyles();
	        // Inject dialog content
	        this.injectTemplate(this.container, this.content);
	        // Show a spinner if content is dynamic
	        if (dynamicContent) {
	            this.setLoading(true);
	        }
	        // Add close handlers
	        this.addCloseHandlers();
	        // A short delay is required before triggering animations
	        setTimeout(() => {
	            this.show();
	        }, 10);
	    }
	    /**
	     * Show the dialog
	     */
	    show() {
	        this.container.classList.add('bitski-visible', 'bitski-loaded');
	    }
	    /**
	     * Hides the dialog, but does not remove
	     */
	    hide() {
	        this.container.classList.remove('bitski-visible', 'bitski-loaded');
	    }
	    /**
	     * Dismisses the dialog without triggering the close handler.
	     */
	    close() {
	        // Allow 500ms for the animations to finish before removing elements from DOM
	        setTimeout(() => {
	            this.container.remove();
	        }, 500);
	        this.hide();
	    }
	    /**
	     * Show or hide the loading indicator
	     * @param loading Whether or not to display the spinner
	     */
	    setLoading(loading) {
	        const body = document.querySelector('.bitski-dialog-body');
	        if (body) {
	            if (loading) {
	                body.classList.add('bitski-loading');
	            }
	            else {
	                body.classList.remove('bitski-loading');
	            }
	        }
	    }
	    /**
	     * Determines what content to embed
	     * @param content Content to parse
	     */
	    parseContent(content) {
	        // check for an element passed as content
	        if (content instanceof HTMLElement) {
	            return content;
	        }
	        // determine if content is a selector
	        if (document.querySelector(content)) {
	            return document.querySelector(content);
	        }
	        // otherwise content is text to be appended to the dialog body
	        const div = document.createElement('div');
	        div.innerText = content;
	        return div;
	    }
	    /**
	     * Creates and injects the container element at the end of the body,
	     * responsible for housing all the dialog-related content.
	     */
	    createContainer() {
	        const existingContainer = document.querySelector('#bitski-dialog-container');
	        if (existingContainer) {
	            return existingContainer;
	        }
	        const container = document.createElement('div');
	        container.id = 'bitski-dialog-container';
	        document.body.appendChild(container);
	        return container;
	    }
	    /**
	     * Injects the provided content into the template provided
	     * @param container The container element
	     * @param content The content to inject in the template
	     */
	    injectTemplate(container, content) {
	        container.innerHTML = TEMPLATE;
	        const body = container.querySelector('.bitski-dialog-body');
	        if (body) {
	            body.appendChild(content);
	        }
	    }
	    /**
	     * Adds event listeners for events that should trigger closing the dialog
	     */
	    addCloseHandlers() {
	        // Close on click outside of the dialog
	        this.container.addEventListener('click', (event) => {
	            if (event.target === this.container) {
	                this.close();
	            }
	        });
	        // Close on escape press
	        document.addEventListener('keyup', (e) => {
	            if (e.key === 'Escape') {
	                this.close();
	            }
	        });
	        // Close on close button click
	        const closeButton = this.container.querySelector('.bitski-close-button');
	        if (closeButton) {
	            closeButton.addEventListener('click', this.close.bind(this));
	        }
	    }
	}

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	let getRandomValues;
	const rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }

	  return getRandomValues(rnds8);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	const byteToHex = [];

	for (let i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).slice(1));
	}

	function unsafeStringify(arr, offset = 0) {
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
	}

	const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
	var native = {
	  randomUUID
	};

	function v4(options, buf, offset) {
	  if (native.randomUUID && !buf && !options) {
	    return native.randomUUID();
	  }

	  options = options || {};
	  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;

	    for (let i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }

	    return buf;
	  }

	  return unsafeStringify(rnds);
	}

	/**
	 * Responsible for creating the Transaction object from a given RPC payload
	 * @param req JSON-RPC payload to extract the values from
	 */
	const createBitskiTransaction = (method, params, chain, additionalContext) => {
	    const context = createContext(method, params, chain, additionalContext);
	    const kind = kindForMethod(method);
	    const extractedPayload = createPayload(method, params);
	    return {
	        id: v4(),
	        kind,
	        payload: extractedPayload,
	        context,
	    };
	};
	const createContext = (method, params, chain, additionalContext) => {
	    switch (method) {
	        case 'personal_sign':
	        case ethProviderTypes.EthMethod.eth_sign:
	        case ethProviderTypes.EthMethod.eth_sendTransaction:
	        case ethProviderTypes.EthMethod.eth_signTransaction: {
	            return Object.assign({ chainId: parseInt(chain.chainId, 16), rpcUrl: !SUPPORTED_CHAIN_IDS.includes(chain.chainId) ? chain.rpcUrls[0] : undefined }, additionalContext);
	        }
	        case ethProviderTypes.EthMethod.eth_signTypedData:
	        case ethProviderTypes.EthMethod.eth_signTypedData_v1:
	        case ethProviderTypes.EthMethod.eth_signTypedData_v3:
	        case ethProviderTypes.EthMethod.eth_signTypedData_v4:
	            // The from address should be the first parameter as a 20 byte hex string
	            if (params && (params === null || params === void 0 ? void 0 : params.length) > 0) {
	                return Object.assign({ from: params[0], chainId: parseInt(chain.chainId, 16), rpcUrl: !SUPPORTED_CHAIN_IDS.includes(chain.chainId) ? chain.rpcUrls[0] : undefined }, additionalContext);
	            }
	            throw dist$3.ethErrors.rpc.invalidParams('Missing from');
	        default:
	            throw dist$3.ethErrors.rpc.internal('Unsupported method');
	    }
	};
	/**
	 * Responsible for creating the payload from a given RPC request
	 * @param req JSON-RPC request to extract params from
	 */
	const createPayload = (method, params) => {
	    switch (method) {
	        case ethProviderTypes.EthMethod.eth_sendTransaction:
	        case ethProviderTypes.EthMethod.eth_signTransaction:
	            if (params && params.length > 0) {
	                return params[0];
	            }
	            else {
	                throw dist$3.ethErrors.rpc.invalidParams('Missing transaction');
	            }
	        case ethProviderTypes.EthMethod.eth_sign:
	            if (params && params.length > 1) {
	                return { from: params[0], message: params[1] };
	            }
	            else {
	                throw dist$3.ethErrors.rpc.invalidParams('Missing message');
	            }
	        case 'personal_sign':
	            if (params && params.length > 1) {
	                // If the first param is a wallet address, flip the parameter ordering for personal_sign
	                // so that it matches eth_sign. This is to gracefully respect Dapps who adopted Metamask's
	                // API for personal_sign early, and recover from the wrong param order
	                // when it is clearly identifiable.
	                const [first, second] = params;
	                if (first.startsWith('0x') && first.length === 42) {
	                    return { from: first, message: second };
	                }
	                return { from: second, message: first };
	            }
	            else {
	                throw dist$3.ethErrors.rpc.invalidParams('Missing message');
	            }
	        case ethProviderTypes.EthMethod.eth_signTypedData:
	        case ethProviderTypes.EthMethod.eth_signTypedData_v1:
	        case ethProviderTypes.EthMethod.eth_signTypedData_v3:
	        case ethProviderTypes.EthMethod.eth_signTypedData_v4:
	            if (params && params.length > 1) {
	                return params[1];
	            }
	            else {
	                throw dist$3.ethErrors.rpc.invalidParams('Missing typed data');
	            }
	        default:
	            throw dist$3.ethErrors.rpc.internal('Unsupported method');
	    }
	};
	/**
	 * Determines a BitskiTransaction.Kind value from a given RPC method name
	 * @param method The JSON-RPC method being requested
	 */
	const kindForMethod = (method) => {
	    switch (method) {
	        case ethProviderTypes.EthMethod.eth_sendTransaction:
	            return "ETH_SEND_TRANSACTION" /* SendTransaction */;
	        case ethProviderTypes.EthMethod.eth_signTransaction:
	            return "ETH_SIGN_TRANSACTION" /* SignTransaction */;
	        case ethProviderTypes.EthMethod.eth_sign:
	        case 'personal_sign':
	            return "ETH_SIGN" /* Sign */;
	        case ethProviderTypes.EthMethod.eth_signTypedData:
	            return "ETH_SIGN_TYPED_DATA" /* SignTypedData */;
	        case ethProviderTypes.EthMethod.eth_signTypedData_v1:
	            return "ETH_SIGN_TYPED_DATA_V1" /* SignTypedDataV1 */;
	        case ethProviderTypes.EthMethod.eth_signTypedData_v3:
	            return "ETH_SIGN_TYPED_DATA_V3" /* SignTypedDataV3 */;
	        case ethProviderTypes.EthMethod.eth_signTypedData_v4:
	            return "ETH_SIGN_TYPED_DATA_V4" /* SignTypedDataV4 */;
	        default:
	            throw dist$3.ethErrors.rpc.internal('Unsupported method');
	    }
	};

	// Global state, this manages the currently open signer popup. There should never
	// be more than one, so it's ok for this to be module scoped.
	let currentRequestDialog;
	let currentRequest;
	if (typeof window !== 'undefined') {
	    window.addEventListener('message', (event) => {
	        // Ignore messages from the current window, and from frames that aren't on Bitski.com
	        if (event.source === window || !event.origin.endsWith(IFRAME_MESSAGE_ORIGIN_ENDS_WITH)) {
	            return;
	        }
	        const data = event.data;
	        // Ignore message events that don't actually have data
	        if (data === undefined || data === null) {
	            return;
	        }
	        handleCallback(data);
	    });
	}
	/**
	 * Responsible for submitting the Transaction object to the API
	 * @param transaction The Transaction object to submit
	 * @param accessToken The current user's access token
	 */
	const submitTransaction = async (transaction, config) => {
	    const headers = Object.assign({}, config.additionalHeaders);
	    if (config.getAccessToken) {
	        headers['Authorization'] = `Bearer ${await config.getAccessToken()}`;
	    }
	    const response = (await fetchJsonWithRetry(config.fetch, 5, `${config.apiBaseUrl}/transactions`, {
	        method: 'POST',
	        body: { transaction },
	        headers,
	    }));
	    return response.transaction;
	};
	const redirectToCallbackURL = (transaction, config) => {
	    const url = `${config.signerBaseUrl}/transactions/${transaction.id}?redirectURI=${config.transactionCallbackUrl}`;
	    window.location.href = url;
	    // return a non-resolving promise so we block until redirect
	    // eslint-disable-next-line @typescript-eslint/no-empty-function
	    return new Promise(() => { });
	};
	const showIframe = (transaction, context) => {
	    return new Promise((fulfill, reject) => {
	        const url = `${context.config.signerBaseUrl}/transactions/${transaction.id}`;
	        const iframe = document.createElement('iframe');
	        iframe.style.position = 'absolute';
	        iframe.style.top = '0';
	        iframe.style.left = '0';
	        iframe.style.width = '100%';
	        iframe.style.height = '100%';
	        iframe.frameBorder = '0';
	        iframe.src = url;
	        // Dismiss any existing dialogs to prevent UI glitches.
	        if (currentRequestDialog && currentRequest) {
	            currentRequestDialog.close();
	            const [, reject] = currentRequest;
	            reject(dist$3.ethErrors.provider.userRejectedRequest('Another signing request was made before this one was completed'));
	        }
	        currentRequest = [fulfill, reject];
	        currentRequestDialog = new Dialog(iframe, true);
	    });
	};
	const handleCallback = (callback) => {
	    // Ignore messages when we don't have a current request in flight
	    if (currentRequest === undefined) {
	        return;
	    }
	    const [fulfill, reject] = currentRequest;
	    // Dismiss current dialog
	    if (currentRequestDialog) {
	        currentRequestDialog.close();
	    }
	    // Clear state
	    currentRequest = undefined;
	    currentRequestDialog = undefined;
	    // Call the callback to complete the request
	    if (callback.error) {
	        reject(dist$3.ethErrors.rpc.internal(callback.error));
	    }
	    else {
	        fulfill(callback.result);
	    }
	};
	function createBrowserSigner(signerConfig) {
	    var _a;
	    const showPopup = (_a = signerConfig === null || signerConfig === void 0 ? void 0 : signerConfig.showPopup) !== null && _a !== void 0 ? _a : showIframe;
	    return async (method, params, requestContext) => {
	        const { config } = requestContext;
	        const transaction = await createBitskiTransaction(method, params, requestContext.chain, requestContext.config.additionalSigningContext);
	        // If we have a callback URL, use the redirect flow
	        if (config.transactionCallbackUrl) {
	            const persisted = await submitTransaction(transaction, config);
	            return redirectToCallbackURL(persisted, config);
	        }
	        else {
	            // We can submit the transaction and show our authorization modal at the
	            // same time, so they load in parallel
	            submitTransaction(transaction, config).catch((error) => handleCallback({ error }));
	            // Show the modal (await response)
	            return showPopup(transaction, requestContext);
	        }
	    };
	}

	// Some eth methods result in a subscription being created, and return the id of that subscription.
	// We need to keep track of the subscription id and the chain id it was created on, so we can
	// call future methods to interact with or unsubscribe from the subscription.
	const SUB_METHODS = new Set([
	    ethProviderTypes.EthMethod.eth_subscribe,
	    ethProviderTypes.EthMethod.eth_newFilter,
	    ethProviderTypes.EthMethod.eth_newBlockFilter,
	    ethProviderTypes.EthMethod.eth_newPendingTransactionFilter,
	]);
	const SUB_INTERACTION_METHODS = new Set([
	    ethProviderTypes.EthMethod.eth_getFilterChanges,
	    ethProviderTypes.EthMethod.eth_getFilterLogs,
	]);
	const UNSUB_METHODS = new Set([ethProviderTypes.EthMethod.eth_unsubscribe, ethProviderTypes.EthMethod.eth_uninstallFilter]);
	class BitskiProvider {
	    constructor(config) {
	        var _a, _b, _c, _d, _e, _f, _g;
	        this.engine = new dist$2.JsonRpcEngine();
	        this.events = new _default();
	        this.destructors = [];
	        this.requestId = 0;
	        this.didEmitConnect = false;
	        this.activeSubs = new Set();
	        this.config = Object.assign(Object.assign({}, config), { fetch: (_a = config.fetch) !== null && _a !== void 0 ? _a : fetch, additionalHeaders: Object.assign({ 'X-API-KEY': config.clientId, 'X-CLIENT-ID': config.clientId, 'X-CLIENT-VERSION': "bitski-provider-v2.0.0" }, ((_b = config.additionalHeaders) !== null && _b !== void 0 ? _b : {})), apiBaseUrl: (_c = config.apiBaseUrl) !== null && _c !== void 0 ? _c : BITSKI_API_BASE_URL, signerBaseUrl: (_d = config.signerBaseUrl) !== null && _d !== void 0 ? _d : BITSKI_SIGNER_BASE_URL, store: (_e = config.store) !== null && _e !== void 0 ? _e : new LocalStorageStore(), sign: (_f = config.sign) !== null && _f !== void 0 ? _f : createBrowserSigner() });
	        this.store = new BitskiProviderStateStore(this.config.store);
	        // Setup the engine
	        const engine = this.engine;
	        (_g = config.prependMiddleware) === null || _g === void 0 ? void 0 : _g.forEach((middleware) => 
	        // TODO: Need to typecast because JSON RPC engine middleware can't have
	        // additional props on it, can get rid of this once we get rid of JSON RPC engine
	        engine.push(dist$2.createAsyncMiddleware(middleware)));
	        // Handles static responses
	        engine.push(createFixtureMiddleware());
	        engine.push(createChainManagementMiddleware());
	        if (!config.disableValidation) {
	            // Ensures that transactions are well formed (nonce, gas, gasPrice, from) before they are sent to Bitski
	            engine.push(createTypedDataSanitizerMiddleware());
	            engine.push(createTransactionValidatorMiddleware());
	        }
	        if (!config.disableCaching) {
	            engine.push(createBlockCacheMiddleware());
	        }
	        engine.push(createFilterMiddleware$1());
	        engine.push(createSubscriptionMiddleware());
	        if (!config.disableCaching) {
	            engine.push(createInflightCacheMiddleware_1());
	        }
	        engine.push(createEthAccountsMiddleware());
	        engine.push(createSignatureMiddleware());
	        engine.push(createFetchRestMiddleware());
	        engine.push(createFetchRpcMiddleware());
	    }
	    async requestWithExtra(request, extra) {
	        var _a, _b;
	        const { method, params } = request;
	        let chainId;
	        if (SUB_INTERACTION_METHODS.has(method) || UNSUB_METHODS.has(method)) {
	            const id = params === null || params === void 0 ? void 0 : params[0];
	            assert(this.activeSubs.has(id), `Subscription/filter not found for id: ${id}`);
	            const parts = id.split(':');
	            // extract chain and subscription id from compound id
	            chainId = parts[0];
	            params[0] = parts[1];
	            if (UNSUB_METHODS.has(method)) {
	                this.activeSubs.delete(id);
	            }
	        }
	        else {
	            chainId = await this.store.getCurrentChainId();
	        }
	        try {
	            let result = await this.requestWithChain(chainId, request, { extra });
	            if (SUB_METHODS.has(method)) {
	                // Ensure the subscription id is unique across chains
	                // by creating unique compound id
	                result = `${chainId}:${result}`;
	                this.activeSubs.add(result);
	            }
	            return result;
	        }
	        catch (err) {
	            if (UNAUTHORIZED_ERRORS.some((phrase) => err.message.includes(phrase))) {
	                await ((_b = (_a = this.config).clearAccessToken) === null || _b === void 0 ? void 0 : _b.call(_a));
	            }
	            throw err;
	        }
	    }
	    async request(request) {
	        return this.requestWithExtra(request);
	    }
	    supportsSubscriptions() {
	        return true;
	    }
	    isConnected() {
	        return true;
	    }
	    on(eventName, listener) {
	        this.events.on(eventName, listener);
	        // Don't emit `connect` until after the first connect listener has been
	        // added, to ensure apps have time to set up their listeners.
	        if (eventName === ethProviderTypes.EthEvent.connect && !this.didEmitConnect) {
	            this.didEmitConnect = true;
	            this.store.getCurrentChainId().then((chainId) => {
	                // Wait a tick to allow any other listeners to be added
	                setTimeout(() => {
	                    this.events.emit(ethProviderTypes.EthEvent.connect, { chainId });
	                });
	            });
	        }
	    }
	    removeListener(eventName, listener) {
	        this.events.removeListener(eventName, listener);
	    }
	    destroy() {
	        var _a, _b;
	        this.destructors.forEach((destroy) => destroy());
	        (_b = (_a = this.config.store).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
	    }
	    async requestWithChain(chainId, { method, params }, opts) {
	        const chain = expect(await this.store.findChain(chainId), 'expected a chain');
	        const context = {
	            chain,
	            config: this.config,
	            store: this.store,
	            emit: this.events.emit.bind(this.events),
	            extra: opts === null || opts === void 0 ? void 0 : opts.extra,
	            request: (req, opts) => this.requestWithChain(chainId, req, opts),
	            addDestructor: (destroy) => this.destructors.push(destroy),
	        };
	        const req = {
	            id: this.requestId++,
	            jsonrpc: '2.0',
	            method,
	            params: params,
	            context,
	            // Used by block-cache middleware
	            skipCache: !!(opts === null || opts === void 0 ? void 0 : opts.skipCache),
	        };
	        const res = await this.engine.handle(req);
	        if (res.error !== undefined) {
	            throw res.error;
	        }
	        else {
	            // TODO: Fix this type cast
	            return res.result;
	        }
	    }
	}
	const createBitskiProvider = (config) => {
	    return new BitskiProvider(config);
	};

	// SDK
	const SDK_VERSION = '0.14.1';
	// URLs
	const BITSKI_USER_API_HOST = 'https://www.bitski.com/v1';
	// OAuth
	const DEFAULT_OAUTH_CONFIGURATION = {
	    authorization_endpoint: 'https://account.bitski.com/oauth2/auth',
	    revocation_endpoint: '',
	    token_endpoint: 'https://account.bitski.com/oauth2/token',
	    userinfo_endpoint: 'https://account.bitski.com/userinfo',
	};
	const DEFAULT_SCOPES = ['openid']; // scopes that are always included
	const DEFAULT_OPTIONAL_SCOPES = ['offline']; // scopes that are included by default, but can be overridden
	// Popup Window
	const CHECK_FOR_POPUP_CLOSE_INTERVAL = 500;
	const DEFAULT_POPUP_FEATURES = {
	    location: 'no',
	    toolbar: 'no',
	    width: 500,
	    height: 500,
	    left: 100,
	    top: 100,
	};
	// Storage
	const REFRESH_TOKEN_KEY = 'bitski.refresh_token';
	const ACCESS_TOKEN_KEY = 'bitski.access_token';
	const ID_TOKEN_KEY = 'bitski.id_token';
	var OAuthSignInMethod;
	(function (OAuthSignInMethod) {
	    OAuthSignInMethod["Redirect"] = "REDIRECT";
	    OAuthSignInMethod["Popup"] = "POPUP";
	    OAuthSignInMethod["Silent"] = "SILENT";
	})(OAuthSignInMethod || (OAuthSignInMethod = {}));
	var AuthenticationStatus;
	(function (AuthenticationStatus) {
	    AuthenticationStatus["Connected"] = "CONNECTED";
	    AuthenticationStatus["Expired"] = "EXPIRED";
	    AuthenticationStatus["NotConnected"] = "NOT_CONNECTED";
	})(AuthenticationStatus || (AuthenticationStatus = {}));

	var built = {};

	var authorization_request = {};

	var crypto_utils = {};

	var base64Js = {};

	base64Js.byteLength = byteLength;
	base64Js.toByteArray = toByteArray;
	base64Js.fromByteArray = fromByteArray;

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens (b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4);

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

	  var curByte = 0;

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen;

	  var i;
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = (tmp >> 16) & 0xFF;
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    );
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    );
	  }

	  return parts.join('')
	}

	var errors = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(errors, "__esModule", { value: true });
	errors.AppAuthError = void 0;
	/**
	 * Represents the AppAuthError type.
	 */
	var AppAuthError = /** @class */ (function () {
	    function AppAuthError(message, extras) {
	        this.message = message;
	        this.extras = extras;
	    }
	    return AppAuthError;
	}());
	errors.AppAuthError = AppAuthError;

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(crypto_utils, "__esModule", { value: true });
	crypto_utils.DefaultCrypto = crypto_utils.textEncodeLite = crypto_utils.urlSafe = crypto_utils.bufferToString = void 0;
	var base64 = base64Js;
	var errors_1$2 = errors;
	var HAS_CRYPTO = typeof window !== 'undefined' && !!window.crypto;
	var HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!window.crypto.subtle;
	var CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	function bufferToString(buffer) {
	    var state = [];
	    for (var i = 0; i < buffer.byteLength; i += 1) {
	        var index = buffer[i] % CHARSET.length;
	        state.push(CHARSET[index]);
	    }
	    return state.join('');
	}
	crypto_utils.bufferToString = bufferToString;
	function urlSafe(buffer) {
	    var encoded = base64.fromByteArray(new Uint8Array(buffer));
	    return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
	}
	crypto_utils.urlSafe = urlSafe;
	// adapted from source: http://stackoverflow.com/a/11058858
	// this is used in place of TextEncode as the api is not yet
	// well supported: https://caniuse.com/#search=TextEncoder
	function textEncodeLite(str) {
	    var buf = new ArrayBuffer(str.length);
	    var bufView = new Uint8Array(buf);
	    for (var i = 0; i < str.length; i++) {
	        bufView[i] = str.charCodeAt(i);
	    }
	    return bufView;
	}
	crypto_utils.textEncodeLite = textEncodeLite;
	/**
	 * The default implementation of the `Crypto` interface.
	 * This uses the capabilities of the browser.
	 */
	var DefaultCrypto = /** @class */ (function () {
	    function DefaultCrypto() {
	    }
	    DefaultCrypto.prototype.generateRandom = function (size) {
	        var buffer = new Uint8Array(size);
	        if (HAS_CRYPTO) {
	            window.crypto.getRandomValues(buffer);
	        }
	        else {
	            // fall back to Math.random() if nothing else is available
	            for (var i = 0; i < size; i += 1) {
	                buffer[i] = (Math.random() * CHARSET.length) | 0;
	            }
	        }
	        return bufferToString(buffer);
	    };
	    DefaultCrypto.prototype.deriveChallenge = function (code) {
	        if (code.length < 43 || code.length > 128) {
	            return Promise.reject(new errors_1$2.AppAuthError('Invalid code length.'));
	        }
	        if (!HAS_SUBTLE_CRYPTO) {
	            return Promise.reject(new errors_1$2.AppAuthError('window.crypto.subtle is unavailable.'));
	        }
	        return new Promise(function (resolve, reject) {
	            crypto.subtle.digest('SHA-256', textEncodeLite(code)).then(function (buffer) {
	                return resolve(urlSafe(new Uint8Array(buffer)));
	            }, function (error) { return reject(error); });
	        });
	    };
	    return DefaultCrypto;
	}());
	crypto_utils.DefaultCrypto = DefaultCrypto;

	var logger = {};

	var flags = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(flags, "__esModule", { value: true });
	flags.IS_PROFILE = flags.IS_LOG = void 0;
	/* Global flags that control the behavior of App Auth JS. */
	/* Logging turned on ? */
	flags.IS_LOG = true;
	/* Profiling turned on ? */
	flags.IS_PROFILE = false;

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(logger, "__esModule", { value: true });
	logger.profile = logger.log = void 0;
	var flags_1 = flags;
	function log(message) {
	    var args = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        args[_i - 1] = arguments[_i];
	    }
	    if (flags_1.IS_LOG) {
	        var length_1 = args ? args.length : 0;
	        if (length_1 > 0) {
	            console.log.apply(console, __spreadArray([message], args));
	        }
	        else {
	            console.log(message);
	        }
	    }
	}
	logger.log = log;
	// check to see if native support for profiling is available.
	var NATIVE_PROFILE_SUPPORT = typeof window !== 'undefined' && !!window.performance && !!console.profile;
	/**
	 * A decorator that can profile a function.
	 */
	function profile(target, propertyKey, descriptor) {
	    if (flags_1.IS_PROFILE) {
	        return performProfile(target, propertyKey, descriptor);
	    }
	    else {
	        // return as-is
	        return descriptor;
	    }
	}
	logger.profile = profile;
	function performProfile(target, propertyKey, descriptor) {
	    var originalCallable = descriptor.value;
	    // name must exist
	    var name = originalCallable.name;
	    if (!name) {
	        name = 'anonymous function';
	    }
	    if (NATIVE_PROFILE_SUPPORT) {
	        descriptor.value = function (args) {
	            console.profile(name);
	            var startTime = window.performance.now();
	            var result = originalCallable.call.apply(originalCallable, __spreadArray([this || window], args));
	            var duration = window.performance.now() - startTime;
	            console.log(name + " took " + duration + " ms");
	            console.profileEnd();
	            return result;
	        };
	    }
	    else {
	        descriptor.value = function (args) {
	            log("Profile start " + name);
	            var start = Date.now();
	            var result = originalCallable.call.apply(originalCallable, __spreadArray([this || window], args));
	            var duration = Date.now() - start;
	            log("Profile end " + name + " took " + duration + " ms.");
	            return result;
	        };
	    }
	    return descriptor;
	}

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(authorization_request, "__esModule", { value: true });
	authorization_request.AuthorizationRequest = void 0;
	var crypto_utils_1$1 = crypto_utils;
	var logger_1$1 = logger;
	/**
	 * Generates a cryptographically random new state. Useful for CSRF protection.
	 */
	var SIZE = 10; // 10 bytes
	var newState = function (crypto) {
	    return crypto.generateRandom(SIZE);
	};
	/**
	 * Represents the AuthorizationRequest.
	 * For more information look at
	 * https://tools.ietf.org/html/rfc6749#section-4.1.1
	 */
	var AuthorizationRequest = /** @class */ (function () {
	    /**
	     * Constructs a new AuthorizationRequest.
	     * Use a `undefined` value for the `state` parameter, to generate a random
	     * state for CSRF protection.
	     */
	    function AuthorizationRequest(request, crypto, usePkce) {
	        if (crypto === void 0) { crypto = new crypto_utils_1$1.DefaultCrypto(); }
	        if (usePkce === void 0) { usePkce = true; }
	        this.crypto = crypto;
	        this.usePkce = usePkce;
	        this.clientId = request.client_id;
	        this.redirectUri = request.redirect_uri;
	        this.scope = request.scope;
	        this.responseType = request.response_type || AuthorizationRequest.RESPONSE_TYPE_CODE;
	        this.state = request.state || newState(crypto);
	        this.extras = request.extras;
	        // read internal properties if available
	        this.internal = request.internal;
	    }
	    AuthorizationRequest.prototype.setupCodeVerifier = function () {
	        var _this = this;
	        if (!this.usePkce) {
	            return Promise.resolve();
	        }
	        else {
	            var codeVerifier_1 = this.crypto.generateRandom(128);
	            var challenge = this.crypto.deriveChallenge(codeVerifier_1).catch(function (error) {
	                logger_1$1.log('Unable to generate PKCE challenge. Not using PKCE', error);
	                return undefined;
	            });
	            return challenge.then(function (result) {
	                if (result) {
	                    // keep track of the code used.
	                    _this.internal = _this.internal || {};
	                    _this.internal['code_verifier'] = codeVerifier_1;
	                    _this.extras = _this.extras || {};
	                    _this.extras['code_challenge'] = result;
	                    // We always use S256. Plain is not good enough.
	                    _this.extras['code_challenge_method'] = 'S256';
	                }
	            });
	        }
	    };
	    /**
	     * Serializes the AuthorizationRequest to a JavaScript Object.
	     */
	    AuthorizationRequest.prototype.toJson = function () {
	        var _this = this;
	        // Always make sure that the code verifier is setup when toJson() is called.
	        return this.setupCodeVerifier().then(function () {
	            return {
	                response_type: _this.responseType,
	                client_id: _this.clientId,
	                redirect_uri: _this.redirectUri,
	                scope: _this.scope,
	                state: _this.state,
	                extras: _this.extras,
	                internal: _this.internal
	            };
	        });
	    };
	    AuthorizationRequest.RESPONSE_TYPE_TOKEN = 'token';
	    AuthorizationRequest.RESPONSE_TYPE_CODE = 'code';
	    return AuthorizationRequest;
	}());
	authorization_request.AuthorizationRequest = AuthorizationRequest;

	var authorization_request_handler = {};

	(function (exports) {
		/*
		 * Copyright 2017 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
		 * in compliance with the License. You may obtain a copy of the License at
		 *
		 * http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software distributed under the
		 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
		 * express or implied. See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AuthorizationRequestHandler = exports.BUILT_IN_PARAMETERS = exports.AuthorizationNotifier = void 0;
		var logger_1 = logger;
		/**
		 * Authorization Service notifier.
		 * This manages the communication of the AuthorizationResponse to the 3p client.
		 */
		var AuthorizationNotifier = /** @class */ (function () {
		    function AuthorizationNotifier() {
		        this.listener = null;
		    }
		    AuthorizationNotifier.prototype.setAuthorizationListener = function (listener) {
		        this.listener = listener;
		    };
		    /**
		     * The authorization complete callback.
		     */
		    AuthorizationNotifier.prototype.onAuthorizationComplete = function (request, response, error) {
		        if (this.listener) {
		            // complete authorization request
		            this.listener(request, response, error);
		        }
		    };
		    return AuthorizationNotifier;
		}());
		exports.AuthorizationNotifier = AuthorizationNotifier;
		// TODO(rahulrav@): add more built in parameters.
		/* built in parameters. */
		exports.BUILT_IN_PARAMETERS = ['redirect_uri', 'client_id', 'response_type', 'state', 'scope'];
		/**
		 * Defines the interface which is capable of handling an authorization request
		 * using various methods (iframe / popup / different process etc.).
		 */
		var AuthorizationRequestHandler = /** @class */ (function () {
		    function AuthorizationRequestHandler(utils, crypto) {
		        this.utils = utils;
		        this.crypto = crypto;
		        // notifier send the response back to the client.
		        this.notifier = null;
		    }
		    /**
		     * A utility method to be able to build the authorization request URL.
		     */
		    AuthorizationRequestHandler.prototype.buildRequestUrl = function (configuration, request) {
		        // build the query string
		        // coerce to any type for convenience
		        var requestMap = {
		            'redirect_uri': request.redirectUri,
		            'client_id': request.clientId,
		            'response_type': request.responseType,
		            'state': request.state,
		            'scope': request.scope
		        };
		        // copy over extras
		        if (request.extras) {
		            for (var extra in request.extras) {
		                if (request.extras.hasOwnProperty(extra)) {
		                    // check before inserting to requestMap
		                    if (exports.BUILT_IN_PARAMETERS.indexOf(extra) < 0) {
		                        requestMap[extra] = request.extras[extra];
		                    }
		                }
		            }
		        }
		        var query = this.utils.stringify(requestMap);
		        var baseUrl = configuration.authorizationEndpoint;
		        var url = baseUrl + "?" + query;
		        return url;
		    };
		    /**
		     * Completes the authorization request if necessary & when possible.
		     */
		    AuthorizationRequestHandler.prototype.completeAuthorizationRequestIfPossible = function () {
		        var _this = this;
		        // call complete authorization if possible to see there might
		        // be a response that needs to be delivered.
		        logger_1.log("Checking to see if there is an authorization response to be delivered.");
		        if (!this.notifier) {
		            logger_1.log("Notifier is not present on AuthorizationRequest handler.\n          No delivery of result will be possible");
		        }
		        return this.completeAuthorizationRequest().then(function (result) {
		            if (!result) {
		                logger_1.log("No result is available yet.");
		            }
		            if (result && _this.notifier) {
		                _this.notifier.onAuthorizationComplete(result.request, result.response, result.error);
		            }
		        });
		    };
		    /**
		     * Sets the default Authorization Service notifier.
		     */
		    AuthorizationRequestHandler.prototype.setAuthorizationNotifier = function (notifier) {
		        this.notifier = notifier;
		        return this;
		    };
		    return AuthorizationRequestHandler;
		}());
		exports.AuthorizationRequestHandler = AuthorizationRequestHandler;
		
	} (authorization_request_handler));

	var authorization_response = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(authorization_response, "__esModule", { value: true });
	authorization_response.AuthorizationError = authorization_response.AuthorizationResponse = void 0;
	/**
	 * Represents the Authorization Response type.
	 * For more information look at
	 * https://tools.ietf.org/html/rfc6749#section-4.1.2
	 */
	var AuthorizationResponse = /** @class */ (function () {
	    function AuthorizationResponse(response) {
	        this.code = response.code;
	        this.state = response.state;
	    }
	    AuthorizationResponse.prototype.toJson = function () {
	        return { code: this.code, state: this.state };
	    };
	    return AuthorizationResponse;
	}());
	authorization_response.AuthorizationResponse = AuthorizationResponse;
	/**
	 * Represents the Authorization error response.
	 * For more information look at:
	 * https://tools.ietf.org/html/rfc6749#section-4.1.2.1
	 */
	var AuthorizationError = /** @class */ (function () {
	    function AuthorizationError(error) {
	        this.error = error.error;
	        this.errorDescription = error.error_description;
	        this.errorUri = error.error_uri;
	        this.state = error.state;
	    }
	    AuthorizationError.prototype.toJson = function () {
	        return {
	            error: this.error,
	            error_description: this.errorDescription,
	            error_uri: this.errorUri,
	            state: this.state
	        };
	    };
	    return AuthorizationError;
	}());
	authorization_response.AuthorizationError = AuthorizationError;

	var authorization_service_configuration = {};

	var xhr = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(xhr, "__esModule", { value: true });
	xhr.TestRequestor = xhr.FetchRequestor = xhr.JQueryRequestor = xhr.Requestor = void 0;
	var errors_1$1 = errors;
	/**
	 * An class that abstracts away the ability to make an XMLHttpRequest.
	 */
	var Requestor = /** @class */ (function () {
	    function Requestor() {
	    }
	    return Requestor;
	}());
	xhr.Requestor = Requestor;
	/**
	 * Uses $.ajax to makes the Ajax requests.
	 */
	var JQueryRequestor = /** @class */ (function (_super) {
	    __extends$2(JQueryRequestor, _super);
	    function JQueryRequestor() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    JQueryRequestor.prototype.xhr = function (settings) {
	        // NOTE: using jquery to make XHR's as whatwg-fetch requires
	        // that I target ES6.
	        var xhr = $.ajax(settings);
	        return new Promise(function (resolve, reject) {
	            xhr.then(function (data, textStatus, jqXhr) {
	                resolve(data);
	            }, function (jqXhr, textStatus, error) {
	                reject(new errors_1$1.AppAuthError(error));
	            });
	        });
	    };
	    return JQueryRequestor;
	}(Requestor));
	xhr.JQueryRequestor = JQueryRequestor;
	/**
	 * Uses fetch API to make Ajax requests
	 */
	var FetchRequestor = /** @class */ (function (_super) {
	    __extends$2(FetchRequestor, _super);
	    function FetchRequestor() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    FetchRequestor.prototype.xhr = function (settings) {
	        if (!settings.url) {
	            return Promise.reject(new errors_1$1.AppAuthError('A URL must be provided.'));
	        }
	        var url = new URL(settings.url);
	        var requestInit = {};
	        requestInit.method = settings.method;
	        requestInit.mode = 'cors';
	        if (settings.data) {
	            if (settings.method && settings.method.toUpperCase() === 'POST') {
	                requestInit.body = settings.data;
	            }
	            else {
	                var searchParams = new URLSearchParams(settings.data);
	                searchParams.forEach(function (value, key) {
	                    url.searchParams.append(key, value);
	                });
	            }
	        }
	        // Set the request headers
	        requestInit.headers = {};
	        if (settings.headers) {
	            for (var i in settings.headers) {
	                if (settings.headers.hasOwnProperty(i)) {
	                    requestInit.headers[i] = settings.headers[i];
	                }
	            }
	        }
	        var isJsonDataType = settings.dataType && settings.dataType.toLowerCase() === 'json';
	        // Set 'Accept' header value for json requests (Taken from
	        // https://github.com/jquery/jquery/blob/e0d941156900a6bff7c098c8ea7290528e468cf8/src/ajax.js#L644
	        // )
	        if (isJsonDataType) {
	            requestInit.headers['Accept'] = 'application/json, text/javascript, */*; q=0.01';
	        }
	        return fetch(url.toString(), requestInit).then(function (response) {
	            if (response.status >= 200 && response.status < 300) {
	                var contentType = response.headers.get('content-type');
	                if (isJsonDataType || (contentType && contentType.indexOf('application/json') !== -1)) {
	                    return response.json();
	                }
	                else {
	                    return response.text();
	                }
	            }
	            else {
	                return Promise.reject(new errors_1$1.AppAuthError(response.status.toString(), response.statusText));
	            }
	        });
	    };
	    return FetchRequestor;
	}(Requestor));
	xhr.FetchRequestor = FetchRequestor;
	/**
	 * Should be used only in the context of testing. Just uses the underlying
	 * Promise to mock the behavior of the Requestor.
	 */
	var TestRequestor = /** @class */ (function (_super) {
	    __extends$2(TestRequestor, _super);
	    function TestRequestor(promise) {
	        var _this = _super.call(this) || this;
	        _this.promise = promise;
	        return _this;
	    }
	    TestRequestor.prototype.xhr = function (settings) {
	        return this.promise; // unsafe cast
	    };
	    return TestRequestor;
	}(Requestor));
	xhr.TestRequestor = TestRequestor;

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(authorization_service_configuration, "__esModule", { value: true });
	authorization_service_configuration.AuthorizationServiceConfiguration = void 0;
	var xhr_1$1 = xhr;
	/**
	 * The standard base path for well-known resources on domains.
	 * See https://tools.ietf.org/html/rfc5785 for more information.
	 */
	var WELL_KNOWN_PATH = '.well-known';
	/**
	 * The standard resource under the well known path at which an OpenID Connect
	 * discovery document can be found under an issuer's base URI.
	 */
	var OPENID_CONFIGURATION = 'openid-configuration';
	/**
	 * Configuration details required to interact with an authorization service.
	 *
	 * More information at https://openid.net/specs/openid-connect-discovery-1_0-17.html
	 */
	var AuthorizationServiceConfiguration = /** @class */ (function () {
	    function AuthorizationServiceConfiguration(request) {
	        this.authorizationEndpoint = request.authorization_endpoint;
	        this.tokenEndpoint = request.token_endpoint;
	        this.revocationEndpoint = request.revocation_endpoint;
	        this.userInfoEndpoint = request.userinfo_endpoint;
	        this.endSessionEndpoint = request.end_session_endpoint;
	    }
	    AuthorizationServiceConfiguration.prototype.toJson = function () {
	        return {
	            authorization_endpoint: this.authorizationEndpoint,
	            token_endpoint: this.tokenEndpoint,
	            revocation_endpoint: this.revocationEndpoint,
	            end_session_endpoint: this.endSessionEndpoint,
	            userinfo_endpoint: this.userInfoEndpoint
	        };
	    };
	    AuthorizationServiceConfiguration.fetchFromIssuer = function (openIdIssuerUrl, requestor) {
	        var fullUrl = openIdIssuerUrl + "/" + WELL_KNOWN_PATH + "/" + OPENID_CONFIGURATION;
	        var requestorToUse = requestor || new xhr_1$1.JQueryRequestor();
	        return requestorToUse
	            .xhr({ url: fullUrl, dataType: 'json', method: 'GET' })
	            .then(function (json) { return new AuthorizationServiceConfiguration(json); });
	    };
	    return AuthorizationServiceConfiguration;
	}());
	authorization_service_configuration.AuthorizationServiceConfiguration = AuthorizationServiceConfiguration;

	var query_string_utils = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(query_string_utils, "__esModule", { value: true });
	query_string_utils.BasicQueryStringUtils = void 0;
	var BasicQueryStringUtils = /** @class */ (function () {
	    function BasicQueryStringUtils() {
	    }
	    BasicQueryStringUtils.prototype.parse = function (input, useHash) {
	        if (useHash) {
	            return this.parseQueryString(input.hash);
	        }
	        else {
	            return this.parseQueryString(input.search);
	        }
	    };
	    BasicQueryStringUtils.prototype.parseQueryString = function (query) {
	        var result = {};
	        // if anything starts with ?, # or & remove it
	        query = query.trim().replace(/^(\?|#|&)/, '');
	        var params = query.split('&');
	        for (var i = 0; i < params.length; i += 1) {
	            var param = params[i]; // looks something like a=b
	            var parts = param.split('=');
	            if (parts.length >= 2) {
	                var key = decodeURIComponent(parts.shift());
	                var value = parts.length > 0 ? parts.join('=') : null;
	                if (value) {
	                    result[key] = decodeURIComponent(value);
	                }
	            }
	        }
	        return result;
	    };
	    BasicQueryStringUtils.prototype.stringify = function (input) {
	        var encoded = [];
	        for (var key in input) {
	            if (input.hasOwnProperty(key) && input[key]) {
	                encoded.push(encodeURIComponent(key) + "=" + encodeURIComponent(input[key]));
	            }
	        }
	        return encoded.join('&');
	    };
	    return BasicQueryStringUtils;
	}());
	query_string_utils.BasicQueryStringUtils = BasicQueryStringUtils;

	var redirect_based_handler = {};

	var storage = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(storage, "__esModule", { value: true });
	storage.LocalStorageBackend = storage.StorageBackend = void 0;
	/**
	 * Asynchronous storage APIs. All methods return a `Promise`.
	 * All methods take the `DOMString`
	 * IDL type (as it is the lowest common denominator).
	 */
	var StorageBackend = /** @class */ (function () {
	    function StorageBackend() {
	    }
	    return StorageBackend;
	}());
	storage.StorageBackend = StorageBackend;
	/**
	 * A `StorageBackend` backed by `localstorage`.
	 */
	var LocalStorageBackend = /** @class */ (function (_super) {
	    __extends$1(LocalStorageBackend, _super);
	    function LocalStorageBackend(storage) {
	        var _this = _super.call(this) || this;
	        _this.storage = storage || window.localStorage;
	        return _this;
	    }
	    LocalStorageBackend.prototype.getItem = function (name) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var value = _this.storage.getItem(name);
	            if (value) {
	                resolve(value);
	            }
	            else {
	                resolve(null);
	            }
	        });
	    };
	    LocalStorageBackend.prototype.removeItem = function (name) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this.storage.removeItem(name);
	            resolve();
	        });
	    };
	    LocalStorageBackend.prototype.clear = function () {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this.storage.clear();
	            resolve();
	        });
	    };
	    LocalStorageBackend.prototype.setItem = function (name, value) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this.storage.setItem(name, value);
	            resolve();
	        });
	    };
	    return LocalStorageBackend;
	}(StorageBackend));
	storage.LocalStorageBackend = LocalStorageBackend;

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(redirect_based_handler, "__esModule", { value: true });
	redirect_based_handler.RedirectRequestHandler = void 0;
	var authorization_request_1 = authorization_request;
	var authorization_request_handler_1 = authorization_request_handler;
	var authorization_response_1 = authorization_response;
	var crypto_utils_1 = crypto_utils;
	var logger_1 = logger;
	var query_string_utils_1$1 = query_string_utils;
	var storage_1 = storage;
	/** key for authorization request. */
	var authorizationRequestKey = function (handle) {
	    return handle + "_appauth_authorization_request";
	};
	/** key for authorization service configuration */
	var authorizationServiceConfigurationKey = function (handle) {
	    return handle + "_appauth_authorization_service_configuration";
	};
	/** key in local storage which represents the current authorization request. */
	var AUTHORIZATION_REQUEST_HANDLE_KEY = 'appauth_current_authorization_request';
	/**
	 * Represents an AuthorizationRequestHandler which uses a standard
	 * redirect based code flow.
	 */
	var RedirectRequestHandler = /** @class */ (function (_super) {
	    __extends(RedirectRequestHandler, _super);
	    function RedirectRequestHandler(
	    // use the provided storage backend
	    // or initialize local storage with the default storage backend which
	    // uses window.localStorage
	    storageBackend, utils, locationLike, crypto) {
	        if (storageBackend === void 0) { storageBackend = new storage_1.LocalStorageBackend(); }
	        if (utils === void 0) { utils = new query_string_utils_1$1.BasicQueryStringUtils(); }
	        if (locationLike === void 0) { locationLike = window.location; }
	        if (crypto === void 0) { crypto = new crypto_utils_1.DefaultCrypto(); }
	        var _this = _super.call(this, utils, crypto) || this;
	        _this.storageBackend = storageBackend;
	        _this.locationLike = locationLike;
	        return _this;
	    }
	    RedirectRequestHandler.prototype.performAuthorizationRequest = function (configuration, request) {
	        var _this = this;
	        var handle = this.crypto.generateRandom(10);
	        // before you make request, persist all request related data in local storage.
	        var persisted = Promise.all([
	            this.storageBackend.setItem(AUTHORIZATION_REQUEST_HANDLE_KEY, handle),
	            // Calling toJson() adds in the code & challenge when possible
	            request.toJson().then(function (result) {
	                return _this.storageBackend.setItem(authorizationRequestKey(handle), JSON.stringify(result));
	            }),
	            this.storageBackend.setItem(authorizationServiceConfigurationKey(handle), JSON.stringify(configuration.toJson())),
	        ]);
	        persisted.then(function () {
	            // make the redirect request
	            var url = _this.buildRequestUrl(configuration, request);
	            logger_1.log('Making a request to ', request, url);
	            _this.locationLike.assign(url);
	        });
	    };
	    /**
	     * Attempts to introspect the contents of storage backend and completes the
	     * request.
	     */
	    RedirectRequestHandler.prototype.completeAuthorizationRequest = function () {
	        var _this = this;
	        // TODO(rahulrav@): handle authorization errors.
	        return this.storageBackend.getItem(AUTHORIZATION_REQUEST_HANDLE_KEY).then(function (handle) {
	            if (handle) {
	                // we have a pending request.
	                // fetch authorization request, and check state
	                return _this.storageBackend
	                    .getItem(authorizationRequestKey(handle))
	                    // requires a corresponding instance of result
	                    // TODO(rahulrav@): check for inconsitent state here
	                    .then(function (result) { return JSON.parse(result); })
	                    .then(function (json) { return new authorization_request_1.AuthorizationRequest(json); })
	                    .then(function (request) {
	                    // check redirect_uri and state
	                    var currentUri = "" + _this.locationLike.origin + _this.locationLike.pathname;
	                    var queryParams = _this.utils.parse(_this.locationLike, true /* use hash */);
	                    var state = queryParams['state'];
	                    var code = queryParams['code'];
	                    var error = queryParams['error'];
	                    logger_1.log('Potential authorization request ', currentUri, queryParams, state, code, error);
	                    var shouldNotify = state === request.state;
	                    var authorizationResponse = null;
	                    var authorizationError = null;
	                    if (shouldNotify) {
	                        if (error) {
	                            // get additional optional info.
	                            var errorUri = queryParams['error_uri'];
	                            var errorDescription = queryParams['error_description'];
	                            authorizationError = new authorization_response_1.AuthorizationError({
	                                error: error,
	                                error_description: errorDescription,
	                                error_uri: errorUri,
	                                state: state
	                            });
	                        }
	                        else {
	                            authorizationResponse = new authorization_response_1.AuthorizationResponse({ code: code, state: state });
	                        }
	                        // cleanup state
	                        return Promise
	                            .all([
	                            _this.storageBackend.removeItem(AUTHORIZATION_REQUEST_HANDLE_KEY),
	                            _this.storageBackend.removeItem(authorizationRequestKey(handle)),
	                            _this.storageBackend.removeItem(authorizationServiceConfigurationKey(handle))
	                        ])
	                            .then(function () {
	                            logger_1.log('Delivering authorization response');
	                            return {
	                                request: request,
	                                response: authorizationResponse,
	                                error: authorizationError
	                            };
	                        });
	                    }
	                    else {
	                        logger_1.log('Mismatched request (state and request_uri) dont match.');
	                        return Promise.resolve(null);
	                    }
	                });
	            }
	            else {
	                return null;
	            }
	        });
	    };
	    return RedirectRequestHandler;
	}(authorization_request_handler_1.AuthorizationRequestHandler));
	redirect_based_handler.RedirectRequestHandler = RedirectRequestHandler;

	var revoke_token_request = {};

	Object.defineProperty(revoke_token_request, "__esModule", { value: true });
	revoke_token_request.RevokeTokenRequest = void 0;
	/**
	 * Represents a revoke token request.
	 * For more information look at:
	 * https://tools.ietf.org/html/rfc7009#section-2.1
	 */
	var RevokeTokenRequest = /** @class */ (function () {
	    function RevokeTokenRequest(request) {
	        this.token = request.token;
	        this.tokenTypeHint = request.token_type_hint;
	        this.clientId = request.client_id;
	        this.clientSecret = request.client_secret;
	    }
	    /**
	     * Serializes a TokenRequest to a JavaScript object.
	     */
	    RevokeTokenRequest.prototype.toJson = function () {
	        var json = { token: this.token };
	        if (this.tokenTypeHint) {
	            json['token_type_hint'] = this.tokenTypeHint;
	        }
	        if (this.clientId) {
	            json['client_id'] = this.clientId;
	        }
	        if (this.clientSecret) {
	            json['client_secret'] = this.clientSecret;
	        }
	        return json;
	    };
	    RevokeTokenRequest.prototype.toStringMap = function () {
	        var json = this.toJson();
	        // :(
	        return json;
	    };
	    return RevokeTokenRequest;
	}());
	revoke_token_request.RevokeTokenRequest = RevokeTokenRequest;

	var token_request = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(token_request, "__esModule", { value: true });
	token_request.TokenRequest = token_request.GRANT_TYPE_REFRESH_TOKEN = token_request.GRANT_TYPE_AUTHORIZATION_CODE = void 0;
	token_request.GRANT_TYPE_AUTHORIZATION_CODE = 'authorization_code';
	token_request.GRANT_TYPE_REFRESH_TOKEN = 'refresh_token';
	/**
	 * Represents an Access Token request.
	 * For more information look at:
	 * https://tools.ietf.org/html/rfc6749#section-4.1.3
	 */
	var TokenRequest = /** @class */ (function () {
	    function TokenRequest(request) {
	        this.clientId = request.client_id;
	        this.redirectUri = request.redirect_uri;
	        this.grantType = request.grant_type;
	        this.code = request.code;
	        this.refreshToken = request.refresh_token;
	        this.extras = request.extras;
	    }
	    /**
	     * Serializes a TokenRequest to a JavaScript object.
	     */
	    TokenRequest.prototype.toJson = function () {
	        return {
	            grant_type: this.grantType,
	            code: this.code,
	            refresh_token: this.refreshToken,
	            redirect_uri: this.redirectUri,
	            client_id: this.clientId,
	            extras: this.extras
	        };
	    };
	    TokenRequest.prototype.toStringMap = function () {
	        var map = {
	            grant_type: this.grantType,
	            client_id: this.clientId,
	            redirect_uri: this.redirectUri
	        };
	        if (this.code) {
	            map['code'] = this.code;
	        }
	        if (this.refreshToken) {
	            map['refresh_token'] = this.refreshToken;
	        }
	        // copy over extras
	        if (this.extras) {
	            for (var extra in this.extras) {
	                if (this.extras.hasOwnProperty(extra) && !map.hasOwnProperty(extra)) {
	                    // check before inserting to requestMap
	                    map[extra] = this.extras[extra];
	                }
	            }
	        }
	        return map;
	    };
	    return TokenRequest;
	}());
	token_request.TokenRequest = TokenRequest;

	var token_request_handler = {};

	var token_response = {};

	(function (exports) {
		/*
		 * Copyright 2017 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
		 * in compliance with the License. You may obtain a copy of the License at
		 *
		 * http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software distributed under the
		 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
		 * express or implied. See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.TokenError = exports.TokenResponse = exports.nowInSeconds = void 0;
		// constants
		var AUTH_EXPIRY_BUFFER = 10 * 60 * -1; // 10 mins in seconds
		/**
		 * Returns the instant of time in seconds.
		 */
		var nowInSeconds = function () { return Math.round(new Date().getTime() / 1000); };
		exports.nowInSeconds = nowInSeconds;
		/**
		 * Represents the Token Response type.
		 * For more information look at:
		 * https://tools.ietf.org/html/rfc6749#section-5.1
		 */
		var TokenResponse = /** @class */ (function () {
		    function TokenResponse(response) {
		        this.accessToken = response.access_token;
		        this.tokenType = response.token_type || 'bearer';
		        if (response.expires_in) {
		            this.expiresIn = parseInt(response.expires_in, 10);
		        }
		        this.refreshToken = response.refresh_token;
		        this.scope = response.scope;
		        this.idToken = response.id_token;
		        this.issuedAt = response.issued_at || exports.nowInSeconds();
		    }
		    TokenResponse.prototype.toJson = function () {
		        var _a;
		        return {
		            access_token: this.accessToken,
		            id_token: this.idToken,
		            refresh_token: this.refreshToken,
		            scope: this.scope,
		            token_type: this.tokenType,
		            issued_at: this.issuedAt,
		            expires_in: (_a = this.expiresIn) === null || _a === void 0 ? void 0 : _a.toString()
		        };
		    };
		    TokenResponse.prototype.isValid = function (buffer) {
		        if (buffer === void 0) { buffer = AUTH_EXPIRY_BUFFER; }
		        if (this.expiresIn) {
		            var now = exports.nowInSeconds();
		            return now < this.issuedAt + this.expiresIn + buffer;
		        }
		        else {
		            return true;
		        }
		    };
		    return TokenResponse;
		}());
		exports.TokenResponse = TokenResponse;
		/**
		 * Represents the Token Error type.
		 * For more information look at:
		 * https://tools.ietf.org/html/rfc6749#section-5.2
		 */
		var TokenError = /** @class */ (function () {
		    function TokenError(tokenError) {
		        this.error = tokenError.error;
		        this.errorDescription = tokenError.error_description;
		        this.errorUri = tokenError.error_uri;
		    }
		    TokenError.prototype.toJson = function () {
		        return {
		            error: this.error, error_description: this.errorDescription, error_uri: this.errorUri
		        };
		    };
		    return TokenError;
		}());
		exports.TokenError = TokenError;
		
	} (token_response));

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(token_request_handler, "__esModule", { value: true });
	token_request_handler.BaseTokenRequestHandler = void 0;
	var errors_1 = errors;
	var query_string_utils_1 = query_string_utils;
	var token_response_1 = token_response;
	var xhr_1 = xhr;
	/**
	 * The default token request handler.
	 */
	var BaseTokenRequestHandler = /** @class */ (function () {
	    function BaseTokenRequestHandler(requestor, utils) {
	        if (requestor === void 0) { requestor = new xhr_1.JQueryRequestor(); }
	        if (utils === void 0) { utils = new query_string_utils_1.BasicQueryStringUtils(); }
	        this.requestor = requestor;
	        this.utils = utils;
	    }
	    BaseTokenRequestHandler.prototype.isTokenResponse = function (response) {
	        return response.error === undefined;
	    };
	    BaseTokenRequestHandler.prototype.performRevokeTokenRequest = function (configuration, request) {
	        var revokeTokenResponse = this.requestor.xhr({
	            url: configuration.revocationEndpoint,
	            method: 'POST',
	            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
	            data: this.utils.stringify(request.toStringMap())
	        });
	        return revokeTokenResponse.then(function (response) {
	            return true;
	        });
	    };
	    BaseTokenRequestHandler.prototype.performTokenRequest = function (configuration, request) {
	        var _this = this;
	        var tokenResponse = this.requestor.xhr({
	            url: configuration.tokenEndpoint,
	            method: 'POST',
	            dataType: 'json',
	            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
	            data: this.utils.stringify(request.toStringMap())
	        });
	        return tokenResponse.then(function (response) {
	            if (_this.isTokenResponse(response)) {
	                return new token_response_1.TokenResponse(response);
	            }
	            else {
	                return Promise.reject(new errors_1.AppAuthError(response.error, new token_response_1.TokenError(response)));
	            }
	        });
	    };
	    return BaseTokenRequestHandler;
	}());
	token_request_handler.BaseTokenRequestHandler = BaseTokenRequestHandler;

	var types = {};

	/*
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 * in compliance with the License. You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under the
	 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
	 * express or implied. See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(types, "__esModule", { value: true });

	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(authorization_request, exports);
		__exportStar(authorization_request_handler, exports);
		__exportStar(authorization_response, exports);
		__exportStar(authorization_service_configuration, exports);
		__exportStar(crypto_utils, exports);
		__exportStar(errors, exports);
		__exportStar(flags, exports);
		__exportStar(logger, exports);
		__exportStar(query_string_utils, exports);
		__exportStar(redirect_based_handler, exports);
		__exportStar(revoke_token_request, exports);
		__exportStar(storage, exports);
		__exportStar(token_request, exports);
		__exportStar(token_request_handler, exports);
		__exportStar(token_response, exports);
		__exportStar(types, exports);
		__exportStar(xhr, exports);
		
	} (built));

	class NoHashQueryStringUtils extends built.BasicQueryStringUtils {
	    parse(input, useHash) {
	        return super.parse(input, false /* never use hash */);
	    }
	}

	/**
	 * Parses a Fetch Response to extract either the result or the error
	 * @param response the fetch response to parse
	 */
	function parseResponse(response) {
	    return response
	        .json()
	        .catch(() => {
	        throw new Error('Invalid JSON response');
	    })
	        .then((json) => {
	        if (response.status >= 200 && response.status < 300) {
	            return json;
	        }
	        else {
	            if (json && json.error && json.error.message) {
	                throw new Error(json.error.message);
	            }
	            else if (json && json.error) {
	                throw new Error(json.error);
	            }
	            else {
	                throw new Error('Unknown error');
	            }
	        }
	    });
	}

	/**
	 * Automatically handles finalizing the oauth sign in process with the Bitski SDK
	 */
	/**
	 * Extracts query params from the hash of the url
	 * @param url the url to parse
	 */
	function parseUrlParams(url) {
	    let params;
	    if (url.href.includes('#')) {
	        params = extractQuery(url.hash);
	    }
	    else if (url.href.includes('?')) {
	        params = url.search.split('?').pop();
	    }
	    if (!params) {
	        throw new Error('No params found in result');
	    }
	    return params.split('&').reduce((prev, item) => {
	        const [key, value] = item.split('=');
	        if (key && value) {
	            prev[decodeURIComponent(key)] = decodeURIComponent(value);
	        }
	        return prev;
	    }, {});
	}
	function extractQuery(url) {
	    if (!url.includes('#')) {
	        throw new Error('No params found in result');
	    }
	    return url.split('#').pop();
	}

	/**
	 * A simple utility class that will check to see if a popup is blocked.
	 * Derived from info and examples on this page:
	 * https://stackoverflow.com/questions/2914/how-can-i-detect-if-a-browser-is-blocking-a-popup
	 */
	class PopupValidator {
	    constructor(errorHandler) {
	        this.errorHandler = errorHandler;
	    }
	    // Check a popup window to see if it has been blocked.
	    // The error handler will be called asynchronously if
	    // the window has been detected to have been blocked.
	    check(popup) {
	        if (popup) {
	            if (/chrome/.test(navigator.userAgent.toLowerCase())) {
	                setTimeout(() => {
	                    this.isPopupBlocked(popup);
	                }, 2000);
	            }
	            else {
	                popup.onload = () => {
	                    this.isPopupBlocked(popup);
	                };
	            }
	        }
	        else {
	            this.handleBlocked();
	        }
	    }
	    isPopupBlocked(popup) {
	        if (popup.innerHeight > 0 === false) {
	            this.handleBlocked();
	        }
	    }
	    handleBlocked() {
	        this.errorHandler();
	    }
	}

	// tslint:disable max-classes-per-file
	// Intermediate errors, since AuthorizationRequestHandler must return an AuthorizationError instance.
	// These should not be user visible.
	class PopupClosedError extends built.AuthorizationError {
	    constructor() {
	        super({ error: 'The popup was dismissed.' });
	    }
	}
	class PopupBlockedError extends built.AuthorizationError {
	    constructor() {
	        super({ error: 'The popup was blocked.' });
	    }
	}
	// Create a popup feature string from an object with keys and values
	function createPopupFeatureString(features) {
	    // Convert to array of strings
	    const featuresArray = Object.keys(features).reduce((arr, key) => {
	        const value = features[key];
	        // convert to feature string format: top=100
	        arr.push(`${key}=${value}`);
	        return arr;
	    }, Array());
	    // Join strings with ',' and finish with ';'
	    return featuresArray.join(',') + ';';
	}
	// Returns a set of attributes for a centered popup based on
	// the default values from constants.ts
	function createCenteredPopupFeatures() {
	    const windowFeatures = DEFAULT_POPUP_FEATURES;
	    const w = windowFeatures.width;
	    const h = windowFeatures.height;
	    // Fixes dual-screen position
	    const dualScreenLeft = window.screenLeft || window.screenX;
	    const dualScreenTop = window.screenTop || window.screenY;
	    const windowWidth = window.innerWidth || document.documentElement.clientWidth || screen.width;
	    const windowHeight = window.innerHeight || document.documentElement.clientHeight || screen.height;
	    const left = windowWidth / 2 - w / 2;
	    const top = windowHeight / 2 - h / 2;
	    windowFeatures.left = left + dualScreenLeft;
	    windowFeatures.top = top + dualScreenTop;
	    return windowFeatures;
	}
	class PopupRequestHandler extends built.AuthorizationRequestHandler {
	    constructor(utils = new built.BasicQueryStringUtils(), crypto = new built.DefaultCrypto()) {
	        super(utils, crypto);
	        this.popupWindow = null;
	        this.isCancelled = false;
	        this.isBlocked = false;
	        // Watch for the popup being blocked
	        this.validator = new PopupValidator(() => {
	            // Return a specific error if blocked, so that we can handle it appropriately.
	            this.isBlocked = true;
	            this.completeAuthorizationRequestIfPossible();
	        });
	    }
	    performAuthorizationRequest(configuration, request) {
	        var _a, _b;
	        const url = this.buildRequestUrl(configuration, request);
	        this.pendingRequest = request;
	        this.id = request.state;
	        // Set a unique handler on the main window
	        window[`popupCallback_${request.state}`] = this.callback.bind(this);
	        // Start monitoring to see if the popup has been closed
	        this.closedTimer = window.setInterval(this.checkPopup.bind(this), CHECK_FOR_POPUP_CLOSE_INTERVAL);
	        // Create features for popup
	        const windowFeatures = createCenteredPopupFeatures();
	        // Create popup window
	        this.popupWindow = window.open(url, '_blank', createPopupFeatureString(windowFeatures));
	        // Check if the popup we just created was blocked.
	        this.validator.check(this.popupWindow);
	        // Focus the popup to bring it to the front
	        (_b = (_a = this.popupWindow) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);
	    }
	    callback(url) {
	        this.responseUrl = url;
	        this.completeAuthorizationRequestIfPossible();
	    }
	    // Custom implementation to remove excess log spam
	    completeAuthorizationRequestIfPossible() {
	        return this.completeAuthorizationRequest().then((result) => {
	            if (result && this.notifier) {
	                this.notifier.onAuthorizationComplete(result.request, result.response, result.error);
	            }
	        });
	    }
	    completeAuthorizationRequest() {
	        const request = this.pendingRequest;
	        // Assert there is a pending request
	        if (!request) {
	            return Promise.resolve(null);
	        }
	        // Assert the request wasn't cancelled
	        if (this.isCancelled === true) {
	            return this.respondWithCancelled(request);
	        }
	        if (this.isBlocked === true) {
	            return this.respondWithBlocked(request);
	        }
	        // Assert there is no error
	        if (this.error) {
	            return this.respondWithError(request, this.error.message);
	        }
	        // Assert there is a response url to parse
	        if (!this.responseUrl) {
	            return Promise.resolve(null);
	        }
	        // Parse the url into data
	        const data = parseUrlParams(this.responseUrl);
	        // Extra the state
	        const state = data.state;
	        // Validate state is same as request
	        if (request.state !== state) {
	            return Promise.resolve(null);
	        }
	        // Check for an error response
	        const error = data.error;
	        if (error) {
	            // get additional optional info.
	            const errorUri = data.error_uri;
	            const errorDescription = data.error_description;
	            return this.respondWithError(request, error, errorDescription, errorUri);
	        }
	        // Respond with a code
	        const code = data.code;
	        return this.respondWithCode(request, code);
	    }
	    respondWithBlocked(request) {
	        const error = new PopupBlockedError();
	        const response = { request, error, response: null };
	        this.cleanup();
	        return Promise.resolve(response);
	    }
	    respondWithCancelled(request) {
	        const error = new PopupClosedError();
	        const response = { request, error, response: null };
	        this.cleanup();
	        return Promise.resolve(response);
	    }
	    respondWithError(request, errorMessage, errorDescription, errorUri) {
	        const error = new built.AuthorizationError({
	            error: errorMessage,
	            error_description: errorDescription,
	            error_uri: errorUri,
	            state: request.state,
	        });
	        const response = { request, error, response: null };
	        this.cleanup();
	        return Promise.resolve(response);
	    }
	    respondWithCode(request, code) {
	        let authorizationResponse = null;
	        if (code) {
	            authorizationResponse = new built.AuthorizationResponse({ code, state: request.state });
	        }
	        const response = { request, response: authorizationResponse, error: null };
	        this.cleanup();
	        return Promise.resolve(response);
	    }
	    cleanup() {
	        var _a, _b;
	        window.clearInterval(this.closedTimer);
	        delete window[`popupCallback_${this.id}`];
	        (_b = (_a = this.popupWindow) === null || _a === void 0 ? void 0 : _a.close) === null || _b === void 0 ? void 0 : _b.call(_a);
	        this.popupWindow = null;
	        this.pendingRequest = undefined;
	        this.error = undefined;
	        this.id = undefined;
	        this.responseUrl = undefined;
	    }
	    checkPopup() {
	        if (this.popupWindow && this.popupWindow.closed) {
	            // Stop checking
	            window.clearInterval(this.closedTimer);
	            this.isCancelled = true;
	            this.completeAuthorizationRequestIfPossible();
	        }
	    }
	}

	const USER_CANCELLED_MESSAGE = 'Sign in request was cancelled.';
	/**
	 * Responsible for submitting requests to our OAuth server.
	 */
	class OAuthManager {
	    /**
	     * Create a new OAuth Manager
	     * @param options Settings object
	     * @param options.clientId string: The client id to use for various requests
	     * @param options.redirectUri string: The redirect URI to use for responding to auth requests
	     * @param options.configuration AuthorizationServiceConfiguration (optional): The configuration for the OAuth server
	     * @param options.additionalScopes string[] (optional): Additional scopes to request outside of openid.
	     * Default is offline. Pass an empty array to only request openid.
	     */
	    constructor(options) {
	        this.clientId = options.clientId;
	        this.redirectUri = options.redirectUri;
	        this.configuration =
	            options.configuration || new built.AuthorizationServiceConfiguration(DEFAULT_OAUTH_CONFIGURATION);
	        const additionalScopes = options.additionalScopes || DEFAULT_OPTIONAL_SCOPES;
	        this.scopes = DEFAULT_SCOPES.concat(additionalScopes);
	        this.tokenHandler = new built.BaseTokenRequestHandler(new built.FetchRequestor());
	        this.notifier = new built.AuthorizationNotifier();
	        this.notifier.setAuthorizationListener(this.didCompleteAuthorizationFlow.bind(this));
	    }
	    /**
	     * Trigger a popup sign in flow (the default)
	     */
	    signInPopup(opts) {
	        opts = opts || {};
	        const promise = new Promise((fulfill, reject) => {
	            this.pendingResolver = { fulfill, reject };
	        });
	        this.authHandler = new PopupRequestHandler();
	        this.authHandler.setAuthorizationNotifier(this.notifier);
	        const request = this.createAuthRequest(opts);
	        this.authHandler.performAuthorizationRequest(this.configuration, request);
	        return promise.then((response) => {
	            return this.requestAccessToken(response.code);
	        });
	    }
	    /**
	     * Trigger a redirect sign in flow. Promise should never fulfill, as you will be redirected.
	     */
	    signInRedirect(opts) {
	        opts = opts || {};
	        const promise = new Promise((fulfill, reject) => {
	            this.pendingResolver = { fulfill, reject };
	        });
	        this.authHandler = new built.RedirectRequestHandler(undefined, new NoHashQueryStringUtils());
	        this.authHandler.setAuthorizationNotifier(this.notifier);
	        const request = this.createAuthRequest(opts);
	        this.authHandler.performAuthorizationRequest(this.configuration, request);
	        // Since this method redirects the whole window, the promise will
	        // likely never complete unless we encounter an error.
	        return promise;
	    }
	    /**
	     * Attempt to finalize auth request from a redirect flow. Called from your redirect url once you've been
	     * redirected back.
	     */
	    redirectCallback() {
	        const promise = new Promise((fulfill, reject) => {
	            this.pendingResolver = { fulfill, reject };
	        });
	        this.authHandler = new built.RedirectRequestHandler(undefined, new NoHashQueryStringUtils());
	        this.authHandler.setAuthorizationNotifier(this.notifier);
	        this.authHandler.completeAuthorizationRequestIfPossible();
	        return promise.then((response) => {
	            return this.requestAccessToken(response.code);
	        });
	    }
	    /**
	     * Exchange an authorization code for an access token
	     * @param code The authorization code to exchange
	     */
	    requestAccessToken(code) {
	        const request = this.createTokenRequest(code);
	        return this.tokenHandler.performTokenRequest(this.configuration, request);
	    }
	    /**
	     * Request a new access token from a previous refresh token
	     * @param refreshToken The refresh token to use for authorization
	     */
	    refreshAccessToken(refreshToken) {
	        const request = this.createRefreshTokenRequest(refreshToken);
	        return this.tokenHandler.performTokenRequest(this.configuration, request);
	    }
	    /**
	     * Submit a sign out request on the oauth endpoint
	     * @param accessToken The access token to sign out with
	     */
	    requestSignOut(accessToken) {
	        return fetch(`${BITSKI_USER_API_HOST}/logout`, {
	            headers: {
	                Accept: 'application/json',
	                Authorization: `Bearer ${accessToken}`,
	                'Content-Type': 'application/json',
	            },
	            method: 'POST',
	        }).then((response) => {
	            return parseResponse(response);
	        });
	    }
	    /**
	     * Request a user's profile from the oauth server
	     * @param accessToken The access token for the user
	     */
	    requestUserInfo(accessToken) {
	        const userInfoEndpoint = this.configuration.userInfoEndpoint;
	        if (!userInfoEndpoint) {
	            return Promise.reject(new Error('Could not find user info endpoint'));
	        }
	        return fetch(userInfoEndpoint, {
	            headers: {
	                Accept: 'application/json',
	                Authorization: `Bearer ${accessToken}`,
	            },
	        }).then((response) => {
	            return parseResponse(response);
	        });
	    }
	    /**
	     * Internal callback from our Auth Request handler. Passes the response through to a cached promise if it exists.
	     * @param request The original auth request
	     * @param response The auth response if it was successful
	     * @param errorResponse The error response if it failed
	     */
	    didCompleteAuthorizationFlow(request, response, errorResponse) {
	        if (this.pendingResolver) {
	            if (response) {
	                this.pendingResolver.fulfill(response);
	                this.pendingResolver = undefined;
	            }
	            else if (errorResponse) {
	                if (errorResponse instanceof PopupClosedError) {
	                    this.pendingResolver.reject(new Error(USER_CANCELLED_MESSAGE));
	                }
	                else if (errorResponse instanceof PopupBlockedError) {
	                    // Parse domain of the authority, to log better context for error.
	                    const urlMatch = /^(http?s:\/\/[\w.]*)\/[\w/]*$/;
	                    // Check for matches against the authority
	                    const matches = this.configuration.authorizationEndpoint.match(urlMatch);
	                    const baseUrl = matches && matches.length > 1 ? matches[1] : '';
	                    this.pendingResolver.reject(new Error(`The popup was blocked. Please make sure ${baseUrl} is allowed to open popups.`));
	                }
	                else {
	                    this.pendingResolver.reject(new Error(`Error from the server: ${errorResponse.error}`));
	                }
	                this.pendingResolver = undefined;
	            }
	        }
	    }
	    /**
	     * Factory method to create an auth request
	     */
	    createAuthRequest(opts) {
	        // Create base request
	        const request = new built.AuthorizationRequest({
	            client_id: this.clientId,
	            redirect_uri: this.redirectUri,
	            response_type: built.AuthorizationRequest.RESPONSE_TYPE_CODE,
	            scope: this.scopes.join(' '),
	        }, undefined, false);
	        // Pass options through
	        if (opts.login_hint) {
	            // Only assign extras if login_hint is included in the options
	            request.extras = { login_hint: opts.login_hint };
	        }
	        return request;
	    }
	    /**
	     * Factory method to create a token request with a refresh token
	     * @param refreshToken Refresh token to use
	     */
	    createRefreshTokenRequest(refreshToken) {
	        return new built.TokenRequest({
	            client_id: this.clientId,
	            grant_type: built.GRANT_TYPE_REFRESH_TOKEN,
	            redirect_uri: this.redirectUri,
	            refresh_token: refreshToken,
	        });
	    }
	    /**
	     * Factory method to create a token request with an auth code
	     * @param code The auth code to use
	     */
	    createTokenRequest(code) {
	        return new built.TokenRequest({
	            client_id: this.clientId,
	            code,
	            grant_type: built.GRANT_TYPE_AUTHORIZATION_CODE,
	            redirect_uri: this.redirectUri,
	        });
	    }
	}

	/**
	 * Represents a Bitski access token
	 */
	class AccessToken {
	    /**
	     *
	     * @param token the access token
	     * @param expiresAt the token expiration date (in seconds) (optional)
	     * @param scope the scopes this token represents (optional)
	     */
	    constructor(token, expiresAt, scope) {
	        this.token = token;
	        this.scope = scope;
	        this.expiresAt = expiresAt;
	    }
	    /**
	     * Creates a token from a TokenResponse object
	     * @param tokenResponse The token response object to build a token from
	     */
	    static fromTokenResponse(tokenResponse) {
	        let expiresAt;
	        if (tokenResponse.expiresIn) {
	            expiresAt = Math.floor(Date.now() / 1000) + tokenResponse.expiresIn;
	        }
	        return new AccessToken(tokenResponse.accessToken, expiresAt, tokenResponse.scope);
	    }
	    /**
	     * Creates a token from a storage string
	     * @param s JSON string representing the token
	     */
	    static fromString(s) {
	        let parsed;
	        try {
	            parsed = JSON.parse(s);
	        }
	        catch (error) {
	            return;
	        }
	        if (!parsed.token) {
	            return;
	        }
	        return new AccessToken(parsed.token, parsed.expiresAt, parsed.scope);
	    }
	    /**
	     * Calculates if the token is still active
	     */
	    get expired() {
	        if (this.expiresAt) {
	            const now = Math.floor(Date.now() / 1000);
	            const expiresIn = this.expiresAt - now;
	            return expiresIn <= 0;
	        }
	        return false;
	    }
	    /**
	     * Returns a JSON string suitable for writing in local storage
	     */
	    toStorageString() {
	        return JSON.stringify({
	            expiresAt: this.expiresAt,
	            scope: this.scope,
	            token: this.token,
	        });
	    }
	}

	class TokenStore {
	    constructor(clientId, store) {
	        var _a, _b;
	        this.clientId = clientId;
	        this.store = store;
	        this.loadTokensFromCache();
	        (_b = (_a = this.store).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, () => this.loadTokensFromCache());
	    }
	    async getCurrentToken() {
	        const accessToken = await this.accessToken;
	        if (accessToken && !accessToken.expired) {
	            return accessToken.token;
	        }
	    }
	    async getCurrentIdToken() {
	        const idToken = await this.idToken;
	        const accessToken = await this.accessToken;
	        if (idToken && accessToken && !accessToken.expired) {
	            return idToken;
	        }
	    }
	    getRefreshToken() {
	        return this.refreshToken;
	    }
	    get idTokenKey() {
	        return `${ID_TOKEN_KEY}.${this.clientId}`;
	    }
	    get accessTokenKey() {
	        return `${ACCESS_TOKEN_KEY}.${this.clientId}`;
	    }
	    get refreshTokenKey() {
	        return `${REFRESH_TOKEN_KEY}.${this.clientId}`;
	    }
	    loadTokensFromCache() {
	        this.accessToken = Promise.resolve(this.store.getItem(this.accessTokenKey))
	            .then((accessTokenString) => {
	            const accessTokenResult = string$1.decode(accessTokenString);
	            if (accessTokenResult.value) {
	                return AccessToken.fromString(accessTokenResult.value);
	            }
	        })
	            .catch(() => {
	            console.log('Could not parse accessToken, setting to undefined');
	            return undefined;
	        });
	        this.idToken = Promise.resolve(this.store.getItem(this.idTokenKey))
	            .then((token) => string$1.decode(token).value)
	            .catch(() => {
	            console.log('Could not parse idToken, setting to undefined');
	            return undefined;
	        });
	        this.refreshToken = Promise.resolve(this.store.getItem(this.refreshTokenKey))
	            .then((token) => string$1.decode(token).value)
	            .catch(() => {
	            console.log('Could not parse refreshToken, setting to undefined');
	            return undefined;
	        });
	    }
	    persistTokenResponse(response) {
	        const parsedToken = AccessToken.fromTokenResponse(response);
	        this.store.setItem(this.accessTokenKey, parsedToken.toStorageString());
	        this.accessToken = Promise.resolve(parsedToken);
	        this.store.setItem(this.idTokenKey, response.idToken);
	        this.idToken = Promise.resolve(response.idToken);
	        if (response.refreshToken) {
	            this.store.setItem(this.refreshTokenKey, response.refreshToken);
	            this.refreshToken = Promise.resolve(response.refreshToken);
	        }
	    }
	    async invalidateCurrentToken() {
	        this.accessToken = Promise.resolve(undefined);
	        this.idToken = Promise.resolve(undefined);
	        await Promise.all([
	            this.store.clearItem(this.accessTokenKey),
	            this.store.clearItem(this.idTokenKey),
	        ]);
	    }
	    async clear() {
	        this.accessToken = Promise.resolve(undefined);
	        this.idToken = Promise.resolve(undefined);
	        this.refreshToken = Promise.resolve(undefined);
	        await Promise.all([
	            this.store.clearItem(this.refreshTokenKey),
	            this.store.clearItem(this.accessTokenKey),
	            this.store.clearItem(this.idTokenKey),
	        ]);
	    }
	}

	class User {
	    constructor(id, accounts, email, emailVerified, phone, phoneNumberVerified, preferredUsername) {
	        this.id = id;
	        this.accounts = accounts;
	        this.email = email;
	        this.emailVerified = emailVerified;
	        this.phoneNumber = phone;
	        this.phoneNumberVerified = phoneNumberVerified;
	        this.preferredUsername = preferredUsername;
	    }
	    static fromJson(json) {
	        return new User(json.sub, json.accounts, json.email, json.email_verified, json.phone_number, json.phone_number_verified, json.preferred_username);
	    }
	    static fromString(s) {
	        let parsed;
	        try {
	            parsed = JSON.parse(s);
	        }
	        catch (e) {
	            return;
	        }
	        if (parsed.id) {
	            return new User(parsed.id, parsed.accounts, parsed.email, parsed.emailVerified, parsed.phoneNumber, parsed.phoneNumberVerified, parsed.preferredUsername);
	        }
	        return;
	    }
	    toStorageString() {
	        return JSON.stringify({
	            accounts: this.accounts,
	            email: this.email,
	            emailVerified: this.emailVerified,
	            id: this.id,
	            phoneNumber: this.phoneNumber,
	            phoneNumberVerified: this.phoneNumberVerified,
	            preferredUsername: this.preferredUsername,
	        });
	    }
	}

	class OpenidAuthProvider {
	    constructor(clientId, redirectUri, store, additionalScopes, configuration) {
	        this.didConnect = false;
	        this.oauthManager = new OAuthManager({
	            additionalScopes,
	            clientId,
	            redirectUri,
	            configuration,
	        });
	        this.tokenStore = new TokenStore(clientId, store);
	    }
	    async getAuthStatus() {
	        if (await this.tokenStore.getCurrentToken()) {
	            return AuthenticationStatus.Connected;
	        }
	        else if (await this.tokenStore.getRefreshToken()) {
	            return AuthenticationStatus.Expired;
	        }
	        else {
	            return AuthenticationStatus.NotConnected;
	        }
	    }
	    async getAccessToken() {
	        const currentToken = await this.tokenStore.getCurrentToken();
	        if (currentToken) {
	            return currentToken;
	        }
	        if (await this.tokenStore.getRefreshToken()) {
	            return this.refreshAccessToken();
	        }
	        throw new Error('Not signed in');
	    }
	    async getIdToken() {
	        const currentIdToken = await this.tokenStore.getCurrentToken();
	        if (currentIdToken) {
	            return currentIdToken;
	        }
	        if (await this.tokenStore.getRefreshToken()) {
	            return this.refreshIdToken();
	        }
	        return Promise.reject(new Error('Not signed in'));
	    }
	    async getRefreshToken() {
	        const refreshToken = await this.tokenStore.getRefreshToken();
	        if (refreshToken) {
	            return refreshToken;
	        }
	        // Error: the user did not approve this app for offline access
	        if (await this.tokenStore.getCurrentToken()) {
	            return Promise.reject(new Error('No refresh token available'));
	        }
	        // Error: the user is not signed in.
	        return Promise.reject(new Error('Not signed in'));
	    }
	    async invalidateToken() {
	        await this.tokenStore.invalidateCurrentToken();
	        if (this.signOutCallback) {
	            this.signOutCallback();
	        }
	    }
	    refreshTokens() {
	        if (!this._refreshTokensPromise) {
	            this._refreshTokensPromise = this.tokenStore.getRefreshToken().then(async (refreshToken) => {
	                if (!refreshToken) {
	                    throw new Error('No refresh token available');
	                }
	                try {
	                    const tokenResponse = await this.oauthManager.refreshAccessToken(refreshToken);
	                    this.tokenStore.persistTokenResponse(tokenResponse);
	                    return tokenResponse;
	                }
	                catch (error) {
	                    this.currentUser = undefined;
	                    await this.tokenStore.clear();
	                    throw error;
	                }
	                finally {
	                    this._refreshTokensPromise = undefined;
	                }
	            });
	        }
	        return this._refreshTokensPromise;
	    }
	    async refreshAccessToken() {
	        const tokenResponse = await this.refreshTokens();
	        return tokenResponse.accessToken;
	    }
	    async refreshIdToken() {
	        const tokenResponse = await this.refreshTokens();
	        return tokenResponse.idToken;
	    }
	    signIn(method, opts) {
	        let promise;
	        switch (method) {
	            case OAuthSignInMethod.Redirect:
	                promise = this.oauthManager.signInRedirect(opts);
	                break;
	            case OAuthSignInMethod.Silent:
	                return Promise.reject(new Error('Sign in method not supported'));
	            default:
	                promise = this.oauthManager.signInPopup(opts);
	                break;
	        }
	        return promise.then((tokenResponse) => {
	            this.tokenStore.persistTokenResponse(tokenResponse);
	            return this.loadUser();
	        });
	    }
	    connect() {
	        return this.refreshAccessToken().then(() => {
	            return this.loadUser();
	        });
	    }
	    getUser() {
	        return this.getOrFetchUser();
	    }
	    getUserFromCache() {
	        return this.currentUser;
	    }
	    async signInOrConnect(signInMethod = OAuthSignInMethod.Popup, opts) {
	        switch (await this.getAuthStatus()) {
	            case AuthenticationStatus.Connected:
	                return this.loadUser();
	            case AuthenticationStatus.Expired:
	                return this.connect();
	            case AuthenticationStatus.NotConnected:
	                return this.signIn(signInMethod, opts);
	        }
	    }
	    redirectCallback() {
	        return this.oauthManager.redirectCallback().then((tokenResponse) => {
	            this.tokenStore.persistTokenResponse(tokenResponse);
	            return this.loadUser();
	        });
	    }
	    async signOut() {
	        await this.tokenStore.clear();
	        // Call the sign out callback if one has been provided
	        if (this.signOutCallback) {
	            this.signOutCallback();
	        }
	        // We don't currently have the ability to invalidate access tokens, so for now simply resolve.
	        // Down the road this may perform a network request to invalidate.
	        return Promise.resolve();
	    }
	    async getOrFetchUser() {
	        if (this.currentUser) {
	            return this.currentUser;
	        }
	        return this.loadUser();
	    }
	    loadUser() {
	        return this.getAccessToken()
	            .then((accessToken) => {
	            return this.oauthManager.requestUserInfo(accessToken);
	        })
	            .then((json) => {
	            return User.fromJson(json);
	        })
	            .then((user) => {
	            this.currentUser = user;
	            return user;
	        });
	    }
	    loadFromCache() {
	        this.tokenStore.loadTokensFromCache();
	    }
	}

	/* tslint:disable */
	const css = `
.bitski-connect-button {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, 'Helvetica Neue', sans-serif;
  font-weight: 500;
  background-color: #1C11D9;
  background-repeat: no-repeat;
  background-position: 0px 0px;
  border: none;
  color: #fff;
  margin: 0;
  padding: 0;
  cursor: pointer;
  text-shadow: 1px 0 1px rgba(0, 0, 0, 0.03);
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.14);
  transition: background 200ms linear, transform 200ms ease-out;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.bitski-connect-button:focus,
.bitski-connect-button:active {
  background-color: #2117C7;
  transform: scale(0.99, 0.99);
  color: rgba(255, 255, 255, 0.8);
}
.bitski-connect-button.size-small {
  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-sm.svg');
  border-radius: 3px;
  font-size: 10px;
  height: 22px;
  line-height: 19px;
  padding-left: 30px;
  padding-right: 8px;
}
.bitski-connect-button.size-medium {
  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-md.svg');
  border-radius: 4px;
  font-size: 11px;
  height: 30px;
  line-height: 29px;
  padding-left: 40px;
  padding-right: 12px;
}
.bitski-connect-button.size-large {
  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-lg.svg');
  border-radius: 5px;
  font-size: 14px;
  height: 44px;
  line-height: 44px;
  padding-left: 57px;
  padding-right: 15px;
}
`;

	/**
	 * Bitski SDK
	 */
	class BitskiSDK {
	    /**
	     * @param clientId OAuth Client ID
	     * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.
	     * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].
	     * Note: Make sure your app is approved for the scopes you are requesting first.
	     * @param options Other OAuth settings. Don't change these unless you know what you are doing.
	     */
	    constructor(clientId, redirectUri, additionalScopes, options) {
	        this.signoutHandlers = [];
	        this.clientId = clientId;
	        this.sdkVersion = SDK_VERSION;
	        this.store = (options === null || options === void 0 ? void 0 : options.store) || new LocalStorageStore();
	        this.authProvider = new OpenidAuthProvider(clientId, redirectUri || window.location.href, this.store, additionalScopes, options === null || options === void 0 ? void 0 : options.configuration);
	        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
	            if (document && document.body) {
	                this.injectStyles();
	            }
	            else {
	                window.addEventListener('load', () => {
	                    this.injectStyles();
	                });
	            }
	        }
	        this.authProvider.signOutCallback = this.onSignOut.bind(this);
	    }
	    /**
	     * Signs in or connects to bitski depending on the user's auth state.
	     * Since it may open a popup, this method must be called from user interaction handler,
	     * such as a click or tap handler.
	     * @param options Provide SignInOptions for the sign in request. See signIn() for more info.
	     */
	    signInOrConnect(method, options) {
	        return this.authProvider.signInOrConnect(method, options);
	    }
	    /**
	     * Check the logged in state of the user
	     */
	    getAuthStatus() {
	        return this.authProvider.getAuthStatus();
	    }
	    /**
	     * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.
	     * @param options Optionally provide additional options for the sign in request.
	     *
	     * You can use the options parameter to request that we show the sign up form instead of the sign in form:
	     * ```javascript
	     * import { LOGIN_HINT_SIGNUP } from 'bitski';
	     *
	     * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });
	     * ```
	     */
	    signIn(options) {
	        return this.authProvider.signIn(OAuthSignInMethod.Popup, options);
	    }
	    /**
	     * Gets the current signed in user. Will reject if we are not signed in.
	     */
	    getUser() {
	        return this.authProvider.getUser();
	    }
	    /**
	     * Connects to bitski to get a valid access token if possible.
	     */
	    connect() {
	        return this.authProvider.connect();
	    }
	    /**
	     * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.
	     * @param options Optionally provide additional options for the sign in request. See signIn() for more info.
	     */
	    signInRedirect(options) {
	        this.authProvider.signIn(OAuthSignInMethod.Redirect, options);
	    }
	    /**
	     * Call from your oauth redirect page.
	     */
	    redirectCallback() {
	        return this.authProvider.redirectCallback();
	    }
	    /**
	     * Retrieves the current access token for the user, if logged in.
	     */
	    getCurrentAccessToken() {
	        return this.authProvider.getAccessToken();
	    }
	    /**
	     * Retrieves the current ID token for the user, if logged in.
	     */
	    getCurrentIdToken() {
	        return this.authProvider.getIdToken();
	    }
	    /**
	     * Retrieves the current refresh token for the user, if logged in.
	     * Requires that the user has approved your application for offline access.
	     */
	    getCurrentRefreshToken() {
	        return this.authProvider.getRefreshToken();
	    }
	    /**
	     * Register a callback to be called on sign out. This is a good practice,
	     * since there may be situations where you are signed out unexpectedly.
	     * @param fn Your callback function
	     */
	    addSignOutHandler(fn) {
	        this.signoutHandlers.push(fn);
	    }
	    /**
	     * Remove a registered signout callback
	     * @param fn Your callback function
	     */
	    removeSignOutHandler(fn) {
	        const index = this.signoutHandlers.findIndex((item) => item === fn);
	        if (index >= 0) {
	            this.signoutHandlers.splice(index, 1);
	        }
	    }
	    /**
	     * Sign the current user out of your application.
	     */
	    signOut() {
	        return this.authProvider.signOut();
	    }
	    /**
	     * Used to refresh the auth provider's state if the user is logged in/out in a
	     * different process
	     */
	    reloadAuthState() {
	        this.authProvider.loadFromCache();
	    }
	    createProvider(options = {}) {
	        return createBitskiProvider(Object.assign(Object.assign({ clientId: this.clientId, getAccessToken: this.getCurrentAccessToken.bind(this), clearAccessToken: this.signOut.bind(this), getUser: async () => this.authProvider.getUserFromCache(), signerBaseUrl: options.webBaseUrl, transactionCallbackUrl: options.callbackURL }, options), { additionalHeaders: Object.assign({ 'X-CLIENT-VERSION': "bitski-sdk-v3.3.0" }, options.additionalHeaders), prependMiddleware: undefined }));
	    }
	    onSignOut() {
	        this.signoutHandlers.forEach((cb) => {
	            cb();
	        });
	    }
	    /**
	     * Embeds Bitski's UI styles
	     */
	    injectStyles() {
	        if (document.getElementById('BitskiSDKEmbeddedStyles')) {
	            return;
	        }
	        const style = document.createElement('style');
	        style.setAttribute('type', 'text/css');
	        style.setAttribute('id', 'BitskiSDKEmbeddedStyles');
	        style.appendChild(document.createTextNode(css));
	        const head = document.head || document.getElementsByTagName('head')[0];
	        head.appendChild(style);
	    }
	}

	exports.BitskiSDK = BitskiSDK;

}));
