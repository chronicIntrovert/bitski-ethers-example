import { AuthenticationStatus, OAuthSignInMethod } from '../constants';
import { OAuthManager } from './oauth-manager';
import { TokenStore } from './token-store';
import { User } from './user';
export class OpenidAuthProvider {
    constructor(clientId, redirectUri, store, additionalScopes, configuration) {
        this.didConnect = false;
        this.oauthManager = new OAuthManager({
            additionalScopes,
            clientId,
            redirectUri,
            configuration,
        });
        this.tokenStore = new TokenStore(clientId, store);
    }
    async getAuthStatus() {
        if (await this.tokenStore.getCurrentToken()) {
            return AuthenticationStatus.Connected;
        }
        else if (await this.tokenStore.getRefreshToken()) {
            return AuthenticationStatus.Expired;
        }
        else {
            return AuthenticationStatus.NotConnected;
        }
    }
    async getAccessToken() {
        const currentToken = await this.tokenStore.getCurrentToken();
        if (currentToken) {
            return currentToken;
        }
        if (await this.tokenStore.getRefreshToken()) {
            return this.refreshAccessToken();
        }
        throw new Error('Not signed in');
    }
    async getIdToken() {
        const currentIdToken = await this.tokenStore.getCurrentToken();
        if (currentIdToken) {
            return currentIdToken;
        }
        if (await this.tokenStore.getRefreshToken()) {
            return this.refreshIdToken();
        }
        return Promise.reject(new Error('Not signed in'));
    }
    async getRefreshToken() {
        const refreshToken = await this.tokenStore.getRefreshToken();
        if (refreshToken) {
            return refreshToken;
        }
        // Error: the user did not approve this app for offline access
        if (await this.tokenStore.getCurrentToken()) {
            return Promise.reject(new Error('No refresh token available'));
        }
        // Error: the user is not signed in.
        return Promise.reject(new Error('Not signed in'));
    }
    async invalidateToken() {
        await this.tokenStore.invalidateCurrentToken();
        if (this.signOutCallback) {
            this.signOutCallback();
        }
    }
    refreshTokens() {
        if (!this._refreshTokensPromise) {
            this._refreshTokensPromise = this.tokenStore.getRefreshToken().then(async (refreshToken) => {
                if (!refreshToken) {
                    throw new Error('No refresh token available');
                }
                try {
                    const tokenResponse = await this.oauthManager.refreshAccessToken(refreshToken);
                    this.tokenStore.persistTokenResponse(tokenResponse);
                    return tokenResponse;
                }
                catch (error) {
                    this.currentUser = undefined;
                    await this.tokenStore.clear();
                    throw error;
                }
                finally {
                    this._refreshTokensPromise = undefined;
                }
            });
        }
        return this._refreshTokensPromise;
    }
    async refreshAccessToken() {
        const tokenResponse = await this.refreshTokens();
        return tokenResponse.accessToken;
    }
    async refreshIdToken() {
        const tokenResponse = await this.refreshTokens();
        return tokenResponse.idToken;
    }
    signIn(method, opts) {
        let promise;
        switch (method) {
            case OAuthSignInMethod.Redirect:
                promise = this.oauthManager.signInRedirect(opts);
                break;
            case OAuthSignInMethod.Silent:
                return Promise.reject(new Error('Sign in method not supported'));
            default:
                promise = this.oauthManager.signInPopup(opts);
                break;
        }
        return promise.then((tokenResponse) => {
            this.tokenStore.persistTokenResponse(tokenResponse);
            return this.loadUser();
        });
    }
    connect() {
        return this.refreshAccessToken().then(() => {
            return this.loadUser();
        });
    }
    getUser() {
        return this.getOrFetchUser();
    }
    getUserFromCache() {
        return this.currentUser;
    }
    async signInOrConnect(signInMethod = OAuthSignInMethod.Popup, opts) {
        switch (await this.getAuthStatus()) {
            case AuthenticationStatus.Connected:
                return this.loadUser();
            case AuthenticationStatus.Expired:
                return this.connect();
            case AuthenticationStatus.NotConnected:
                return this.signIn(signInMethod, opts);
        }
    }
    redirectCallback() {
        return this.oauthManager.redirectCallback().then((tokenResponse) => {
            this.tokenStore.persistTokenResponse(tokenResponse);
            return this.loadUser();
        });
    }
    async signOut() {
        await this.tokenStore.clear();
        // Call the sign out callback if one has been provided
        if (this.signOutCallback) {
            this.signOutCallback();
        }
        // We don't currently have the ability to invalidate access tokens, so for now simply resolve.
        // Down the road this may perform a network request to invalidate.
        return Promise.resolve();
    }
    async getOrFetchUser() {
        if (this.currentUser) {
            return this.currentUser;
        }
        return this.loadUser();
    }
    loadUser() {
        return this.getAccessToken()
            .then((accessToken) => {
            return this.oauthManager.requestUserInfo(accessToken);
        })
            .then((json) => {
            return User.fromJson(json);
        })
            .then((user) => {
            this.currentUser = user;
            return user;
        });
    }
    loadFromCache() {
        this.tokenStore.loadTokensFromCache();
    }
}
