import { EthChainDefinition, EthEvent, EthEventParams, EthMethod, EthMethodParams, EthRequest, EthResult } from 'eth-provider-types';
import { JsonRpcRequest, PendingJsonRpcResponse } from 'json-rpc-engine';
import type { BitskiProviderStateStore } from './store';
export interface User {
    id: string;
    accounts?: string[];
}
export interface EthChainDefinitionWithRpcUrl extends EthChainDefinition {
    rpcUrls: [firstUrl: string, ...restUrls: string[]];
}
export interface BitskiProviderStore {
    clear(): void | Promise<void>;
    keys?(): string[] | Promise<string[]>;
    getItem(key: string): unknown | undefined | Promise<unknown | undefined>;
    setItem(key: string, value: unknown): void | Promise<void>;
    clearItem(key: string): void | Promise<void>;
    onUpdate?(fn: () => void): any;
    destroy?(): void;
}
export interface InternalBitskiProviderConfig<Extra = unknown> {
    fetch: typeof fetch;
    additionalHeaders: Record<string, string>;
    prependMiddleware?: ProviderMiddleware<unknown[], unknown, Extra>[];
    pollingInterval?: number;
    disableCaching?: boolean;
    disableValidation?: boolean;
    additionalSigningContext?: Record<string, string>;
    clientId: string;
    apiBaseUrl: string;
    signerBaseUrl: string;
    transactionCallbackUrl?: string;
    store: BitskiProviderStore;
    sign: SignFn;
    getUser?(): Promise<User | undefined>;
    getAccessToken?(): Promise<string>;
    clearAccessToken?(): Promise<void>;
}
declare type Optional<T, K extends keyof T> = Omit<T, K> & Partial<T>;
export declare type BitskiProviderConfig<Extra = unknown> = Optional<InternalBitskiProviderConfig<Extra>, 'apiBaseUrl' | 'signerBaseUrl' | 'fetch' | 'additionalHeaders' | 'sign' | 'getUser' | 'store'>;
/**
 * Each provider request is made with a context object. The context object contains
 * information such as the current chain the request should be made on and the
 * configuration of the provider. This allows us to "switch" chains just by using
 * a different context.
 */
export interface RequestContext<Extra = unknown> {
    chain: EthChainDefinitionWithRpcUrl;
    config: InternalBitskiProviderConfig<Extra>;
    store: BitskiProviderStateStore;
    extra?: Extra;
    emit: <T extends EthEvent>(eventName: T, ...params: EthEventParams[T]) => void;
    request<T extends EthMethod>({ method, params }: EthRequest<T>, opts?: {
        skipCache?: boolean;
    }): EthResult<T>;
    addDestructor(fn: () => void): void;
}
export interface EthSignMethodParams extends EthMethodParams {
    personal_sign: [data: string, address: string];
}
export declare type ProviderMiddleware<T = unknown[], U = unknown, V = unknown> = (req: JsonRpcRequest<T> & {
    context: RequestContext<V>;
}, res: PendingJsonRpcResponse<U>, next: () => Promise<void>) => Promise<void>;
export declare type EthSignMethod = EthMethod.eth_sendTransaction | EthMethod.eth_signTransaction | EthMethod.eth_sign | EthMethod.eth_signTypedData | EthMethod.eth_signTypedData_v1 | EthMethod.eth_signTypedData_v3 | EthMethod.eth_signTypedData_v4 | 'personal_sign';
export declare type SignFn = <T extends EthSignMethod>(method: T, params: EthSignMethodParams[T], context: RequestContext) => Promise<string>;
export {};
