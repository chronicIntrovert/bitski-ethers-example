"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLegacyMiddleware = exports.getLegacyMiddlewareProviderFor = exports.clearLegacyProviders = void 0;
const eth_block_tracker_1 = require("eth-block-tracker");
const request_context_1 = require("./request-context");
class LegacyMiddlewareProvider {
    constructor(context) {
        this.context = context;
        this.blockTracker = new eth_block_tracker_1.PollingBlockTracker({
            // The only method used in block trackers is `sendAsync`
            provider: this,
            pollingInterval: context.config.pollingInterval,
            setSkipCacheFlag: true,
        });
    }
    sendAsync(
    // Skip cache comes from block tracker and legacy middlewares
    request, callback) {
        this.context
            .request({ method: request.method, params: request.params }, {
            skipCache: request.skipCache,
        })
            .then((result) => {
            callback(null, { result });
        })
            .catch((err) => {
            callback(err);
        });
    }
}
exports.default = LegacyMiddlewareProvider;
const PROVIDERS = new Map();
// exported for tests
const clearLegacyProviders = () => PROVIDERS.clear();
exports.clearLegacyProviders = clearLegacyProviders;
const getLegacyMiddlewareProviderFor = (context) => {
    let provider = PROVIDERS.get(context.chain.chainId);
    if (!provider) {
        provider = new LegacyMiddlewareProvider(context);
        PROVIDERS.set(context.chain.chainId, provider);
    }
    return provider;
};
exports.getLegacyMiddlewareProviderFor = getLegacyMiddlewareProviderFor;
const createLegacyMiddleware = (createMiddleware) => {
    const MIDDLEWARES = new Map();
    const getMiddlewareFor = (context) => {
        let middleware = MIDDLEWARES.get(context.chain.chainId);
        if (!middleware) {
            const legacyProvider = (0, exports.getLegacyMiddlewareProviderFor)(context);
            middleware = createMiddleware({
                context,
                provider: legacyProvider,
                blockTracker: legacyProvider.blockTracker,
            });
            MIDDLEWARES.set(context.chain.chainId, middleware);
        }
        return middleware;
    };
    return (req, res, next, end) => {
        const context = (0, request_context_1.getRequestContext)(req);
        const middleware = getMiddlewareFor(context);
        middleware(req, res, next, end);
    };
};
exports.createLegacyMiddleware = createLegacyMiddleware;
//# sourceMappingURL=legacy-middleware.js.map