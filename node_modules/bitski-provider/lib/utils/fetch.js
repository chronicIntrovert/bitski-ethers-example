"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchJsonRpcWithRetry = exports.fetchJsonWithRetry = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
    'failed to parse response body',
    'ECONNRESET',
    'EHOSTUNREACH',
    'Timeout out while waiting for response',
    // ignore errors where http req failed to establish
    'Failed to fetch',
    'ENOTFOUND', // DNS error
];
const isErrorRetriable = (err) => {
    if (!(err instanceof Error) && typeof err !== 'string') {
        return false;
    }
    const errMsg = typeof err === 'string' ? err : err.message;
    return RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
};
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const maybeGetErrorMessage = (text) => {
    try {
        const json = JSON.parse(text);
        return json.error;
    }
    catch (err) {
        return undefined;
    }
};
const fetchJsonWithRetry = async (fetchFn, retryCount, url, init, waitBeforeRetryFor = 0) => {
    try {
        const response = await fetchFn(url, {
            method: init.method,
            body: init.body ? JSON.stringify(init.body) : undefined,
            headers: Object.assign({ Accept: 'application/json', 'Content-Type': 'application/json' }, init.headers),
        });
        if (!response.ok) {
            switch (response.status) {
                case 405:
                    throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
                case 429:
                    throw eth_rpc_errors_1.ethErrors.rpc.limitExceeded('Request is being rate limited.');
                case 503:
                case 504:
                    throw eth_rpc_errors_1.ethErrors.rpc.internal('Gateway timeout. The request took too long to process. This can happen when querying logs over too wide a block range.');
                default:
                    // eslint-disable-next-line no-case-declarations
                    const text = await response.text();
                    // eslint-disable-next-line no-case-declarations
                    const errorMessage = maybeGetErrorMessage(text);
                    throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage !== null && errorMessage !== void 0 ? errorMessage : `Request failed, response status: ${response.status}, body: ${text}`);
            }
        }
        return response.json();
    }
    catch (err) {
        if (err && isErrorRetriable(err)) {
            if (retryCount > 0) {
                await sleep(waitBeforeRetryFor);
                return (0, exports.fetchJsonWithRetry)(fetchFn, retryCount - 1, url, init, waitBeforeRetryFor + 1000);
            }
            else {
                throw eth_rpc_errors_1.ethErrors.rpc.internal(`FetchSubprovider - cannot complete request. All retries exhausted.\nOriginal Error:\n${err}\n\n`);
            }
        }
        else if (err instanceof eth_rpc_errors_1.EthereumRpcError || err instanceof eth_rpc_errors_1.EthereumProviderError) {
            throw err;
        }
        else {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(err instanceof Error ? err.message : 'Something went wrong');
        }
    }
};
exports.fetchJsonWithRetry = fetchJsonWithRetry;
const fetchJsonRpcWithRetry = async (fetchFn, retryCount, url, init) => {
    if (init.body && !init.body.params) {
        init.body.params = [];
    }
    const { result, error } = (await (0, exports.fetchJsonWithRetry)(fetchFn, retryCount, url, init));
    if (error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal(error);
    }
    else if (result === undefined) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal('Missing result');
    }
    return result;
};
exports.fetchJsonRpcWithRetry = fetchJsonRpcWithRetry;
//# sourceMappingURL=fetch.js.map