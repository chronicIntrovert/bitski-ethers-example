"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBitskiProvider = exports.BitskiProvider = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const inflight_cache_1 = require("eth-json-rpc-middleware/dist/inflight-cache");
const eth_provider_types_1 = require("eth-provider-types");
const json_rpc_engine_1 = require("json-rpc-engine");
const constants_1 = require("./constants");
const block_cache_1 = require("./middleware/block-cache");
const chain_management_1 = require("./middleware/chain-management");
const eth_accounts_1 = require("./middleware/eth-accounts");
const fetch_rest_1 = require("./middleware/fetch-rest");
const fetch_rpc_1 = require("./middleware/fetch-rpc");
const filter_1 = require("./middleware/filter");
const fixture_1 = require("./middleware/fixture");
const signature_1 = require("./middleware/signature");
const subscription_1 = require("./middleware/subscription");
const transaction_validator_1 = require("./middleware/transaction-validator");
const typed_data_sanitizer_1 = require("./middleware/typed-data-sanitizer");
const browser_1 = __importDefault(require("./signers/browser"));
const store_1 = require("./store");
const type_utils_1 = require("./utils/type-utils");
// Some eth methods result in a subscription being created, and return the id of that subscription.
// We need to keep track of the subscription id and the chain id it was created on, so we can
// call future methods to interact with or unsubscribe from the subscription.
const SUB_METHODS = new Set([
    eth_provider_types_1.EthMethod.eth_subscribe,
    eth_provider_types_1.EthMethod.eth_newFilter,
    eth_provider_types_1.EthMethod.eth_newBlockFilter,
    eth_provider_types_1.EthMethod.eth_newPendingTransactionFilter,
]);
const SUB_INTERACTION_METHODS = new Set([
    eth_provider_types_1.EthMethod.eth_getFilterChanges,
    eth_provider_types_1.EthMethod.eth_getFilterLogs,
]);
const UNSUB_METHODS = new Set([eth_provider_types_1.EthMethod.eth_unsubscribe, eth_provider_types_1.EthMethod.eth_uninstallFilter]);
class BitskiProvider {
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.engine = new json_rpc_engine_1.JsonRpcEngine();
        this.events = new safe_event_emitter_1.default();
        this.destructors = [];
        this.requestId = 0;
        this.didEmitConnect = false;
        this.activeSubs = new Set();
        this.config = Object.assign(Object.assign({}, config), { fetch: (_a = config.fetch) !== null && _a !== void 0 ? _a : fetch, additionalHeaders: Object.assign({ 'X-API-KEY': config.clientId, 'X-CLIENT-ID': config.clientId, 'X-CLIENT-VERSION': "bitski-provider-v2.0.0" }, ((_b = config.additionalHeaders) !== null && _b !== void 0 ? _b : {})), apiBaseUrl: (_c = config.apiBaseUrl) !== null && _c !== void 0 ? _c : constants_1.BITSKI_API_BASE_URL, signerBaseUrl: (_d = config.signerBaseUrl) !== null && _d !== void 0 ? _d : constants_1.BITSKI_SIGNER_BASE_URL, store: (_e = config.store) !== null && _e !== void 0 ? _e : new store_1.LocalStorageStore(), sign: (_f = config.sign) !== null && _f !== void 0 ? _f : (0, browser_1.default)() });
        this.store = new store_1.BitskiProviderStateStore(this.config.store);
        // Setup the engine
        const engine = this.engine;
        (_g = config.prependMiddleware) === null || _g === void 0 ? void 0 : _g.forEach((middleware) => 
        // TODO: Need to typecast because JSON RPC engine middleware can't have
        // additional props on it, can get rid of this once we get rid of JSON RPC engine
        engine.push((0, json_rpc_engine_1.createAsyncMiddleware)(middleware)));
        // Handles static responses
        engine.push((0, fixture_1.createFixtureMiddleware)());
        engine.push((0, chain_management_1.createChainManagementMiddleware)());
        if (!config.disableValidation) {
            // Ensures that transactions are well formed (nonce, gas, gasPrice, from) before they are sent to Bitski
            engine.push((0, typed_data_sanitizer_1.createTypedDataSanitizerMiddleware)());
            engine.push((0, transaction_validator_1.createTransactionValidatorMiddleware)());
        }
        if (!config.disableCaching) {
            engine.push((0, block_cache_1.createBlockCacheMiddleware)());
        }
        engine.push((0, filter_1.createFilterMiddleware)());
        engine.push((0, subscription_1.createSubscriptionMiddleware)());
        if (!config.disableCaching) {
            engine.push((0, inflight_cache_1.createInflightCacheMiddleware)());
        }
        engine.push((0, eth_accounts_1.createEthAccountsMiddleware)());
        engine.push((0, signature_1.createSignatureMiddleware)());
        engine.push((0, fetch_rest_1.createFetchRestMiddleware)());
        engine.push((0, fetch_rpc_1.createFetchRpcMiddleware)());
    }
    async requestWithExtra(request, extra) {
        var _a, _b;
        const { method, params } = request;
        let chainId;
        if (SUB_INTERACTION_METHODS.has(method) || UNSUB_METHODS.has(method)) {
            const id = params === null || params === void 0 ? void 0 : params[0];
            (0, type_utils_1.assert)(this.activeSubs.has(id), `Subscription/filter not found for id: ${id}`);
            const parts = id.split(':');
            // extract chain and subscription id from compound id
            chainId = parts[0];
            params[0] = parts[1];
            if (UNSUB_METHODS.has(method)) {
                this.activeSubs.delete(id);
            }
        }
        else {
            chainId = await this.store.getCurrentChainId();
        }
        try {
            let result = await this.requestWithChain(chainId, request, { extra });
            if (SUB_METHODS.has(method)) {
                // Ensure the subscription id is unique across chains
                // by creating unique compound id
                result = `${chainId}:${result}`;
                this.activeSubs.add(result);
            }
            return result;
        }
        catch (err) {
            if (constants_1.UNAUTHORIZED_ERRORS.some((phrase) => err.message.includes(phrase))) {
                await ((_b = (_a = this.config).clearAccessToken) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
            throw err;
        }
    }
    async request(request) {
        return this.requestWithExtra(request);
    }
    supportsSubscriptions() {
        return true;
    }
    isConnected() {
        return true;
    }
    on(eventName, listener) {
        this.events.on(eventName, listener);
        // Don't emit `connect` until after the first connect listener has been
        // added, to ensure apps have time to set up their listeners.
        if (eventName === eth_provider_types_1.EthEvent.connect && !this.didEmitConnect) {
            this.didEmitConnect = true;
            this.store.getCurrentChainId().then((chainId) => {
                // Wait a tick to allow any other listeners to be added
                setTimeout(() => {
                    this.events.emit(eth_provider_types_1.EthEvent.connect, { chainId });
                });
            });
        }
    }
    removeListener(eventName, listener) {
        this.events.removeListener(eventName, listener);
    }
    destroy() {
        var _a, _b;
        this.destructors.forEach((destroy) => destroy());
        (_b = (_a = this.config.store).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    async requestWithChain(chainId, { method, params }, opts) {
        const chain = (0, type_utils_1.expect)(await this.store.findChain(chainId), 'expected a chain');
        const context = {
            chain,
            config: this.config,
            store: this.store,
            emit: this.events.emit.bind(this.events),
            extra: opts === null || opts === void 0 ? void 0 : opts.extra,
            request: (req, opts) => this.requestWithChain(chainId, req, opts),
            addDestructor: (destroy) => this.destructors.push(destroy),
        };
        const req = {
            id: this.requestId++,
            jsonrpc: '2.0',
            method,
            params: params,
            context,
            // Used by block-cache middleware
            skipCache: !!(opts === null || opts === void 0 ? void 0 : opts.skipCache),
        };
        const res = await this.engine.handle(req);
        if (res.error !== undefined) {
            throw res.error;
        }
        else {
            // TODO: Fix this type cast
            return res.result;
        }
    }
}
exports.BitskiProvider = BitskiProvider;
const createBitskiProvider = (config) => {
    return new BitskiProvider(config);
};
exports.createBitskiProvider = createBitskiProvider;
//# sourceMappingURL=bitski-provider.js.map