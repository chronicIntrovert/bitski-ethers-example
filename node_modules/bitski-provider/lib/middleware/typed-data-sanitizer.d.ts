import { TypedData } from 'eth-provider-types';
import { JsonRpcMiddleware } from 'json-rpc-engine';
interface TypeMapping {
    [typeName: string]: {
        [propertyName: string]: string;
    };
}
export declare const createTypedDataSanitizerMiddleware: () => JsonRpcMiddleware<[
    string,
    string
], unknown>;
/**
 * Sanitizes the `domain` values from the TypedData
 *
 * @param typedData TypedData payload
 * @param typeMapping a TypeMapping pre-generated from the TypedData
 */
export declare const sanitizeDomain: (typedData: TypedData, typeMapping: TypeMapping) => void;
/**
 * Sanitizes the `message` values from the TypedData
 *
 * @param typedData TypedData payload
 * @param typeMapping a TypeMapping pre-generated from the TypedData
 */
export declare const sanitizeMessage: (typedData: TypedData, typeMapping: TypeMapping) => void;
/**
 * Recursively examines each value and determines type from the type mapping to
 * format and sanitize the value if needed.
 *
 * Currently this will only convert number values into a consistent hex format,
 * but in the future additional transformations may be necessary.
 *
 * @param typeName Name of the type we are starting from
 * @param values The root object containing the keys and values
 * @param typeMapping The type mapping that represents this data
 */
export declare const sanitizeType: (typeName: string, values: any, typeMapping: TypeMapping) => void;
/**
 * Maps the type definitions from the typed data for easy look-up.
 * Top level keys represent the structs defined, while top-level values
 * are an object keyed by property with string values of the type name.
 *
 * For example:
 * {
 *    EIP712Domain: {
 *      name: 'string',
 *      version: 'string',
 *      chainId: 'uint256'
 *    }
 * }
 * @param typedData The TypedData to map
 * @returns {TypeMapping} the mapped data schema
 */
export declare function createTypeMapping(typedData: TypedData): TypeMapping;
export {};
