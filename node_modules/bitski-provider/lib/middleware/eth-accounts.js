"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEthAccountsMiddleware = void 0;
const eth_provider_types_1 = require("eth-provider-types");
const json_rpc_engine_1 = require("json-rpc-engine");
const constants_1 = require("../constants");
const request_context_1 = require("../utils/request-context");
const fetch_1 = require("../utils/fetch");
const REFRESH = Symbol();
const ANON_USER = 'anonymous';
// We fetch accounts directly in this middleware so that we ensure we're always
// hitting Bitski direcly and not another RPC url (e.g. for custom RPCs/chains).
const fetchAccounts = async (req, config) => {
    const headers = Object.assign({}, config.additionalHeaders);
    if (config.getAccessToken) {
        headers['Authorization'] = `Bearer ${await config.getAccessToken()}`;
    }
    return (await (0, fetch_1.fetchJsonRpcWithRetry)(config.fetch, 5, `${constants_1.BITSKI_RPC_BASE_URL}/mainnet`, {
        method: 'POST',
        headers,
        body: {
            id: req.id,
            jsonrpc: req.jsonrpc,
            method: eth_provider_types_1.EthMethod.eth_accounts,
            params: req.params,
        },
    }));
};
const createEthAccountsMiddleware = () => {
    const cache = new Map();
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a, _b;
        if (req.method !== eth_provider_types_1.EthMethod.eth_accounts && req.method !== eth_provider_types_1.EthMethod.eth_requestAccounts) {
            return next();
        }
        const { config } = (0, request_context_1.getRequestContext)(req);
        const user = await ((_a = config.getUser) === null || _a === void 0 ? void 0 : _a.call(config));
        const userId = (_b = user === null || user === void 0 ? void 0 : user.id) !== null && _b !== void 0 ? _b : ANON_USER;
        let accounts = cache.get(userId);
        if (!accounts || accounts === REFRESH) {
            if (!accounts && (user === null || user === void 0 ? void 0 : user.accounts)) {
                accounts = user.accounts;
            }
            else {
                accounts = await fetchAccounts(req, config);
            }
            cache.set(userId, accounts);
            setTimeout(() => cache.set(userId, REFRESH), 5 * 60 * 1000);
        }
        res.result = accounts;
    });
};
exports.createEthAccountsMiddleware = createEthAccountsMiddleware;
//# sourceMappingURL=eth-accounts.js.map