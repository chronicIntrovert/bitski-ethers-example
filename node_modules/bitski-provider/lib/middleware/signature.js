"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSignatureMiddleware = void 0;
const eth_provider_types_1 = require("eth-provider-types");
const json_rpc_engine_1 = require("json-rpc-engine");
const constants_1 = require("../constants");
const request_context_1 = require("../utils/request-context");
const createSignatureMiddleware = () => {
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        if (!constants_1.SIGN_METHODS.includes(req.method)) {
            return next();
        }
        const context = (0, request_context_1.getRequestContext)(req);
        const requiresLocalSend = !constants_1.SUPPORTED_CHAIN_IDS.includes(context.chain.chainId) &&
            req.method === eth_provider_types_1.EthMethod.eth_sendTransaction;
        // When we don't support a chain on the server (e.g. custom RPC url), we need
        // to sign the transaction via our flow, then send the signed payload locally
        const method = requiresLocalSend
            ? eth_provider_types_1.EthMethod.eth_signTransaction
            : req.method;
        const signedResponse = await context.config.sign(method, req.params, context);
        res.result = requiresLocalSend
            ? context.request({ method: eth_provider_types_1.EthMethod.eth_sendRawTransaction, params: [signedResponse] })
            : signedResponse;
    });
};
exports.createSignatureMiddleware = createSignatureMiddleware;
//# sourceMappingURL=signature.js.map