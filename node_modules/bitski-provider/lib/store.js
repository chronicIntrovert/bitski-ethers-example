"use strict";
// Default implementation of generic store interface.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitskiProviderStateStore = exports.LocalStorageStore = exports.CURRENT_CHAIN_STORAGE_KEY = exports.CHAINS_STORAGE_KEY = void 0;
const constants_1 = require("./constants");
const decoders_1 = require("decoders");
exports.CHAINS_STORAGE_KEY = 'bitski-chains';
exports.CURRENT_CHAIN_STORAGE_KEY = 'bitski-current-chain';
// A decoder for EthChainDefinitionWithRpcUrl
const chainDefinitionDecoder = (0, decoders_1.object)({
    chainId: decoders_1.string,
    rpcUrls: (0, decoders_1.nonEmptyArray)(decoders_1.string),
    chainName: (0, decoders_1.optional)(decoders_1.string),
    nativeCurrency: (0, decoders_1.optional)((0, decoders_1.object)({
        name: decoders_1.string,
        symbol: decoders_1.string,
        decimals: decoders_1.number,
    })),
    blockExplorerUrls: (0, decoders_1.optional)((0, decoders_1.array)(decoders_1.string)),
    iconUrls: (0, decoders_1.optional)((0, decoders_1.array)(decoders_1.string)), // Currently ignored.
});
// Uses localStorage or sessionStorage (pass which one you want in constructor).
class LocalStorageStore {
    constructor(storage = localStorage) {
        this.storage = storage;
    }
    keys() {
        return Object.keys(this.storage);
    }
    async clear() {
        this.storage.clear();
    }
    async getItem(key) {
        const value = this.storage.getItem(key);
        return value ? JSON.parse(value) : undefined;
    }
    async setItem(key, value) {
        this.storage.setItem(key, JSON.stringify(value));
    }
    async clearItem(key) {
        this.storage.removeItem(key);
    }
}
exports.LocalStorageStore = LocalStorageStore;
function ensureRpcUrl(definition) {
    if (!definition.rpcUrls || definition.rpcUrls.length === 0) {
        const chainId = definition.chainId;
        if (!constants_1.SUPPORTED_CHAIN_IDS.includes(chainId)) {
            throw new Error(`no RPC url found for chainId ${chainId}, and it is not a chain supported directly by Bitski`);
        }
        definition.rpcUrls = [`https://api.bitski.com/v1/web3/chains/${parseInt(chainId, 16)}`];
    }
}
class BitskiProviderStateStore {
    constructor(store) {
        var _a, _b;
        this.store = store;
        this.load();
        (_b = (_a = this.store).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, async () => this.load());
    }
    async findChain(chainId) {
        const chains = await this.chains;
        return chains.find((chain) => chain.chainId === chainId);
    }
    async addChain(definition) {
        if (await this.findChain(definition.chainId)) {
            // Chain already exists, return success
            return;
        }
        ensureRpcUrl(definition);
        const chains = await this.chains;
        chains.push(definition);
        this.store.setItem(exports.CHAINS_STORAGE_KEY, chains);
    }
    async getCurrentChainId() {
        return this.currentChainId;
    }
    async setCurrentChainId(chainId) {
        this.currentChainId = Promise.resolve(chainId);
        this.store.setItem(exports.CURRENT_CHAIN_STORAGE_KEY, chainId);
    }
    load() {
        this.chains = Promise.resolve(this.store.getItem(exports.CHAINS_STORAGE_KEY)).then((chains) => {
            var _a;
            const result = (0, decoders_1.array)(chainDefinitionDecoder).decode(chains);
            return (_a = result.value) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_CHAINS.slice();
        });
        this.currentChainId = Promise.resolve(this.store.getItem(exports.CURRENT_CHAIN_STORAGE_KEY)).then((chainId) => {
            var _a;
            const result = decoders_1.string.decode(chainId);
            return (_a = result.value) !== null && _a !== void 0 ? _a : '0x1';
        });
    }
}
exports.BitskiProviderStateStore = BitskiProviderStateStore;
//# sourceMappingURL=store.js.map