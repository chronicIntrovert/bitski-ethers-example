import SafeEventEmitter from '@metamask/safe-event-emitter';
import { createInflightCacheMiddleware } from 'eth-json-rpc-middleware/dist/inflight-cache';
import { EthEvent, EthMethod, } from 'eth-provider-types';
import { JsonRpcEngine, createAsyncMiddleware, } from 'json-rpc-engine';
import { BITSKI_API_BASE_URL, BITSKI_SIGNER_BASE_URL, UNAUTHORIZED_ERRORS } from './constants';
import { createBlockCacheMiddleware } from './middleware/block-cache';
import { createChainManagementMiddleware } from './middleware/chain-management';
import { createEthAccountsMiddleware } from './middleware/eth-accounts';
import { createFetchRestMiddleware } from './middleware/fetch-rest';
import { createFetchRpcMiddleware } from './middleware/fetch-rpc';
import { createFilterMiddleware } from './middleware/filter';
import { createFixtureMiddleware } from './middleware/fixture';
import { createSignatureMiddleware } from './middleware/signature';
import { createSubscriptionMiddleware } from './middleware/subscription';
import { createTransactionValidatorMiddleware } from './middleware/transaction-validator';
import { createTypedDataSanitizerMiddleware } from './middleware/typed-data-sanitizer';
import createBrowserSigner from './signers/browser';
import { BitskiProviderStateStore, LocalStorageStore } from './store';
import { assert, expect } from './utils/type-utils';
// Some eth methods result in a subscription being created, and return the id of that subscription.
// We need to keep track of the subscription id and the chain id it was created on, so we can
// call future methods to interact with or unsubscribe from the subscription.
const SUB_METHODS = new Set([
    EthMethod.eth_subscribe,
    EthMethod.eth_newFilter,
    EthMethod.eth_newBlockFilter,
    EthMethod.eth_newPendingTransactionFilter,
]);
const SUB_INTERACTION_METHODS = new Set([
    EthMethod.eth_getFilterChanges,
    EthMethod.eth_getFilterLogs,
]);
const UNSUB_METHODS = new Set([EthMethod.eth_unsubscribe, EthMethod.eth_uninstallFilter]);
export class BitskiProvider {
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.engine = new JsonRpcEngine();
        this.events = new SafeEventEmitter();
        this.destructors = [];
        this.requestId = 0;
        this.didEmitConnect = false;
        this.activeSubs = new Set();
        this.config = Object.assign(Object.assign({}, config), { fetch: (_a = config.fetch) !== null && _a !== void 0 ? _a : fetch, additionalHeaders: Object.assign({ 'X-API-KEY': config.clientId, 'X-CLIENT-ID': config.clientId, 'X-CLIENT-VERSION': "bitski-provider-v2.0.0" }, ((_b = config.additionalHeaders) !== null && _b !== void 0 ? _b : {})), apiBaseUrl: (_c = config.apiBaseUrl) !== null && _c !== void 0 ? _c : BITSKI_API_BASE_URL, signerBaseUrl: (_d = config.signerBaseUrl) !== null && _d !== void 0 ? _d : BITSKI_SIGNER_BASE_URL, store: (_e = config.store) !== null && _e !== void 0 ? _e : new LocalStorageStore(), sign: (_f = config.sign) !== null && _f !== void 0 ? _f : createBrowserSigner() });
        this.store = new BitskiProviderStateStore(this.config.store);
        // Setup the engine
        const engine = this.engine;
        (_g = config.prependMiddleware) === null || _g === void 0 ? void 0 : _g.forEach((middleware) => 
        // TODO: Need to typecast because JSON RPC engine middleware can't have
        // additional props on it, can get rid of this once we get rid of JSON RPC engine
        engine.push(createAsyncMiddleware(middleware)));
        // Handles static responses
        engine.push(createFixtureMiddleware());
        engine.push(createChainManagementMiddleware());
        if (!config.disableValidation) {
            // Ensures that transactions are well formed (nonce, gas, gasPrice, from) before they are sent to Bitski
            engine.push(createTypedDataSanitizerMiddleware());
            engine.push(createTransactionValidatorMiddleware());
        }
        if (!config.disableCaching) {
            engine.push(createBlockCacheMiddleware());
        }
        engine.push(createFilterMiddleware());
        engine.push(createSubscriptionMiddleware());
        if (!config.disableCaching) {
            engine.push(createInflightCacheMiddleware());
        }
        engine.push(createEthAccountsMiddleware());
        engine.push(createSignatureMiddleware());
        engine.push(createFetchRestMiddleware());
        engine.push(createFetchRpcMiddleware());
    }
    async requestWithExtra(request, extra) {
        var _a, _b;
        const { method, params } = request;
        let chainId;
        if (SUB_INTERACTION_METHODS.has(method) || UNSUB_METHODS.has(method)) {
            const id = params === null || params === void 0 ? void 0 : params[0];
            assert(this.activeSubs.has(id), `Subscription/filter not found for id: ${id}`);
            const parts = id.split(':');
            // extract chain and subscription id from compound id
            chainId = parts[0];
            params[0] = parts[1];
            if (UNSUB_METHODS.has(method)) {
                this.activeSubs.delete(id);
            }
        }
        else {
            chainId = await this.store.getCurrentChainId();
        }
        try {
            let result = await this.requestWithChain(chainId, request, { extra });
            if (SUB_METHODS.has(method)) {
                // Ensure the subscription id is unique across chains
                // by creating unique compound id
                result = `${chainId}:${result}`;
                this.activeSubs.add(result);
            }
            return result;
        }
        catch (err) {
            if (UNAUTHORIZED_ERRORS.some((phrase) => err.message.includes(phrase))) {
                await ((_b = (_a = this.config).clearAccessToken) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
            throw err;
        }
    }
    async request(request) {
        return this.requestWithExtra(request);
    }
    supportsSubscriptions() {
        return true;
    }
    isConnected() {
        return true;
    }
    on(eventName, listener) {
        this.events.on(eventName, listener);
        // Don't emit `connect` until after the first connect listener has been
        // added, to ensure apps have time to set up their listeners.
        if (eventName === EthEvent.connect && !this.didEmitConnect) {
            this.didEmitConnect = true;
            this.store.getCurrentChainId().then((chainId) => {
                // Wait a tick to allow any other listeners to be added
                setTimeout(() => {
                    this.events.emit(EthEvent.connect, { chainId });
                });
            });
        }
    }
    removeListener(eventName, listener) {
        this.events.removeListener(eventName, listener);
    }
    destroy() {
        var _a, _b;
        this.destructors.forEach((destroy) => destroy());
        (_b = (_a = this.config.store).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    async requestWithChain(chainId, { method, params }, opts) {
        const chain = expect(await this.store.findChain(chainId), 'expected a chain');
        const context = {
            chain,
            config: this.config,
            store: this.store,
            emit: this.events.emit.bind(this.events),
            extra: opts === null || opts === void 0 ? void 0 : opts.extra,
            request: (req, opts) => this.requestWithChain(chainId, req, opts),
            addDestructor: (destroy) => this.destructors.push(destroy),
        };
        const req = {
            id: this.requestId++,
            jsonrpc: '2.0',
            method,
            params: params,
            context,
            // Used by block-cache middleware
            skipCache: !!(opts === null || opts === void 0 ? void 0 : opts.skipCache),
        };
        const res = await this.engine.handle(req);
        if (res.error !== undefined) {
            throw res.error;
        }
        else {
            // TODO: Fix this type cast
            return res.result;
        }
    }
}
export const createBitskiProvider = (config) => {
    return new BitskiProvider(config);
};
