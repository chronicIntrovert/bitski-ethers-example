import { PollingBlockTracker } from 'eth-block-tracker';
import { getRequestContext } from './request-context';
export default class LegacyMiddlewareProvider {
    constructor(context) {
        this.context = context;
        this.blockTracker = new PollingBlockTracker({
            // The only method used in block trackers is `sendAsync`
            provider: this,
            pollingInterval: context.config.pollingInterval,
            setSkipCacheFlag: true,
        });
    }
    sendAsync(
    // Skip cache comes from block tracker and legacy middlewares
    request, callback) {
        this.context
            .request({ method: request.method, params: request.params }, {
            skipCache: request.skipCache,
        })
            .then((result) => {
            callback(null, { result });
        })
            .catch((err) => {
            callback(err);
        });
    }
}
const PROVIDERS = new Map();
// exported for tests
export const clearLegacyProviders = () => PROVIDERS.clear();
export const getLegacyMiddlewareProviderFor = (context) => {
    let provider = PROVIDERS.get(context.chain.chainId);
    if (!provider) {
        provider = new LegacyMiddlewareProvider(context);
        PROVIDERS.set(context.chain.chainId, provider);
    }
    return provider;
};
export const createLegacyMiddleware = (createMiddleware) => {
    const MIDDLEWARES = new Map();
    const getMiddlewareFor = (context) => {
        let middleware = MIDDLEWARES.get(context.chain.chainId);
        if (!middleware) {
            const legacyProvider = getLegacyMiddlewareProviderFor(context);
            middleware = createMiddleware({
                context,
                provider: legacyProvider,
                blockTracker: legacyProvider.blockTracker,
            });
            MIDDLEWARES.set(context.chain.chainId, middleware);
        }
        return middleware;
    };
    return (req, res, next, end) => {
        const context = getRequestContext(req);
        const middleware = getMiddlewareFor(context);
        middleware(req, res, next, end);
    };
};
