import { EthMethod } from 'eth-provider-types';
import { ethErrors } from 'eth-rpc-errors';
import { v4 as uuid } from 'uuid';
import { SUPPORTED_CHAIN_IDS } from '../constants';
/**
 * Responsible for creating the Transaction object from a given RPC payload
 * @param req JSON-RPC payload to extract the values from
 */
export const createBitskiTransaction = (method, params, chain, additionalContext) => {
    const context = createContext(method, params, chain, additionalContext);
    const kind = kindForMethod(method);
    const extractedPayload = createPayload(method, params);
    return {
        id: uuid(),
        kind,
        payload: extractedPayload,
        context,
    };
};
const createContext = (method, params, chain, additionalContext) => {
    switch (method) {
        case 'personal_sign':
        case EthMethod.eth_sign:
        case EthMethod.eth_sendTransaction:
        case EthMethod.eth_signTransaction: {
            return Object.assign({ chainId: parseInt(chain.chainId, 16), rpcUrl: !SUPPORTED_CHAIN_IDS.includes(chain.chainId) ? chain.rpcUrls[0] : undefined }, additionalContext);
        }
        case EthMethod.eth_signTypedData:
        case EthMethod.eth_signTypedData_v1:
        case EthMethod.eth_signTypedData_v3:
        case EthMethod.eth_signTypedData_v4:
            // The from address should be the first parameter as a 20 byte hex string
            if (params && (params === null || params === void 0 ? void 0 : params.length) > 0) {
                return Object.assign({ from: params[0], chainId: parseInt(chain.chainId, 16), rpcUrl: !SUPPORTED_CHAIN_IDS.includes(chain.chainId) ? chain.rpcUrls[0] : undefined }, additionalContext);
            }
            throw ethErrors.rpc.invalidParams('Missing from');
        default:
            throw ethErrors.rpc.internal('Unsupported method');
    }
};
/**
 * Responsible for creating the payload from a given RPC request
 * @param req JSON-RPC request to extract params from
 */
const createPayload = (method, params) => {
    switch (method) {
        case EthMethod.eth_sendTransaction:
        case EthMethod.eth_signTransaction:
            if (params && params.length > 0) {
                return params[0];
            }
            else {
                throw ethErrors.rpc.invalidParams('Missing transaction');
            }
        case EthMethod.eth_sign:
            if (params && params.length > 1) {
                return { from: params[0], message: params[1] };
            }
            else {
                throw ethErrors.rpc.invalidParams('Missing message');
            }
        case 'personal_sign':
            if (params && params.length > 1) {
                // If the first param is a wallet address, flip the parameter ordering for personal_sign
                // so that it matches eth_sign. This is to gracefully respect Dapps who adopted Metamask's
                // API for personal_sign early, and recover from the wrong param order
                // when it is clearly identifiable.
                const [first, second] = params;
                if (first.startsWith('0x') && first.length === 42) {
                    return { from: first, message: second };
                }
                return { from: second, message: first };
            }
            else {
                throw ethErrors.rpc.invalidParams('Missing message');
            }
        case EthMethod.eth_signTypedData:
        case EthMethod.eth_signTypedData_v1:
        case EthMethod.eth_signTypedData_v3:
        case EthMethod.eth_signTypedData_v4:
            if (params && params.length > 1) {
                return params[1];
            }
            else {
                throw ethErrors.rpc.invalidParams('Missing typed data');
            }
        default:
            throw ethErrors.rpc.internal('Unsupported method');
    }
};
/**
 * Determines a BitskiTransaction.Kind value from a given RPC method name
 * @param method The JSON-RPC method being requested
 */
const kindForMethod = (method) => {
    switch (method) {
        case EthMethod.eth_sendTransaction:
            return "ETH_SEND_TRANSACTION" /* SendTransaction */;
        case EthMethod.eth_signTransaction:
            return "ETH_SIGN_TRANSACTION" /* SignTransaction */;
        case EthMethod.eth_sign:
        case 'personal_sign':
            return "ETH_SIGN" /* Sign */;
        case EthMethod.eth_signTypedData:
            return "ETH_SIGN_TYPED_DATA" /* SignTypedData */;
        case EthMethod.eth_signTypedData_v1:
            return "ETH_SIGN_TYPED_DATA_V1" /* SignTypedDataV1 */;
        case EthMethod.eth_signTypedData_v3:
            return "ETH_SIGN_TYPED_DATA_V3" /* SignTypedDataV3 */;
        case EthMethod.eth_signTypedData_v4:
            return "ETH_SIGN_TYPED_DATA_V4" /* SignTypedDataV4 */;
        default:
            throw ethErrors.rpc.internal('Unsupported method');
    }
};
