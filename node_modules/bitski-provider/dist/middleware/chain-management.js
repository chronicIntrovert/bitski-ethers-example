import { EthEvent, EthMethod, } from 'eth-provider-types';
import { ethErrors } from 'eth-rpc-errors';
import { createAsyncMiddleware } from 'json-rpc-engine';
import { getRequestContext } from '../utils/request-context';
import { expect } from '../utils/type-utils';
export const createChainManagementMiddleware = () => {
    return createAsyncMiddleware(async (req, res, next) => {
        var _a, _b;
        const { method } = req;
        const context = getRequestContext(req);
        if (method === EthMethod.eth_chainId) {
            res.result = context.chain.chainId;
            return;
        }
        if (method === EthMethod.wallet_addEthereumChain) {
            const definition = expect((_a = req.params) === null || _a === void 0 ? void 0 : _a[0], 'addEthereumChain requires a chain definition parameter');
            await context.store.addChain(definition);
            res.result = null;
            return;
        }
        if (method === EthMethod.wallet_switchEthereumChain) {
            const chainDetails = expect((_b = req.params) === null || _b === void 0 ? void 0 : _b[0], 'switchEthereumChain requires a chainId');
            const chain = await context.store.findChain(chainDetails.chainId);
            if (!chain) {
                throw ethErrors.provider.userRejectedRequest({ message: 'Chain does not exist' });
            }
            await context.store.setCurrentChainId(chainDetails.chainId);
            context.emit(EthEvent.chainChanged, chainDetails.chainId);
            res.result = null;
            return;
        }
        return next();
    });
};
