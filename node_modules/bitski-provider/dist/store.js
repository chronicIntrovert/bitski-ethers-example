// Default implementation of generic store interface.
import { DEFAULT_CHAINS, SUPPORTED_CHAIN_IDS } from './constants';
import { array, object, optional, string, number, nonEmptyArray } from 'decoders';
export const CHAINS_STORAGE_KEY = 'bitski-chains';
export const CURRENT_CHAIN_STORAGE_KEY = 'bitski-current-chain';
// A decoder for EthChainDefinitionWithRpcUrl
const chainDefinitionDecoder = object({
    chainId: string,
    rpcUrls: nonEmptyArray(string),
    chainName: optional(string),
    nativeCurrency: optional(object({
        name: string,
        symbol: string,
        decimals: number,
    })),
    blockExplorerUrls: optional(array(string)),
    iconUrls: optional(array(string)), // Currently ignored.
});
// Uses localStorage or sessionStorage (pass which one you want in constructor).
export class LocalStorageStore {
    constructor(storage = localStorage) {
        this.storage = storage;
    }
    keys() {
        return Object.keys(this.storage);
    }
    async clear() {
        this.storage.clear();
    }
    async getItem(key) {
        const value = this.storage.getItem(key);
        return value ? JSON.parse(value) : undefined;
    }
    async setItem(key, value) {
        this.storage.setItem(key, JSON.stringify(value));
    }
    async clearItem(key) {
        this.storage.removeItem(key);
    }
}
function ensureRpcUrl(definition) {
    if (!definition.rpcUrls || definition.rpcUrls.length === 0) {
        const chainId = definition.chainId;
        if (!SUPPORTED_CHAIN_IDS.includes(chainId)) {
            throw new Error(`no RPC url found for chainId ${chainId}, and it is not a chain supported directly by Bitski`);
        }
        definition.rpcUrls = [`https://api.bitski.com/v1/web3/chains/${parseInt(chainId, 16)}`];
    }
}
export class BitskiProviderStateStore {
    constructor(store) {
        var _a, _b;
        this.store = store;
        this.load();
        (_b = (_a = this.store).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, async () => this.load());
    }
    async findChain(chainId) {
        const chains = await this.chains;
        return chains.find((chain) => chain.chainId === chainId);
    }
    async addChain(definition) {
        if (await this.findChain(definition.chainId)) {
            // Chain already exists, return success
            return;
        }
        ensureRpcUrl(definition);
        const chains = await this.chains;
        chains.push(definition);
        this.store.setItem(CHAINS_STORAGE_KEY, chains);
    }
    async getCurrentChainId() {
        return this.currentChainId;
    }
    async setCurrentChainId(chainId) {
        this.currentChainId = Promise.resolve(chainId);
        this.store.setItem(CURRENT_CHAIN_STORAGE_KEY, chainId);
    }
    load() {
        this.chains = Promise.resolve(this.store.getItem(CHAINS_STORAGE_KEY)).then((chains) => {
            var _a;
            const result = array(chainDefinitionDecoder).decode(chains);
            return (_a = result.value) !== null && _a !== void 0 ? _a : DEFAULT_CHAINS.slice();
        });
        this.currentChainId = Promise.resolve(this.store.getItem(CURRENT_CHAIN_STORAGE_KEY)).then((chainId) => {
            var _a;
            const result = string.decode(chainId);
            return (_a = result.value) !== null && _a !== void 0 ? _a : '0x1';
        });
    }
}
