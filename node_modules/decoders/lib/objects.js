'use strict'

exports.__esModule = true
exports.dict = dict
exports.exact = exact
exports.inexact = inexact
exports.mapping = mapping
exports.object = object
exports.pojo = void 0

var _annotate = require('../annotate')

var _Decoder = require('../Decoder')

var _utils = require('../_utils')

var pojo = (0, _Decoder.define)(function (blob, ok, err) {
  return blob !== null && blob !== undefined && typeof blob === 'object' && Object.prototype.toString.call(blob) === '[object Object]' ? ok(blob) : err('Must be an object')
})

exports.pojo = pojo

function object(decodersByKey) {
  var knownKeys = new Set(Object.keys(decodersByKey))
  return pojo.then(function (plainObj, ok, err) {
    var actualKeys = new Set(Object.keys(plainObj))

    var missingKeys = (0, _utils.subtract)(knownKeys, actualKeys)
    var record = {}
    var errors = null
    Object.keys(decodersByKey).forEach(function (key) {
      var decoder = decodersByKey[key]
      var rawValue = plainObj[key]
      var result = decoder.decode(rawValue)

      if (result.ok) {
        var value = result.value

        if (value !== undefined) {
          record[key] = value
        }

        missingKeys['delete'](key)
      } else {
        var ann = result.error

        if (rawValue === undefined) {
          missingKeys.add(key)
        } else {
          if (errors === null) {
            errors = {}
          }

          errors[key] = ann
        }
      }
    })

    if (errors || missingKeys.size > 0) {
      var objAnn = (0, _annotate.annotateObject)(plainObj)

      if (errors) {
        objAnn = (0, _annotate.merge)(objAnn, errors)
      }

      if (missingKeys.size > 0) {
        var errMsg = Array.from(missingKeys)
          .map(function (key) {
            return '"' + key + '"'
          })
          .join(', ')
        var pluralized = missingKeys.size > 1 ? 'keys' : 'key'
        objAnn = (0, _annotate.updateText)(objAnn, 'Missing ' + pluralized + ': ' + errMsg)
      }

      return err(objAnn)
    }

    return ok(record)
  })
}

function exact(decodersByKey) {
  var allowedKeys = new Set(Object.keys(decodersByKey))

  var checked = pojo.reject(function (plainObj) {
    var actualKeys = new Set(Object.keys(plainObj))
    var extraKeys = (0, _utils.subtract)(actualKeys, allowedKeys)
    return extraKeys.size > 0 ? 'Unexpected extra keys: ' + Array.from(extraKeys).join(', ') : null
  })

  return checked.then(object(decodersByKey).decode)
}

function inexact(decodersByKey) {
  return pojo.then(function (plainObj) {
    var allkeys = new Set(Object.keys(plainObj))
    var decoder = object(decodersByKey).transform(function (safepart) {
      var safekeys = new Set(Object.keys(decodersByKey))

      safekeys.forEach(function (k) {
        return allkeys.add(k)
      })
      var rv = {}
      allkeys.forEach(function (k) {
        if (safekeys.has(k)) {
          var value = safepart[k]

          if (value !== undefined) {
            rv[k] = value
          }
        } else {
          rv[k] = plainObj[k]
        }
      })
      return rv
    })
    return decoder.decode(plainObj)
  })
}

function dict(decoder) {
  return pojo.then(function (plainObj, ok, err) {
    var rv = {}
    var errors = null
    Object.keys(plainObj).forEach(function (key) {
      var value = plainObj[key]
      var result = decoder.decode(value)

      if (result.ok) {
        if (errors === null) {
          rv[key] = result.value
        }
      } else {
        rv = {}

        if (errors === null) {
          errors = {}
        }

        errors[key] = result.error
      }
    })

    if (errors !== null) {
      return err((0, _annotate.merge)((0, _annotate.annotateObject)(plainObj), errors))
    } else {
      return ok(rv)
    }
  })
}

function mapping(decoder) {
  return dict(decoder).transform(function (obj) {
    return new Map(
      Object.keys(obj).map(function (key) {
        return [key, obj[key]]
      })
    )
  })
}
