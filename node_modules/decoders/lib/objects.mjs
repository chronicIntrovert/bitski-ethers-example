import { annotateObject, merge, updateText } from '../annotate.mjs'
import { define } from '../Decoder.mjs'
import { subtract } from '../_utils.mjs'

export var pojo = define(function (blob, ok, err) {
  return blob !== null && blob !== undefined && typeof blob === 'object' && Object.prototype.toString.call(blob) === '[object Object]' ? ok(blob) : err('Must be an object')
})

export function object(decodersByKey) {
  var knownKeys = new Set(Object.keys(decodersByKey))
  return pojo.then(function (plainObj, ok, err) {
    var actualKeys = new Set(Object.keys(plainObj))

    var missingKeys = subtract(knownKeys, actualKeys)
    var record = {}
    var errors = null
    Object.keys(decodersByKey).forEach(function (key) {
      var decoder = decodersByKey[key]
      var rawValue = plainObj[key]
      var result = decoder.decode(rawValue)

      if (result.ok) {
        var value = result.value

        if (value !== undefined) {
          record[key] = value
        }

        missingKeys['delete'](key)
      } else {
        var ann = result.error

        if (rawValue === undefined) {
          missingKeys.add(key)
        } else {
          if (errors === null) {
            errors = {}
          }

          errors[key] = ann
        }
      }
    })

    if (errors || missingKeys.size > 0) {
      var objAnn = annotateObject(plainObj)

      if (errors) {
        objAnn = merge(objAnn, errors)
      }

      if (missingKeys.size > 0) {
        var errMsg = Array.from(missingKeys)
          .map(function (key) {
            return '"' + key + '"'
          })
          .join(', ')
        var pluralized = missingKeys.size > 1 ? 'keys' : 'key'
        objAnn = updateText(objAnn, 'Missing ' + pluralized + ': ' + errMsg)
      }

      return err(objAnn)
    }

    return ok(record)
  })
}

export function exact(decodersByKey) {
  var allowedKeys = new Set(Object.keys(decodersByKey))

  var checked = pojo.reject(function (plainObj) {
    var actualKeys = new Set(Object.keys(plainObj))
    var extraKeys = subtract(actualKeys, allowedKeys)
    return extraKeys.size > 0 ? 'Unexpected extra keys: ' + Array.from(extraKeys).join(', ') : null
  })

  return checked.then(object(decodersByKey).decode)
}

export function inexact(decodersByKey) {
  return pojo.then(function (plainObj) {
    var allkeys = new Set(Object.keys(plainObj))
    var decoder = object(decodersByKey).transform(function (safepart) {
      var safekeys = new Set(Object.keys(decodersByKey))

      safekeys.forEach(function (k) {
        return allkeys.add(k)
      })
      var rv = {}
      allkeys.forEach(function (k) {
        if (safekeys.has(k)) {
          var value = safepart[k]

          if (value !== undefined) {
            rv[k] = value
          }
        } else {
          rv[k] = plainObj[k]
        }
      })
      return rv
    })
    return decoder.decode(plainObj)
  })
}

export function dict(decoder) {
  return pojo.then(function (plainObj, ok, err) {
    var rv = {}
    var errors = null
    Object.keys(plainObj).forEach(function (key) {
      var value = plainObj[key]
      var result = decoder.decode(value)

      if (result.ok) {
        if (errors === null) {
          rv[key] = result.value
        }
      } else {
        rv = {}

        if (errors === null) {
          errors = {}
        }

        errors[key] = result.error
      }
    })

    if (errors !== null) {
      return err(merge(annotateObject(plainObj), errors))
    } else {
      return ok(rv)
    }
  })
}

export function mapping(decoder) {
  return dict(decoder).transform(function (obj) {
    return new Map(
      Object.keys(obj).map(function (key) {
        return [key, obj[key]]
      })
    )
  })
}
