import { annotate } from './annotate.mjs'
import { formatInline } from './format.mjs'
import { err as makeErr, ok as makeOk } from './result.mjs'

function noThrow(fn) {
  return function (t) {
    try {
      var v = fn(t)
      return makeOk(v)
    } catch (e) {
      return makeErr(annotate(t, e instanceof Error ? e.message : String(e)))
    }
  }
}

function format(err, formatter) {
  var formatted = formatter(err)

  if (typeof formatted === 'string') {
    var _err = new Error('\n' + formatted)

    _err.name = 'Decoding error'
    return _err
  } else {
    return formatted
  }
}

export function define(fn) {
  function decode(blob) {
    return fn(blob, makeOk, function (msg) {
      return makeErr(typeof msg === 'string' ? annotate(blob, msg) : msg)
    })
  }

  function verify(blob, formatter) {
    if (formatter === void 0) {
      formatter = formatInline
    }

    var result = decode(blob)

    if (result.ok) {
      return result.value
    } else {
      throw format(result.error, formatter)
    }
  }

  function value(blob) {
    return decode(blob).value
  }

  function transform(transformFn) {
    return then(noThrow(transformFn))
  }

  function refine(predicateFn, errmsg) {
    return reject(function (value) {
      return predicateFn(value) ? null : errmsg
    })
  }

  function then(next) {
    return define(function (blob, ok, err) {
      var result = decode(blob)
      return result.ok ? next(result.value, ok, err) : result
    })
  }

  function reject(rejectFn) {
    return then(function (value, ok, err) {
      var errmsg = rejectFn(value)
      return errmsg === null ? ok(value) : err(typeof errmsg === 'string' ? annotate(value, errmsg) : errmsg)
    })
  }

  function describe(message) {
    return define(function (blob, _, err) {
      var result = decode(blob)

      if (result.ok) {
        return result
      } else {
        return err(annotate(result.error, message))
      }
    })
  }

  function peek_UNSTABLE(next) {
    return define(function (blob, ok, err) {
      var result = decode(blob)
      return result.ok ? next([blob, result.value], ok, err) : result
    })
  }

  return Object.freeze({
    verify: verify,
    value: value,
    decode: decode,
    transform: transform,
    refine: refine,
    reject: reject,
    describe: describe,
    then: then,
    peek_UNSTABLE: peek_UNSTABLE,
  })
}
