import {
  __commonJS,
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/eth-provider-types/index.js
var require_eth_provider_types = __commonJS({
  "node_modules/eth-provider-types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthProviderMessageType = exports.EthEvent = exports.EthProviderRpcErrorCode = exports.EthBlockNumberTag = exports.EthMethod = void 0;
    var EthMethod2;
    (function(EthMethod3) {
      EthMethod3["web3_clientVersion"] = "web3_clientVersion";
      EthMethod3["web3_sha3"] = "web3_sha3";
      EthMethod3["net_version"] = "net_version";
      EthMethod3["net_listening"] = "net_listening";
      EthMethod3["net_peerCount"] = "net_peerCount";
      EthMethod3["eth_protocolVersion"] = "eth_protocolVersion";
      EthMethod3["eth_syncing"] = "eth_syncing";
      EthMethod3["eth_coinbase"] = "eth_coinbase";
      EthMethod3["eth_createAccessList"] = "eth_createAccessList";
      EthMethod3["eth_feeHistory"] = "eth_feeHistory";
      EthMethod3["eth_mining"] = "eth_mining";
      EthMethod3["eth_hashrate"] = "eth_hashrate";
      EthMethod3["eth_gasPrice"] = "eth_gasPrice";
      EthMethod3["eth_accounts"] = "eth_accounts";
      EthMethod3["eth_requestAccounts"] = "eth_requestAccounts";
      EthMethod3["eth_blockNumber"] = "eth_blockNumber";
      EthMethod3["eth_getBalance"] = "eth_getBalance";
      EthMethod3["eth_getStorageAt"] = "eth_getStorageAt";
      EthMethod3["eth_getTransactionCount"] = "eth_getTransactionCount";
      EthMethod3["eth_getBlockTransactionCountByHash"] = "eth_getBlockTransactionCountByHash";
      EthMethod3["eth_getBlockTransactionCountByNumber"] = "eth_getBlockTransactionCountByNumber";
      EthMethod3["eth_getUncleCountByBlockHash"] = "eth_getUncleCountByBlockHash";
      EthMethod3["eth_getUncleCountByBlockNumber"] = "eth_getUncleCountByBlockNumber";
      EthMethod3["eth_getCode"] = "eth_getCode";
      EthMethod3["eth_sign"] = "eth_sign";
      EthMethod3["eth_signTransaction"] = "eth_signTransaction";
      EthMethod3["eth_signTypedData"] = "eth_signTypedData";
      EthMethod3["eth_signTypedData_v1"] = "eth_signTypedData_v1";
      EthMethod3["eth_signTypedData_v3"] = "eth_signTypedData_v3";
      EthMethod3["eth_signTypedData_v4"] = "eth_signTypedData_v4";
      EthMethod3["eth_sendTransaction"] = "eth_sendTransaction";
      EthMethod3["eth_sendRawTransaction"] = "eth_sendRawTransaction";
      EthMethod3["eth_call"] = "eth_call";
      EthMethod3["eth_estimateGas"] = "eth_estimateGas";
      EthMethod3["eth_getBlockByHash"] = "eth_getBlockByHash";
      EthMethod3["eth_getBlockByNumber"] = "eth_getBlockByNumber";
      EthMethod3["eth_getTransactionByHash"] = "eth_getTransactionByHash";
      EthMethod3["eth_getTransactionByBlockHashAndIndex"] = "eth_getTransactionByBlockHashAndIndex";
      EthMethod3["eth_getTransactionByBlockNumberAndIndex"] = "eth_getTransactionByBlockNumberAndIndex";
      EthMethod3["eth_getTransactionReceipt"] = "eth_getTransactionReceipt";
      EthMethod3["eth_getUncleByBlockHashAndIndex"] = "eth_getUncleByBlockHashAndIndex";
      EthMethod3["eth_getUncleByBlockNumberAndIndex"] = "eth_getUncleByBlockNumberAndIndex";
      EthMethod3["eth_maxPriorityFeePerGas"] = "eth_maxPriorityFeePerGas";
      EthMethod3["eth_newFilter"] = "eth_newFilter";
      EthMethod3["eth_newBlockFilter"] = "eth_newBlockFilter";
      EthMethod3["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
      EthMethod3["eth_uninstallFilter"] = "eth_uninstallFilter";
      EthMethod3["eth_getFilterChanges"] = "eth_getFilterChanges";
      EthMethod3["eth_getFilterLogs"] = "eth_getFilterLogs";
      EthMethod3["eth_getLogs"] = "eth_getLogs";
      EthMethod3["eth_getProof"] = "eth_getProof";
      EthMethod3["eth_getWork"] = "eth_getWork";
      EthMethod3["eth_submitWork"] = "eth_submitWork";
      EthMethod3["eth_submitHashrate"] = "eth_submitHashrate";
      EthMethod3["eth_chainId"] = "eth_chainId";
      EthMethod3["eth_subscribe"] = "eth_subscribe";
      EthMethod3["eth_unsubscribe"] = "eth_unsubscribe";
      EthMethod3["wallet_addEthereumChain"] = "wallet_addEthereumChain";
      EthMethod3["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
      EthMethod3["wallet_requestPermissions"] = "wallet_requestPermissions";
      EthMethod3["wallet_getPermissions"] = "wallet_getPermissions";
    })(EthMethod2 = exports.EthMethod || (exports.EthMethod = {}));
    var EthBlockNumberTag;
    (function(EthBlockNumberTag2) {
      EthBlockNumberTag2["Latest"] = "latest";
      EthBlockNumberTag2["Earliest"] = "earliest";
      EthBlockNumberTag2["Pending"] = "pending";
    })(EthBlockNumberTag = exports.EthBlockNumberTag || (exports.EthBlockNumberTag = {}));
    var EthProviderRpcErrorCode;
    (function(EthProviderRpcErrorCode2) {
      EthProviderRpcErrorCode2[EthProviderRpcErrorCode2["UserRejectedRequest"] = 4001] = "UserRejectedRequest";
      EthProviderRpcErrorCode2[EthProviderRpcErrorCode2["Unauthorized"] = 4100] = "Unauthorized";
      EthProviderRpcErrorCode2[EthProviderRpcErrorCode2["UnsupportedMethod"] = 4200] = "UnsupportedMethod";
      EthProviderRpcErrorCode2[EthProviderRpcErrorCode2["Disconnected"] = 4900] = "Disconnected";
      EthProviderRpcErrorCode2[EthProviderRpcErrorCode2["ChainDisconnected"] = 4901] = "ChainDisconnected";
    })(EthProviderRpcErrorCode = exports.EthProviderRpcErrorCode || (exports.EthProviderRpcErrorCode = {}));
    var EthEvent;
    (function(EthEvent2) {
      EthEvent2["message"] = "message";
      EthEvent2["connect"] = "connect";
      EthEvent2["disconnect"] = "disconnect";
      EthEvent2["chainChanged"] = "chainChanged";
      EthEvent2["accountsChanged"] = "accountsChanged";
      EthEvent2["data"] = "data";
    })(EthEvent = exports.EthEvent || (exports.EthEvent = {}));
    var EthProviderMessageType;
    (function(EthProviderMessageType2) {
      EthProviderMessageType2["eth_subscription"] = "eth_subscription";
    })(EthProviderMessageType = exports.EthProviderMessageType || (exports.EthProviderMessageType = {}));
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/@openid/appauth/built/errors.js
var require_errors = __commonJS({
  "node_modules/@openid/appauth/built/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AppAuthError = void 0;
    var AppAuthError = (
      /** @class */
      function() {
        function AppAuthError2(message, extras) {
          this.message = message;
          this.extras = extras;
        }
        return AppAuthError2;
      }()
    );
    exports.AppAuthError = AppAuthError;
  }
});

// node_modules/@openid/appauth/built/crypto_utils.js
var require_crypto_utils = __commonJS({
  "node_modules/@openid/appauth/built/crypto_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultCrypto = exports.textEncodeLite = exports.urlSafe = exports.bufferToString = void 0;
    var base64 = require_base64_js();
    var errors_1 = require_errors();
    var HAS_CRYPTO = typeof window !== "undefined" && !!window.crypto;
    var HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!window.crypto.subtle;
    var CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    function bufferToString(buffer) {
      var state = [];
      for (var i = 0; i < buffer.byteLength; i += 1) {
        var index = buffer[i] % CHARSET.length;
        state.push(CHARSET[index]);
      }
      return state.join("");
    }
    exports.bufferToString = bufferToString;
    function urlSafe(buffer) {
      var encoded = base64.fromByteArray(new Uint8Array(buffer));
      return encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
    exports.urlSafe = urlSafe;
    function textEncodeLite(str) {
      var buf = new ArrayBuffer(str.length);
      var bufView = new Uint8Array(buf);
      for (var i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return bufView;
    }
    exports.textEncodeLite = textEncodeLite;
    var DefaultCrypto2 = (
      /** @class */
      function() {
        function DefaultCrypto3() {
        }
        DefaultCrypto3.prototype.generateRandom = function(size) {
          var buffer = new Uint8Array(size);
          if (HAS_CRYPTO) {
            window.crypto.getRandomValues(buffer);
          } else {
            for (var i = 0; i < size; i += 1) {
              buffer[i] = Math.random() * CHARSET.length | 0;
            }
          }
          return bufferToString(buffer);
        };
        DefaultCrypto3.prototype.deriveChallenge = function(code) {
          if (code.length < 43 || code.length > 128) {
            return Promise.reject(new errors_1.AppAuthError("Invalid code length."));
          }
          if (!HAS_SUBTLE_CRYPTO) {
            return Promise.reject(new errors_1.AppAuthError("window.crypto.subtle is unavailable."));
          }
          return new Promise(function(resolve, reject) {
            crypto.subtle.digest("SHA-256", textEncodeLite(code)).then(function(buffer) {
              return resolve(urlSafe(new Uint8Array(buffer)));
            }, function(error) {
              return reject(error);
            });
          });
        };
        return DefaultCrypto3;
      }()
    );
    exports.DefaultCrypto = DefaultCrypto2;
  }
});

// node_modules/@openid/appauth/built/flags.js
var require_flags = __commonJS({
  "node_modules/@openid/appauth/built/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_PROFILE = exports.IS_LOG = void 0;
    exports.IS_LOG = true;
    exports.IS_PROFILE = false;
  }
});

// node_modules/@openid/appauth/built/logger.js
var require_logger = __commonJS({
  "node_modules/@openid/appauth/built/logger.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.profile = exports.log = void 0;
    var flags_1 = require_flags();
    function log(message) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (flags_1.IS_LOG) {
        var length_1 = args ? args.length : 0;
        if (length_1 > 0) {
          console.log.apply(console, __spreadArray([message], args));
        } else {
          console.log(message);
        }
      }
    }
    exports.log = log;
    var NATIVE_PROFILE_SUPPORT = typeof window !== "undefined" && !!window.performance && !!console.profile;
    function profile(target, propertyKey, descriptor) {
      if (flags_1.IS_PROFILE) {
        return performProfile(target, propertyKey, descriptor);
      } else {
        return descriptor;
      }
    }
    exports.profile = profile;
    function performProfile(target, propertyKey, descriptor) {
      var originalCallable = descriptor.value;
      var name = originalCallable.name;
      if (!name) {
        name = "anonymous function";
      }
      if (NATIVE_PROFILE_SUPPORT) {
        descriptor.value = function(args) {
          console.profile(name);
          var startTime = window.performance.now();
          var result = originalCallable.call.apply(originalCallable, __spreadArray([this || window], args));
          var duration = window.performance.now() - startTime;
          console.log(name + " took " + duration + " ms");
          console.profileEnd();
          return result;
        };
      } else {
        descriptor.value = function(args) {
          log("Profile start " + name);
          var start = Date.now();
          var result = originalCallable.call.apply(originalCallable, __spreadArray([this || window], args));
          var duration = Date.now() - start;
          log("Profile end " + name + " took " + duration + " ms.");
          return result;
        };
      }
      return descriptor;
    }
  }
});

// node_modules/@openid/appauth/built/authorization_request.js
var require_authorization_request = __commonJS({
  "node_modules/@openid/appauth/built/authorization_request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthorizationRequest = void 0;
    var crypto_utils_1 = require_crypto_utils();
    var logger_1 = require_logger();
    var SIZE = 10;
    var newState = function(crypto2) {
      return crypto2.generateRandom(SIZE);
    };
    var AuthorizationRequest2 = (
      /** @class */
      function() {
        function AuthorizationRequest3(request, crypto2, usePkce) {
          if (crypto2 === void 0) {
            crypto2 = new crypto_utils_1.DefaultCrypto();
          }
          if (usePkce === void 0) {
            usePkce = true;
          }
          this.crypto = crypto2;
          this.usePkce = usePkce;
          this.clientId = request.client_id;
          this.redirectUri = request.redirect_uri;
          this.scope = request.scope;
          this.responseType = request.response_type || AuthorizationRequest3.RESPONSE_TYPE_CODE;
          this.state = request.state || newState(crypto2);
          this.extras = request.extras;
          this.internal = request.internal;
        }
        AuthorizationRequest3.prototype.setupCodeVerifier = function() {
          var _this = this;
          if (!this.usePkce) {
            return Promise.resolve();
          } else {
            var codeVerifier_1 = this.crypto.generateRandom(128);
            var challenge = this.crypto.deriveChallenge(codeVerifier_1).catch(function(error) {
              logger_1.log("Unable to generate PKCE challenge. Not using PKCE", error);
              return void 0;
            });
            return challenge.then(function(result) {
              if (result) {
                _this.internal = _this.internal || {};
                _this.internal["code_verifier"] = codeVerifier_1;
                _this.extras = _this.extras || {};
                _this.extras["code_challenge"] = result;
                _this.extras["code_challenge_method"] = "S256";
              }
            });
          }
        };
        AuthorizationRequest3.prototype.toJson = function() {
          var _this = this;
          return this.setupCodeVerifier().then(function() {
            return {
              response_type: _this.responseType,
              client_id: _this.clientId,
              redirect_uri: _this.redirectUri,
              scope: _this.scope,
              state: _this.state,
              extras: _this.extras,
              internal: _this.internal
            };
          });
        };
        AuthorizationRequest3.RESPONSE_TYPE_TOKEN = "token";
        AuthorizationRequest3.RESPONSE_TYPE_CODE = "code";
        return AuthorizationRequest3;
      }()
    );
    exports.AuthorizationRequest = AuthorizationRequest2;
  }
});

// node_modules/@openid/appauth/built/authorization_request_handler.js
var require_authorization_request_handler = __commonJS({
  "node_modules/@openid/appauth/built/authorization_request_handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthorizationRequestHandler = exports.BUILT_IN_PARAMETERS = exports.AuthorizationNotifier = void 0;
    var logger_1 = require_logger();
    var AuthorizationNotifier2 = (
      /** @class */
      function() {
        function AuthorizationNotifier3() {
          this.listener = null;
        }
        AuthorizationNotifier3.prototype.setAuthorizationListener = function(listener) {
          this.listener = listener;
        };
        AuthorizationNotifier3.prototype.onAuthorizationComplete = function(request, response, error) {
          if (this.listener) {
            this.listener(request, response, error);
          }
        };
        return AuthorizationNotifier3;
      }()
    );
    exports.AuthorizationNotifier = AuthorizationNotifier2;
    exports.BUILT_IN_PARAMETERS = ["redirect_uri", "client_id", "response_type", "state", "scope"];
    var AuthorizationRequestHandler2 = (
      /** @class */
      function() {
        function AuthorizationRequestHandler3(utils, crypto2) {
          this.utils = utils;
          this.crypto = crypto2;
          this.notifier = null;
        }
        AuthorizationRequestHandler3.prototype.buildRequestUrl = function(configuration, request) {
          var requestMap = {
            "redirect_uri": request.redirectUri,
            "client_id": request.clientId,
            "response_type": request.responseType,
            "state": request.state,
            "scope": request.scope
          };
          if (request.extras) {
            for (var extra in request.extras) {
              if (request.extras.hasOwnProperty(extra)) {
                if (exports.BUILT_IN_PARAMETERS.indexOf(extra) < 0) {
                  requestMap[extra] = request.extras[extra];
                }
              }
            }
          }
          var query = this.utils.stringify(requestMap);
          var baseUrl = configuration.authorizationEndpoint;
          var url = baseUrl + "?" + query;
          return url;
        };
        AuthorizationRequestHandler3.prototype.completeAuthorizationRequestIfPossible = function() {
          var _this = this;
          logger_1.log("Checking to see if there is an authorization response to be delivered.");
          if (!this.notifier) {
            logger_1.log("Notifier is not present on AuthorizationRequest handler.\n          No delivery of result will be possible");
          }
          return this.completeAuthorizationRequest().then(function(result) {
            if (!result) {
              logger_1.log("No result is available yet.");
            }
            if (result && _this.notifier) {
              _this.notifier.onAuthorizationComplete(result.request, result.response, result.error);
            }
          });
        };
        AuthorizationRequestHandler3.prototype.setAuthorizationNotifier = function(notifier) {
          this.notifier = notifier;
          return this;
        };
        ;
        return AuthorizationRequestHandler3;
      }()
    );
    exports.AuthorizationRequestHandler = AuthorizationRequestHandler2;
  }
});

// node_modules/@openid/appauth/built/authorization_response.js
var require_authorization_response = __commonJS({
  "node_modules/@openid/appauth/built/authorization_response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthorizationError = exports.AuthorizationResponse = void 0;
    var AuthorizationResponse2 = (
      /** @class */
      function() {
        function AuthorizationResponse3(response) {
          this.code = response.code;
          this.state = response.state;
        }
        AuthorizationResponse3.prototype.toJson = function() {
          return { code: this.code, state: this.state };
        };
        return AuthorizationResponse3;
      }()
    );
    exports.AuthorizationResponse = AuthorizationResponse2;
    var AuthorizationError2 = (
      /** @class */
      function() {
        function AuthorizationError3(error) {
          this.error = error.error;
          this.errorDescription = error.error_description;
          this.errorUri = error.error_uri;
          this.state = error.state;
        }
        AuthorizationError3.prototype.toJson = function() {
          return {
            error: this.error,
            error_description: this.errorDescription,
            error_uri: this.errorUri,
            state: this.state
          };
        };
        return AuthorizationError3;
      }()
    );
    exports.AuthorizationError = AuthorizationError2;
  }
});

// node_modules/@openid/appauth/built/xhr.js
var require_xhr = __commonJS({
  "node_modules/@openid/appauth/built/xhr.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestRequestor = exports.FetchRequestor = exports.JQueryRequestor = exports.Requestor = void 0;
    var errors_1 = require_errors();
    var Requestor = (
      /** @class */
      function() {
        function Requestor2() {
        }
        return Requestor2;
      }()
    );
    exports.Requestor = Requestor;
    var JQueryRequestor = (
      /** @class */
      function(_super) {
        __extends(JQueryRequestor2, _super);
        function JQueryRequestor2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        JQueryRequestor2.prototype.xhr = function(settings) {
          var xhr = $.ajax(settings);
          return new Promise(function(resolve, reject) {
            xhr.then(function(data, textStatus, jqXhr) {
              resolve(data);
            }, function(jqXhr, textStatus, error) {
              reject(new errors_1.AppAuthError(error));
            });
          });
        };
        return JQueryRequestor2;
      }(Requestor)
    );
    exports.JQueryRequestor = JQueryRequestor;
    var FetchRequestor2 = (
      /** @class */
      function(_super) {
        __extends(FetchRequestor3, _super);
        function FetchRequestor3() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        FetchRequestor3.prototype.xhr = function(settings) {
          if (!settings.url) {
            return Promise.reject(new errors_1.AppAuthError("A URL must be provided."));
          }
          var url = new URL(settings.url);
          var requestInit = {};
          requestInit.method = settings.method;
          requestInit.mode = "cors";
          if (settings.data) {
            if (settings.method && settings.method.toUpperCase() === "POST") {
              requestInit.body = settings.data;
            } else {
              var searchParams = new URLSearchParams(settings.data);
              searchParams.forEach(function(value, key) {
                url.searchParams.append(key, value);
              });
            }
          }
          requestInit.headers = {};
          if (settings.headers) {
            for (var i in settings.headers) {
              if (settings.headers.hasOwnProperty(i)) {
                requestInit.headers[i] = settings.headers[i];
              }
            }
          }
          var isJsonDataType = settings.dataType && settings.dataType.toLowerCase() === "json";
          if (isJsonDataType) {
            requestInit.headers["Accept"] = "application/json, text/javascript, */*; q=0.01";
          }
          return fetch(url.toString(), requestInit).then(function(response) {
            if (response.status >= 200 && response.status < 300) {
              var contentType = response.headers.get("content-type");
              if (isJsonDataType || contentType && contentType.indexOf("application/json") !== -1) {
                return response.json();
              } else {
                return response.text();
              }
            } else {
              return Promise.reject(new errors_1.AppAuthError(response.status.toString(), response.statusText));
            }
          });
        };
        return FetchRequestor3;
      }(Requestor)
    );
    exports.FetchRequestor = FetchRequestor2;
    var TestRequestor = (
      /** @class */
      function(_super) {
        __extends(TestRequestor2, _super);
        function TestRequestor2(promise) {
          var _this = _super.call(this) || this;
          _this.promise = promise;
          return _this;
        }
        TestRequestor2.prototype.xhr = function(settings) {
          return this.promise;
        };
        return TestRequestor2;
      }(Requestor)
    );
    exports.TestRequestor = TestRequestor;
  }
});

// node_modules/@openid/appauth/built/authorization_service_configuration.js
var require_authorization_service_configuration = __commonJS({
  "node_modules/@openid/appauth/built/authorization_service_configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthorizationServiceConfiguration = void 0;
    var xhr_1 = require_xhr();
    var WELL_KNOWN_PATH = ".well-known";
    var OPENID_CONFIGURATION = "openid-configuration";
    var AuthorizationServiceConfiguration2 = (
      /** @class */
      function() {
        function AuthorizationServiceConfiguration3(request) {
          this.authorizationEndpoint = request.authorization_endpoint;
          this.tokenEndpoint = request.token_endpoint;
          this.revocationEndpoint = request.revocation_endpoint;
          this.userInfoEndpoint = request.userinfo_endpoint;
          this.endSessionEndpoint = request.end_session_endpoint;
        }
        AuthorizationServiceConfiguration3.prototype.toJson = function() {
          return {
            authorization_endpoint: this.authorizationEndpoint,
            token_endpoint: this.tokenEndpoint,
            revocation_endpoint: this.revocationEndpoint,
            end_session_endpoint: this.endSessionEndpoint,
            userinfo_endpoint: this.userInfoEndpoint
          };
        };
        AuthorizationServiceConfiguration3.fetchFromIssuer = function(openIdIssuerUrl, requestor) {
          var fullUrl = openIdIssuerUrl + "/" + WELL_KNOWN_PATH + "/" + OPENID_CONFIGURATION;
          var requestorToUse = requestor || new xhr_1.JQueryRequestor();
          return requestorToUse.xhr({ url: fullUrl, dataType: "json", method: "GET" }).then(function(json) {
            return new AuthorizationServiceConfiguration3(json);
          });
        };
        return AuthorizationServiceConfiguration3;
      }()
    );
    exports.AuthorizationServiceConfiguration = AuthorizationServiceConfiguration2;
  }
});

// node_modules/@openid/appauth/built/query_string_utils.js
var require_query_string_utils = __commonJS({
  "node_modules/@openid/appauth/built/query_string_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicQueryStringUtils = void 0;
    var BasicQueryStringUtils3 = (
      /** @class */
      function() {
        function BasicQueryStringUtils4() {
        }
        BasicQueryStringUtils4.prototype.parse = function(input, useHash) {
          if (useHash) {
            return this.parseQueryString(input.hash);
          } else {
            return this.parseQueryString(input.search);
          }
        };
        BasicQueryStringUtils4.prototype.parseQueryString = function(query) {
          var result = {};
          query = query.trim().replace(/^(\?|#|&)/, "");
          var params = query.split("&");
          for (var i = 0; i < params.length; i += 1) {
            var param = params[i];
            var parts = param.split("=");
            if (parts.length >= 2) {
              var key = decodeURIComponent(parts.shift());
              var value = parts.length > 0 ? parts.join("=") : null;
              if (value) {
                result[key] = decodeURIComponent(value);
              }
            }
          }
          return result;
        };
        BasicQueryStringUtils4.prototype.stringify = function(input) {
          var encoded = [];
          for (var key in input) {
            if (input.hasOwnProperty(key) && input[key]) {
              encoded.push(encodeURIComponent(key) + "=" + encodeURIComponent(input[key]));
            }
          }
          return encoded.join("&");
        };
        return BasicQueryStringUtils4;
      }()
    );
    exports.BasicQueryStringUtils = BasicQueryStringUtils3;
  }
});

// node_modules/@openid/appauth/built/storage.js
var require_storage = __commonJS({
  "node_modules/@openid/appauth/built/storage.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalStorageBackend = exports.StorageBackend = void 0;
    var StorageBackend = (
      /** @class */
      function() {
        function StorageBackend2() {
        }
        return StorageBackend2;
      }()
    );
    exports.StorageBackend = StorageBackend;
    var LocalStorageBackend = (
      /** @class */
      function(_super) {
        __extends(LocalStorageBackend2, _super);
        function LocalStorageBackend2(storage) {
          var _this = _super.call(this) || this;
          _this.storage = storage || window.localStorage;
          return _this;
        }
        LocalStorageBackend2.prototype.getItem = function(name) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var value = _this.storage.getItem(name);
            if (value) {
              resolve(value);
            } else {
              resolve(null);
            }
          });
        };
        LocalStorageBackend2.prototype.removeItem = function(name) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.storage.removeItem(name);
            resolve();
          });
        };
        LocalStorageBackend2.prototype.clear = function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.storage.clear();
            resolve();
          });
        };
        LocalStorageBackend2.prototype.setItem = function(name, value) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.storage.setItem(name, value);
            resolve();
          });
        };
        return LocalStorageBackend2;
      }(StorageBackend)
    );
    exports.LocalStorageBackend = LocalStorageBackend;
  }
});

// node_modules/@openid/appauth/built/redirect_based_handler.js
var require_redirect_based_handler = __commonJS({
  "node_modules/@openid/appauth/built/redirect_based_handler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RedirectRequestHandler = void 0;
    var authorization_request_1 = require_authorization_request();
    var authorization_request_handler_1 = require_authorization_request_handler();
    var authorization_response_1 = require_authorization_response();
    var crypto_utils_1 = require_crypto_utils();
    var logger_1 = require_logger();
    var query_string_utils_1 = require_query_string_utils();
    var storage_1 = require_storage();
    var authorizationRequestKey = function(handle) {
      return handle + "_appauth_authorization_request";
    };
    var authorizationServiceConfigurationKey = function(handle) {
      return handle + "_appauth_authorization_service_configuration";
    };
    var AUTHORIZATION_REQUEST_HANDLE_KEY = "appauth_current_authorization_request";
    var RedirectRequestHandler2 = (
      /** @class */
      function(_super) {
        __extends(RedirectRequestHandler3, _super);
        function RedirectRequestHandler3(storageBackend, utils, locationLike, crypto2) {
          if (storageBackend === void 0) {
            storageBackend = new storage_1.LocalStorageBackend();
          }
          if (utils === void 0) {
            utils = new query_string_utils_1.BasicQueryStringUtils();
          }
          if (locationLike === void 0) {
            locationLike = window.location;
          }
          if (crypto2 === void 0) {
            crypto2 = new crypto_utils_1.DefaultCrypto();
          }
          var _this = _super.call(this, utils, crypto2) || this;
          _this.storageBackend = storageBackend;
          _this.locationLike = locationLike;
          return _this;
        }
        RedirectRequestHandler3.prototype.performAuthorizationRequest = function(configuration, request) {
          var _this = this;
          var handle = this.crypto.generateRandom(10);
          var persisted = Promise.all([
            this.storageBackend.setItem(AUTHORIZATION_REQUEST_HANDLE_KEY, handle),
            // Calling toJson() adds in the code & challenge when possible
            request.toJson().then(function(result) {
              return _this.storageBackend.setItem(authorizationRequestKey(handle), JSON.stringify(result));
            }),
            this.storageBackend.setItem(authorizationServiceConfigurationKey(handle), JSON.stringify(configuration.toJson()))
          ]);
          persisted.then(function() {
            var url = _this.buildRequestUrl(configuration, request);
            logger_1.log("Making a request to ", request, url);
            _this.locationLike.assign(url);
          });
        };
        RedirectRequestHandler3.prototype.completeAuthorizationRequest = function() {
          var _this = this;
          return this.storageBackend.getItem(AUTHORIZATION_REQUEST_HANDLE_KEY).then(function(handle) {
            if (handle) {
              return _this.storageBackend.getItem(authorizationRequestKey(handle)).then(function(result) {
                return JSON.parse(result);
              }).then(function(json) {
                return new authorization_request_1.AuthorizationRequest(json);
              }).then(function(request) {
                var currentUri = "" + _this.locationLike.origin + _this.locationLike.pathname;
                var queryParams = _this.utils.parse(
                  _this.locationLike,
                  true
                  /* use hash */
                );
                var state = queryParams["state"];
                var code = queryParams["code"];
                var error = queryParams["error"];
                logger_1.log("Potential authorization request ", currentUri, queryParams, state, code, error);
                var shouldNotify = state === request.state;
                var authorizationResponse = null;
                var authorizationError = null;
                if (shouldNotify) {
                  if (error) {
                    var errorUri = queryParams["error_uri"];
                    var errorDescription = queryParams["error_description"];
                    authorizationError = new authorization_response_1.AuthorizationError({
                      error,
                      error_description: errorDescription,
                      error_uri: errorUri,
                      state
                    });
                  } else {
                    authorizationResponse = new authorization_response_1.AuthorizationResponse({ code, state });
                  }
                  return Promise.all([
                    _this.storageBackend.removeItem(AUTHORIZATION_REQUEST_HANDLE_KEY),
                    _this.storageBackend.removeItem(authorizationRequestKey(handle)),
                    _this.storageBackend.removeItem(authorizationServiceConfigurationKey(handle))
                  ]).then(function() {
                    logger_1.log("Delivering authorization response");
                    return {
                      request,
                      response: authorizationResponse,
                      error: authorizationError
                    };
                  });
                } else {
                  logger_1.log("Mismatched request (state and request_uri) dont match.");
                  return Promise.resolve(null);
                }
              });
            } else {
              return null;
            }
          });
        };
        return RedirectRequestHandler3;
      }(authorization_request_handler_1.AuthorizationRequestHandler)
    );
    exports.RedirectRequestHandler = RedirectRequestHandler2;
  }
});

// node_modules/@openid/appauth/built/revoke_token_request.js
var require_revoke_token_request = __commonJS({
  "node_modules/@openid/appauth/built/revoke_token_request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RevokeTokenRequest = void 0;
    var RevokeTokenRequest = (
      /** @class */
      function() {
        function RevokeTokenRequest2(request) {
          this.token = request.token;
          this.tokenTypeHint = request.token_type_hint;
          this.clientId = request.client_id;
          this.clientSecret = request.client_secret;
        }
        RevokeTokenRequest2.prototype.toJson = function() {
          var json = { token: this.token };
          if (this.tokenTypeHint) {
            json["token_type_hint"] = this.tokenTypeHint;
          }
          if (this.clientId) {
            json["client_id"] = this.clientId;
          }
          if (this.clientSecret) {
            json["client_secret"] = this.clientSecret;
          }
          return json;
        };
        RevokeTokenRequest2.prototype.toStringMap = function() {
          var json = this.toJson();
          return json;
        };
        return RevokeTokenRequest2;
      }()
    );
    exports.RevokeTokenRequest = RevokeTokenRequest;
  }
});

// node_modules/@openid/appauth/built/token_request.js
var require_token_request = __commonJS({
  "node_modules/@openid/appauth/built/token_request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenRequest = exports.GRANT_TYPE_REFRESH_TOKEN = exports.GRANT_TYPE_AUTHORIZATION_CODE = void 0;
    exports.GRANT_TYPE_AUTHORIZATION_CODE = "authorization_code";
    exports.GRANT_TYPE_REFRESH_TOKEN = "refresh_token";
    var TokenRequest2 = (
      /** @class */
      function() {
        function TokenRequest3(request) {
          this.clientId = request.client_id;
          this.redirectUri = request.redirect_uri;
          this.grantType = request.grant_type;
          this.code = request.code;
          this.refreshToken = request.refresh_token;
          this.extras = request.extras;
        }
        TokenRequest3.prototype.toJson = function() {
          return {
            grant_type: this.grantType,
            code: this.code,
            refresh_token: this.refreshToken,
            redirect_uri: this.redirectUri,
            client_id: this.clientId,
            extras: this.extras
          };
        };
        TokenRequest3.prototype.toStringMap = function() {
          var map = {
            grant_type: this.grantType,
            client_id: this.clientId,
            redirect_uri: this.redirectUri
          };
          if (this.code) {
            map["code"] = this.code;
          }
          if (this.refreshToken) {
            map["refresh_token"] = this.refreshToken;
          }
          if (this.extras) {
            for (var extra in this.extras) {
              if (this.extras.hasOwnProperty(extra) && !map.hasOwnProperty(extra)) {
                map[extra] = this.extras[extra];
              }
            }
          }
          return map;
        };
        return TokenRequest3;
      }()
    );
    exports.TokenRequest = TokenRequest2;
  }
});

// node_modules/@openid/appauth/built/token_response.js
var require_token_response = __commonJS({
  "node_modules/@openid/appauth/built/token_response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenError = exports.TokenResponse = exports.nowInSeconds = void 0;
    var AUTH_EXPIRY_BUFFER = 10 * 60 * -1;
    var nowInSeconds = function() {
      return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    };
    exports.nowInSeconds = nowInSeconds;
    var TokenResponse = (
      /** @class */
      function() {
        function TokenResponse2(response) {
          this.accessToken = response.access_token;
          this.tokenType = response.token_type || "bearer";
          if (response.expires_in) {
            this.expiresIn = parseInt(response.expires_in, 10);
          }
          this.refreshToken = response.refresh_token;
          this.scope = response.scope;
          this.idToken = response.id_token;
          this.issuedAt = response.issued_at || exports.nowInSeconds();
        }
        TokenResponse2.prototype.toJson = function() {
          var _a;
          return {
            access_token: this.accessToken,
            id_token: this.idToken,
            refresh_token: this.refreshToken,
            scope: this.scope,
            token_type: this.tokenType,
            issued_at: this.issuedAt,
            expires_in: (_a = this.expiresIn) === null || _a === void 0 ? void 0 : _a.toString()
          };
        };
        TokenResponse2.prototype.isValid = function(buffer) {
          if (buffer === void 0) {
            buffer = AUTH_EXPIRY_BUFFER;
          }
          if (this.expiresIn) {
            var now = exports.nowInSeconds();
            return now < this.issuedAt + this.expiresIn + buffer;
          } else {
            return true;
          }
        };
        return TokenResponse2;
      }()
    );
    exports.TokenResponse = TokenResponse;
    var TokenError = (
      /** @class */
      function() {
        function TokenError2(tokenError) {
          this.error = tokenError.error;
          this.errorDescription = tokenError.error_description;
          this.errorUri = tokenError.error_uri;
        }
        TokenError2.prototype.toJson = function() {
          return {
            error: this.error,
            error_description: this.errorDescription,
            error_uri: this.errorUri
          };
        };
        return TokenError2;
      }()
    );
    exports.TokenError = TokenError;
  }
});

// node_modules/@openid/appauth/built/token_request_handler.js
var require_token_request_handler = __commonJS({
  "node_modules/@openid/appauth/built/token_request_handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseTokenRequestHandler = void 0;
    var errors_1 = require_errors();
    var query_string_utils_1 = require_query_string_utils();
    var token_response_1 = require_token_response();
    var xhr_1 = require_xhr();
    var BaseTokenRequestHandler2 = (
      /** @class */
      function() {
        function BaseTokenRequestHandler3(requestor, utils) {
          if (requestor === void 0) {
            requestor = new xhr_1.JQueryRequestor();
          }
          if (utils === void 0) {
            utils = new query_string_utils_1.BasicQueryStringUtils();
          }
          this.requestor = requestor;
          this.utils = utils;
        }
        BaseTokenRequestHandler3.prototype.isTokenResponse = function(response) {
          return response.error === void 0;
        };
        BaseTokenRequestHandler3.prototype.performRevokeTokenRequest = function(configuration, request) {
          var revokeTokenResponse = this.requestor.xhr({
            url: configuration.revocationEndpoint,
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            data: this.utils.stringify(request.toStringMap())
          });
          return revokeTokenResponse.then(function(response) {
            return true;
          });
        };
        BaseTokenRequestHandler3.prototype.performTokenRequest = function(configuration, request) {
          var _this = this;
          var tokenResponse = this.requestor.xhr({
            url: configuration.tokenEndpoint,
            method: "POST",
            dataType: "json",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            data: this.utils.stringify(request.toStringMap())
          });
          return tokenResponse.then(function(response) {
            if (_this.isTokenResponse(response)) {
              return new token_response_1.TokenResponse(response);
            } else {
              return Promise.reject(new errors_1.AppAuthError(response.error, new token_response_1.TokenError(response)));
            }
          });
        };
        return BaseTokenRequestHandler3;
      }()
    );
    exports.BaseTokenRequestHandler = BaseTokenRequestHandler2;
  }
});

// node_modules/@openid/appauth/built/types.js
var require_types = __commonJS({
  "node_modules/@openid/appauth/built/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@openid/appauth/built/index.js
var require_built = __commonJS({
  "node_modules/@openid/appauth/built/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_authorization_request(), exports);
    __exportStar(require_authorization_request_handler(), exports);
    __exportStar(require_authorization_response(), exports);
    __exportStar(require_authorization_service_configuration(), exports);
    __exportStar(require_crypto_utils(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_flags(), exports);
    __exportStar(require_logger(), exports);
    __exportStar(require_query_string_utils(), exports);
    __exportStar(require_redirect_based_handler(), exports);
    __exportStar(require_revoke_token_request(), exports);
    __exportStar(require_storage(), exports);
    __exportStar(require_token_request(), exports);
    __exportStar(require_token_request_handler(), exports);
    __exportStar(require_token_response(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_xhr(), exports);
  }
});

// node_modules/bitski/dist/esm/-private/utils/callback.js
function processCallback() {
  if (window.opener) {
    notifyOpener(window.location);
  } else {
    throw new Error("Parent window could not be found");
  }
}
function notifyOpener(url) {
  if (window.opener) {
    if (url) {
      const data = parseUrlParams(url);
      if (data.state) {
        const name = `popupCallback_${data.state}`;
        const callback = window.opener[name];
        if (callback) {
          callback(url);
        } else {
          throw new Error("No callback found on opener");
        }
      } else {
        throw new Error("No state found in response");
      }
    }
  } else {
    throw new Error("No window.opener");
  }
}
function parseUrlParams(url) {
  let params;
  if (url.href.includes("#")) {
    params = extractQuery(url.hash);
  } else if (url.href.includes("?")) {
    params = url.search.split("?").pop();
  }
  if (!params) {
    throw new Error("No params found in result");
  }
  return params.split("&").reduce((prev, item) => {
    const [key, value] = item.split("=");
    if (key && value) {
      prev[decodeURIComponent(key)] = decodeURIComponent(value);
    }
    return prev;
  }, {});
}
function extractQuery(url) {
  if (!url.includes("#")) {
    throw new Error("No params found in result");
  }
  return url.split("#").pop();
}

// node_modules/bitski/dist/esm/load.js
var BITSKI_SDK_URL = "https://cdn.bitskistatic.com/js/sdk/v3.3/bitski.min.js";
var BITSKI_SDK_REGEX = /^https:\/\/cdn\.bitskistatic\.com\/js\/sdk\/v3.3\/bitski\.min\.js\/?(\?.*)?$/;
var findScript = () => {
  const scripts = document.querySelectorAll(`script[src^="${BITSKI_SDK_URL}"]`);
  for (let i = 0; i < scripts.length; i++) {
    const script = scripts[i];
    if (!BITSKI_SDK_REGEX.test(script.src)) {
      continue;
    }
    return script;
  }
  return null;
};
var injectScript = () => {
  const script = document.createElement("script");
  script.src = BITSKI_SDK_URL;
  const headOrBody = document.head || document.body;
  if (!headOrBody) {
    throw new Error("Expected document.body not to be null. The Bitski SDK requires a <body> element.");
  }
  headOrBody.appendChild(script);
  return script;
};
var bitskiPromise = null;
var windowLoadPromise = new Promise((resolve) => {
  if (typeof window === "undefined") {
    resolve(null);
    return;
  }
  if (window.document.readyState === "complete") {
    resolve(null);
    return;
  }
  window.addEventListener("load", () => resolve(null));
});
var loadScript = () => {
  if (bitskiPromise !== null) {
    return bitskiPromise;
  }
  bitskiPromise = new Promise((resolve, reject) => {
    if (globalThis.Bitski) {
      resolve(globalThis.Bitski.BitskiSDK);
      return;
    }
    if (typeof window === "undefined") {
      resolve(null);
      return;
    }
    windowLoadPromise.then(() => {
      if (window.Bitski) {
        resolve(window.Bitski.BitskiSDK);
        return;
      }
      try {
        let script = findScript();
        if (!script) {
          script = injectScript();
        }
        script.addEventListener("load", () => {
          if (window.Bitski) {
            resolve(window.Bitski.BitskiSDK);
          } else {
            reject(new Error("Bitski SDK not available"));
          }
        });
        script.addEventListener("error", () => {
          reject(new Error("Failed to load Bitski SDK"));
        });
      } catch (error) {
        reject(error);
        return;
      }
    });
  });
  return bitskiPromise;
};

// node_modules/bitski/dist/esm/provider-shim.js
var import_eth_provider_types = __toESM(require_eth_provider_types());

// node_modules/bitski/dist/esm/-private/utils/numbers.js
function toHex(number) {
  return `0x${number.toString(16)}`;
}

// node_modules/bitski/dist/esm/provider-shim.js
var extraDigits = 3;
function createRandomId() {
  const datePart = (/* @__PURE__ */ new Date()).getTime() * Math.pow(10, extraDigits);
  const extraPart = Math.floor(Math.random() * Math.pow(10, extraDigits));
  return datePart + extraPart;
}
function createResponse(error, result) {
  return {
    id: createRandomId(),
    jsonrpc: "2.0",
    error,
    result
  };
}
var BitskiProviderShim = class {
  constructor(loadSdk, options = {}) {
    this.loadSdk = loadSdk;
    this.options = options;
  }
  loadProvider() {
    if (!this.providerPromise) {
      this.providerPromise = this.loadSdk().then((sdk) => {
        if (!sdk) {
          throw new Error("Bitski SDK not found");
        }
        return sdk.createProvider(this.options);
      });
    }
    return this.providerPromise;
  }
  // TODO: Update types in v4 to use eth-provider-types
  async request({ method, params = [] }) {
    const provider = await this.loadProvider();
    return provider.request({ method, params });
  }
  on(eventName, listener) {
    this.loadProvider().then((provider) => provider.on(eventName, listener));
  }
  removeListener(eventName, listener) {
    this.loadProvider().then((provider) => provider.removeListener(eventName, listener));
  }
  send(methodOrPayload, paramsOrCallback) {
    if (typeof methodOrPayload !== "string" && !Array.isArray(paramsOrCallback)) {
      return this.sendAsync(methodOrPayload, paramsOrCallback);
    }
    return this.request({ method: methodOrPayload, params: paramsOrCallback }).then((result) => {
      return createResponse(void 0, result);
    }).catch((err) => {
      return createResponse(err);
    });
  }
  /**
   * @deprecated Please use `.request` instead.
   */
  sendAsync(payload, callback) {
    this.request(payload).then((response) => {
      callback(null, createResponse(void 0, response));
    }).catch((err) => {
      callback(err);
    });
  }
  // method used externally to set provider
  setNetwork(network) {
    this.providerPromise = this.loadProvider().then(async (provider) => {
      await provider.request({
        method: import_eth_provider_types.EthMethod.wallet_addEthereumChain,
        params: [
          {
            chainId: toHex(network.chainId),
            rpcUrls: [network.rpcUrl]
          }
        ]
      });
      await provider.request({
        method: import_eth_provider_types.EthMethod.wallet_switchEthereumChain,
        params: [{ chainId: toHex(network.chainId) }]
      });
      return provider;
    });
  }
  supportsSubscriptions() {
    return true;
  }
  isConnected() {
    return true;
  }
  /**
   * @deprecated currentBlock is no longer exposed directly, use subscriptions or filters instead
   */
  get currentBlock() {
    return void 0;
  }
  /**
   * @deprecated call request with eth_subscribe directly instead
   */
  subscribe(_subscribeMethod, subscriptionMethod, params) {
    console.warn("BitskiProvider#subscribe() is deprecated. It is no longer necessary to call this method.");
    return Promise.resolve("");
  }
  /**
   * @deprecated call request with eth_ussubscribe directly instead
   */
  unsubscribe(subscriptionId, _unsubscribeMethod) {
    console.warn("BitskiProvider#unsubscribe() is deprecated. It is no longer necessary to call this method.");
    return Promise.resolve(true);
  }
  /**
   * @deprecated BitskiSDK is always running
   */
  isRunning() {
    console.warn("BitskiProvider#isRunning() is deprecated. It is no longer necessary to call this method.");
    return true;
  }
  /**
   * @deprecated BitskiSDK does not need to be started anymore
   */
  start() {
    console.warn("BitskiProvider#start() is deprecated. It is no longer necessary to call this method.");
  }
  /**
   * @deprecated BitskiSDK does not need to be stopped anymore. Unsubscribe from all active
   * subscriptions instead.
   */
  stop() {
    console.warn("BitskiProvider#stop() is deprecated. It is no longer necessary to call this method.");
  }
  /**
   * @deprecated BitskiSDK does not support custom providers anymore
   */
  addProvider(_source, _index) {
    console.warn("BitskiProvider#addProvider() is deprecated. It is no longer necessary to call this method.");
  }
  /**
   * @deprecated BitskiSDK does not support custom providers anymore
   */
  removeProvider(source) {
    console.warn("BitskiProvider#removeProvider() is deprecated. It is no longer necessary to call this method.");
  }
};

// node_modules/bitski/dist/esm/-private/auth/oauth-manager.js
var import_appauth3 = __toESM(require_built());

// node_modules/bitski/dist/esm/-private/constants.js
var OAuthSignInMethod;
(function(OAuthSignInMethod2) {
  OAuthSignInMethod2["Redirect"] = "REDIRECT";
  OAuthSignInMethod2["Popup"] = "POPUP";
  OAuthSignInMethod2["Silent"] = "SILENT";
})(OAuthSignInMethod || (OAuthSignInMethod = {}));
var AuthenticationStatus;
(function(AuthenticationStatus2) {
  AuthenticationStatus2["Connected"] = "CONNECTED";
  AuthenticationStatus2["Expired"] = "EXPIRED";
  AuthenticationStatus2["NotConnected"] = "NOT_CONNECTED";
})(AuthenticationStatus || (AuthenticationStatus = {}));

// node_modules/bitski/dist/esm/-private/utils/no-hash-query-string-utils.js
var import_appauth = __toESM(require_built());

// node_modules/bitski/dist/esm/-private/auth/popup-handler.js
var import_appauth2 = __toESM(require_built());

// node_modules/bitski/dist/esm/-private/auth/oauth-manager.js
var USER_CANCELLED_MESSAGE = "Sign in request was cancelled.";

// node_modules/bitski/dist/esm/-private/components/connect-button.js
var ConnectButtonSize;
(function(ConnectButtonSize2) {
  ConnectButtonSize2["Small"] = "SMALL";
  ConnectButtonSize2["Medium"] = "MEDIUM";
  ConnectButtonSize2["Large"] = "LARGE";
})(ConnectButtonSize || (ConnectButtonSize = {}));
var ConnectButton = class {
  /**
   * @param authProvider An instance of an AuthProvider to process sign in requests.
   * @param options Optional ConnectButtonOptions to configure your button.
   * @param callback Optional callback to be called after successful or failed log in attempt.
   * You can also set this directly later with the `callback` property.
   */
  constructor(loadSDK, options, callback, getProvider) {
    this.getProvider = getProvider;
    options = options || {};
    this.loadSDK = loadSDK;
    this.size = options.size || ConnectButtonSize.Medium;
    this.authIntegrationType = options.authMethod || OAuthSignInMethod.Popup;
    this.callback = callback;
    this.signInOptions = options.signInOptions || {};
    this.element = document.createElement("button");
    this.configureElement();
    this.element.addEventListener("click", this.signin.bind(this));
    if (options.container) {
      options.container.appendChild(this.element);
    }
  }
  /**
   * Removes the button from the page
   */
  remove() {
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
  async signin() {
    const sdk = await this.loadSDK();
    if (sdk === null) {
      throw new Error("Bitski SDK is not available");
    }
    try {
      const user = await sdk.signInOrConnect(this.authIntegrationType, this.signInOptions);
      if (this.getProvider) {
        window.ethereum = this.getProvider();
      }
      if (this.callback) {
        this.callback(void 0, user);
      }
    } catch (error) {
      if (error instanceof Error && error.message === USER_CANCELLED_MESSAGE) {
        if (this.onCancel) {
          this.onCancel();
        }
      } else if (this.callback) {
        this.callback(error, void 0);
      }
    }
  }
  configureElement() {
    this.element.title = "Continue with Bitski";
    this.element.innerText = "Continue with Bitski";
    this.element.className = "bitski-connect-button";
    let sizeClass = "";
    switch (this.size) {
      case ConnectButtonSize.Small:
        sizeClass = "size-small";
        break;
      case ConnectButtonSize.Medium:
        sizeClass = "size-medium";
        break;
      case ConnectButtonSize.Large:
        sizeClass = "size-large";
        break;
    }
    this.element.classList.add(sizeClass);
  }
};

// node_modules/bitski/dist/esm/-private/network.js
var Mainnet = {
  chainId: 1,
  rpcUrl: "https://api.bitski.com/v1/web3/mainnet"
};
var Goerli = {
  chainId: 5,
  rpcUrl: "https://api.bitski.com/v1/web3/goerli"
};
var Polygon = {
  chainId: 137,
  rpcUrl: "https://api.bitski.com/v1/web3/polygon"
};
var Mumbai = {
  chainId: 80001,
  rpcUrl: "https://api.bitski.com/v1/web3/mumbai"
};
var BinanceSmartChain = {
  chainId: 56,
  rpcUrl: "https://api.bitski.com/v1/web3/bsc"
};
var BinanceSmartChainTestnet = {
  chainId: 97,
  rpcUrl: "https://api.bitski.com/v1/web3/bnbt"
};

// node_modules/bitski/dist/esm/index.js
var Bitski = class {
  /**
   * @param clientId OAuth Client ID
   * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.
   * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].
   * Note: Make sure your app is approved for the scopes you are requesting first.
   * @param options Other OAuth settings. Don't change these unless you know what you are doing.
   */
  constructor(clientId, redirectUri, additionalScopes, options) {
    this.clientId = clientId;
    this.redirectUri = redirectUri;
    this.additionalScopes = additionalScopes;
    this.options = options;
  }
  /**
   * Alternative to using our static callback.html file. Call this from your own redirect page.
   */
  static callback() {
    processCallback();
  }
  /**
   * Returns a new web3 provider for a given network.
   * @param options options for the provider, or a network name
   */
  getProvider(options) {
    var _a;
    if (typeof window !== "undefined" && ((_a = window.Bitski) === null || _a === void 0 ? void 0 : _a.getProvider)) {
      return window.Bitski.getProvider(options);
    }
    const network = networkFromProviderOptions(options);
    let provider = this.provider;
    if (!provider) {
      this.provider = provider = new BitskiProviderShim(() => this.loadSDK(), typeof options === "string" ? void 0 : options);
    }
    if (network) {
      provider.setNetwork(network);
    }
    return provider;
  }
  /**
   * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the
   * first parameter, it will automatically add it to the DOM inside that element. Make sure to add
   * a callback to get notified of login events.
   * @param options {ConnectButtonOptions} Optional configuration for the button
   * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.
   */
  getConnectButton(options, callback) {
    return new ConnectButton(() => this.loadSDK(), options, callback, () => this.getProvider());
  }
  /**
   * Reinitalizes the SDK after the page has been reloaded, and bootstraps window.ethereum.
   * This method should be called always, and immediately after the page loads.
   */
  async initialize() {
    var _a, _b, _c;
    const localStorageKeys = await ((_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.store) === null || _b === void 0 ? void 0 : _b.keys) === null || _c === void 0 ? void 0 : _c.call(_b)) || Object.keys(localStorage);
    if (!localStorageKeys.find((key) => key.startsWith("bitski"))) {
      return;
    }
    await this.connect();
    this.bootstrapProvider();
  }
  /**
   * Signs in or connects to bitski depending on the user's auth state.
   * Since it may open a popup, this method must be called from user interaction handler,
   * such as a click or tap handler.
   * @param options Provide SignInOptions for the sign in request. See signIn() for more info.
   */
  start(options) {
    return this.ensureSDK().then((sdk) => sdk.signInOrConnect(void 0, options)).then((user) => {
      this.bootstrapProvider();
      return user;
    });
  }
  /**
   * Check the logged in state of the user
   */
  getAuthStatus() {
    return this.ensureSDK().then((sdk) => sdk.getAuthStatus());
  }
  /**
   * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.
   * @param options Optionally provide additional options for the sign in request.
   *
   * You can use the options parameter to request that we show the sign up form instead of the sign in form:
   * ```javascript
   * import { LOGIN_HINT_SIGNUP } from 'bitski';
   *
   * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });
   * ```
   */
  signIn(options) {
    return this.ensureSDK().then((sdk) => sdk.signIn(options)).then((user) => {
      this.bootstrapProvider();
      return user;
    });
  }
  /**
   * Gets the current signed in user. Will reject if we are not signed in.
   */
  async getUser() {
    return this.ensureSDK().then((sdk) => sdk.getUser());
  }
  /**
   * Connects to bitski to get a valid access token if possible.
   */
  async connect() {
    return this.ensureSDK().then((sdk) => sdk.connect());
  }
  /**
   * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.
   * @param options Optionally provide additional options for the sign in request. See signIn() for more info.
   */
  signInRedirect(options) {
    this.ensureSDK().then((sdk) => sdk.signInRedirect(options));
  }
  /**
   * Call from your oauth redirect page.
   */
  async redirectCallback() {
    return this.ensureSDK().then((sdk) => sdk.redirectCallback()).then((user) => {
      this.bootstrapProvider();
      return user;
    });
  }
  /**
   * Retrieves the current access token for the user, if logged in.
   */
  async getCurrentAccessToken() {
    return this.ensureSDK().then((sdk) => sdk.getCurrentAccessToken());
  }
  /**
   * Retrieves the current ID token for the user, if logged in.
   */
  getCurrentIdToken() {
    return this.ensureSDK().then((sdk) => sdk.getCurrentIdToken());
  }
  /**
   * Retrieves the current refresh token for the user, if logged in.
   * Requires that the user has approved your application for offline access.
   */
  getCurrentRefreshToken() {
    return this.ensureSDK().then((sdk) => sdk.getCurrentRefreshToken());
  }
  /**
   * Register a callback to be called on sign out. This is a good practice,
   * since there may be situations where you are signed out unexpectedly.
   * @param fn Your callback function
   */
  addSignOutHandler(fn) {
    return this.ensureSDK().then((sdk) => sdk.addSignOutHandler(fn));
  }
  /**
   * Remove a registered signout callback
   * @param fn Your callback function
   */
  removeSignOutHandler(fn) {
    return this.ensureSDK().then((sdk) => sdk.removeSignOutHandler(fn));
  }
  /**
   * Sign the current user out of your application.
   */
  signOut() {
    return this.ensureSDK().then((sdk) => sdk.signOut());
  }
  bootstrapProvider() {
    if (typeof window !== void 0) {
      window.ethereum = this.getProvider();
    }
  }
  loadSDK() {
    if (!this.sdk) {
      this.sdk = loadScript().then((BitskiSDK) => {
        return BitskiSDK ? new BitskiSDK(this.clientId, this.redirectUri, this.additionalScopes, this.options) : null;
      });
    }
    return this.sdk;
  }
  async ensureSDK() {
    const sdk = await this.loadSDK();
    if (!sdk) {
      throw new Error("Bitski SDK not available");
    }
    return sdk;
  }
};
var LOGIN_HINT_SIGNUP = "signup";
function networkFromName(networkName) {
  switch (networkName) {
    case "":
    case "mainnet":
      return Mainnet;
    case "goerli":
      return Goerli;
    case "polygon":
      return Polygon;
    case "mumbai":
      return Mumbai;
    case "bnb":
      return BinanceSmartChain;
    case "bnbt":
      return BinanceSmartChainTestnet;
    default:
      throw new Error(`Unsupported network name ${networkName}. Try passing a \`network\` in the options instead.`);
  }
}
function networkFromProviderOptions(options) {
  if (typeof options === "string") {
    return networkFromName(options);
  }
  if (options === null || options === void 0 ? void 0 : options.network) {
    return options.network;
  }
  if (options === null || options === void 0 ? void 0 : options.networkName) {
    return networkFromName(options.networkName);
  }
}
export {
  AuthenticationStatus,
  BinanceSmartChain,
  BinanceSmartChainTestnet,
  Bitski,
  Goerli,
  LOGIN_HINT_SIGNUP,
  Mainnet,
  Mumbai,
  OAuthSignInMethod,
  Polygon
};
//# sourceMappingURL=bitski.js.map
